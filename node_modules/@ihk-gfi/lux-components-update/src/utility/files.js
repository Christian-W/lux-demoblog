"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const logging_1 = require("./logging");
/**
 * Entfernt eine Zeile aus der Datei, die den searchString beinhaltet.
 * Gibt eine Log-Ausgabe aus, wenn die Datei nicht gefunden werden konnte.
 * @param tree
 * @param context
 * @param filePath
 * @param searchString
 */
function deleteLineFromFile(tree, context, filePath, searchString) {
    const fileContent = tree.read(filePath);
    if (fileContent) {
        // String der Datei erhalten
        let content = fileContent.toString();
        if (content.indexOf(searchString) !== -1) {
            // Standard-Separator
            let separator = '\r\n';
            // Wenn nicht gefunden, nur \n als Separator nutzen
            if (content.indexOf(separator) === -1) {
                separator = '\n';
            }
            // Alle Zeilen der Datei erhalten
            const lines = content.split(separator);
            // Lines iterieren und nach der dependency suchen
            for (let line of lines) {
                // Wenn gefunden, die Zeile entfernen
                if (line.indexOf(searchString) > -1) {
                    content = content.replace(line, '');
                }
            }
            // Doppelte Zeilenumbrüche entfernen
            content = content.replace(new RegExp('\r\n', 'g'), '\r\n');
            content = content.replace(new RegExp('\r\n\r\n', 'g'), '\r\n');
            tree.overwrite(filePath, content);
        }
        else {
            logging_1.logInfo(`Die Datei "${filePath}" enthält den String "${searchString}" nicht.`);
        }
    }
    else {
        logging_1.logInfo(`Die Datei "${filePath}" wurde nicht gefunden.`);
    }
}
exports.deleteLineFromFile = deleteLineFromFile;
/**
 * Schreibt die übergebenen Zeilen in die Datei.
 * Wenn die Datei existiert, wird der neue Inhalt am Ende der Datei angehangen.
 * Wenn die Datei nicht exitiert, wird diese mit dem Inhalt erstellt.
 * @param tree
 * @param context
 * @param filePath
 * @param lines
 */
function writeLinesToFile(tree, context, filePath, ...lines) {
    const fileContent = tree.read(filePath);
    let content = '';
    lines.forEach((line) => {
        if (fileContent && fileContent.toString().indexOf(line) === -1) {
            content += line + '\r\n';
        }
    });
    if (fileContent !== null) {
        tree.overwrite(filePath, fileContent.toString() + '\r\n' + content);
        logging_1.logInfo(`Überschreibe die Datei "${filePath}".`);
    }
    else {
        tree.create(filePath, content);
        logging_1.logInfo(`Erstelle die Datei "${filePath}" und füge Inhalt hinzu.`);
    }
}
exports.writeLinesToFile = writeLinesToFile;
/**
 * Iteriert über alle Dateien vom Root-Pfad aus.
 * Über die filePathEndings lassen sich Einschränkungen bzgl. des Datei-Typs festlegen (z.B. .html).
 * Wenn eine Datei die passende Endung und Inhalt hat, wird der Callback mit Pfad und Content aufgerufen.
 * @param tree
 * @param rootPath
 * @param callback(filePath, content)
 * @param filePathEndings Z.B. .html, .ts, src/styles.scss,...
 */
function iterateFilesAndModifyContent(tree, rootPath, callback, ...filePathEndings) {
    tree.getDir(rootPath)
        .visit((filePath) => {
        // Ignoriere folende Odner
        if (filePath.startsWith('/node_modules/') ||
            filePath.startsWith('/.idea/') ||
            filePath.startsWith('/coverage/') ||
            filePath.startsWith('/dist/')) {
            return;
        }
        // Endung der Datei mit erlaubten Endungen abgleichen
        let modifyFile = false;
        for (let fileEnding of filePathEndings) {
            if (filePath.endsWith(fileEnding)) {
                modifyFile = true;
                break;
            }
        }
        // Besitzt die Datei die richtige Endung?
        if (!modifyFile) {
            return;
        }
        // Inhalt auslesen
        const content = tree.read(filePath);
        // Wenn die Datei keinen Inhalt hat, die nächste Datei aufrufen
        if (!content) {
            return;
        }
        // Callback mit aktuellem Pfad + Inhalt der Datei aufrufen
        callback(filePath, content.toString());
    });
}
exports.iterateFilesAndModifyContent = iterateFilesAndModifyContent;
/**
 * Diese Methode ersetzt die angegebene Dateien. Sollten diese nicht existieren, werden sie neu angelegt.
 *
 * @param options Die Optionen.
 * @param sourcePath Ein Quellpfad (z.B. files/theming für alle Dateien unter /theming).
 * @param targetPath Ein Zielpfad (z.B. src/theming/).
 */
function moveFilesToDirectory(options, sourcePath, targetPath) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Aktualisiere Dateien in ' + targetPath);
        if (!targetPath.startsWith('/')) {
            targetPath = '/' + targetPath;
        }
        if (!sourcePath.startsWith('/')) {
            sourcePath = '/' + sourcePath;
        }
        targetPath = options.path + targetPath;
        const templateSource = schematics_1.apply(schematics_1.url('.' + sourcePath), [
            schematics_1.template(Object.assign({}, core_1.strings, options)),
            schematics_1.forEach((file) => {
                if (tree.exists(targetPath + file.path)) {
                    tree.overwrite(targetPath + file.path, file.content);
                }
                else {
                    tree.create(targetPath + file.path, file.content);
                }
                return null;
            })
        ]);
        logging_1.logSuccess(targetPath + ' erfolgreich aktualisiert.');
        return schematics_1.mergeWith(templateSource, schematics_1.MergeStrategy.Overwrite);
    };
}
exports.moveFilesToDirectory = moveFilesToDirectory;
function searchInComponentAndModifyModule(tree, rootPath, searchStrings, callback, ...filePathEndings) {
    tree.getDir(rootPath)
        .visit((filePath) => {
        // Ignoriere folende Odner
        if (filePath.startsWith('/node_modules/') ||
            filePath.startsWith('/.idea/') ||
            filePath.startsWith('/coverage/') ||
            filePath.startsWith('/dist/') ||
            filePath.endsWith('.spec.ts')) {
            return;
        }
        // Endung der Datei mit erlaubten Endungen abgleichen
        let modifyFile = false;
        for (let fileEnding of filePathEndings) {
            if (filePath.endsWith(fileEnding)) {
                modifyFile = true;
                break;
            }
        }
        // Besitzt die Datei die richtige Endung?
        if (!modifyFile) {
            return;
        }
        // Inhalt auslesen
        const content = tree.read(filePath);
        // Wenn die Datei keinen Inhalt hat, die nächste Datei aufrufen
        if (!content) {
            return;
        }
        let foundSearchString = '';
        searchStrings.forEach((searchString) => {
            if (!foundSearchString && content.toString().indexOf(searchString) > -1) {
                foundSearchString = searchString;
            }
        });
        if (!foundSearchString) {
            return;
        }
        // den Ordner der gefundenen Datei nehmen
        const fileDir = filePath.substring(0, filePath.lastIndexOf('/'));
        const modulePath = findModule(tree, fileDir);
        let moduleContent = tree.read(modulePath);
        if (moduleContent) {
            // Callback mit aktuellem Pfad + Inhalt der Datei aufrufen
            callback(modulePath, moduleContent.toString());
        }
    });
}
exports.searchInComponentAndModifyModule = searchInComponentAndModifyModule;
/**
 * Function to find the "closest" module to a generated file's path.
 *
 * Source: https://github.com/angular/angular-cli/blob/master/packages/schematics/angular/utility/find-module.ts
 */
function findModule(host, generateDir, moduleExt = '.module.ts', routingModuleExt = '-routing.module.ts') {
    let dir = host.getDir('/' + generateDir);
    let foundRoutingModule = false;
    while (dir) {
        const allMatches = dir.subfiles.filter(p => p.endsWith(moduleExt));
        const filteredMatches = allMatches.filter(p => !p.endsWith(routingModuleExt));
        foundRoutingModule = foundRoutingModule || allMatches.length !== filteredMatches.length;
        if (filteredMatches.length == 1) {
            return core_1.join(dir.path, filteredMatches[0]);
        }
        else if (filteredMatches.length > 1) {
            throw new Error('More than one module matches. Use skip-import option to skip importing '
                + 'the component into the closest module.');
        }
        dir = dir.parent;
    }
    const errorMsg = foundRoutingModule ? 'Could not find a non Routing NgModule.'
        + `\nModules with suffix '${routingModuleExt}' are strictly reserved for routing.`
        + '\nUse the skip-import option to skip importing in NgModule.'
        : 'Could not find an NgModule. Use the skip-import option to skip importing in NgModule.';
    throw new Error(errorMsg);
}
exports.findModule = findModule;
/**
 * Löscht die Datei aus dem gegebenen Pfad.
 * @param options
 * @param targetPath
 */
function deleteFile(options, targetPath) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Lösche Datei ' + targetPath + '.');
        if (!targetPath.startsWith('/')) {
            targetPath = '/' + targetPath;
        }
        targetPath = options.path + targetPath;
        if (tree.exists(targetPath)) {
            tree.delete(targetPath);
            logging_1.logSuccess(targetPath + ' erfolgreich gelöscht.');
        }
        else {
            logging_1.logSuccess(targetPath + ' konnte nicht gefunden werden.');
        }
        return tree;
    };
}
exports.deleteFile = deleteFile;
//# sourceMappingURL=files.js.map