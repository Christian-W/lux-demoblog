"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const json_utils_1 = require("@schematics/angular/utility/json-utils");
const semver = require("semver");
const chalk_1 = require("chalk");
const logging_1 = require("./logging");
const files_1 = require("./files");
const packageJsonPath = '/package.json';
var NodeDependencyType;
(function (NodeDependencyType) {
    NodeDependencyType["Default"] = "dependencies";
    NodeDependencyType["Dev"] = "devDependencies";
    NodeDependencyType["Peer"] = "peerDependencies";
    NodeDependencyType["Optional"] = "optionalDependencies";
})(NodeDependencyType = exports.NodeDependencyType || (exports.NodeDependencyType = {}));
/**
 * Aktualisiert eine Dependency in der package.json bzw. fügt diese hinzu, falls sie noch nicht vorhanden ist.
 * @param tree
 * @param context
 * @param dependency
 */
function updatePackageJsonDependency(tree, context, dependency) {
    const packageJson = readPackageJson(tree);
    const dependencyTypeNode = json_utils_1.findPropertyInAstObject(packageJson, dependency.type);
    const recorder = tree.beginUpdate(packageJsonPath);
    // Dependency-Typ existiert noch nicht (z.B. devDependencies oder peerDependencies)
    if (!dependencyTypeNode) {
        // Den Dependency-Typ und die Dependency hinzufügen
        json_utils_1.appendPropertyInAstObject(recorder, packageJson, dependency.type, {
            [dependency.name]: dependency.version
        }, 2);
    }
    // Der Dependency-Typ existiert bereits
    else if (dependencyTypeNode.kind === 'object') {
        // Prüfen ob die Dependency bereits darin vorhanden ist
        const dependencyNode = json_utils_1.findPropertyInAstObject(dependencyTypeNode, dependency.name);
        // Diese Dependency gibt es noch nicht
        if (!dependencyNode) {
            json_utils_1.insertPropertyInAstObjectInOrder(recorder, dependencyTypeNode, dependency.name, dependency.version, 4);
            logging_1.logInfo(`Dependency ` + chalk_1.default.greenBright(`${dependency.name}`) + ` nicht gefunden. Füge Sie zum Typ "${dependency.type}" hinzu.`);
        }
        // Diese Dependency existiert bereits
        else {
            const packageJsonDependency = getPackageJsonDependency(tree, dependency.name);
            // Die Dependency ist in einer älteren Version vorhanden
            if (semver.cmp(packageJsonDependency.version.replace(/([\^~])/g, ''), "<", dependency.version)) {
                const { end, start } = dependencyNode;
                // Die alte Version entfernen
                recorder.remove(start.offset, end.offset - start.offset);
                // Die neue hinzufügen
                recorder.insertRight(start.offset, JSON.stringify(dependency.version));
                logging_1.logInfo(`Dependency ` + chalk_1.default.greenBright(`${dependency.name}`) + ` gefunden. Aktualisiere die Version.`);
            }
            else if (semver.cmp(packageJsonDependency.version.replace(/([\^~])/g, ''), "===", dependency.version)) {
                if (packageJsonDependency.version !== dependency.version) {
                    const { end, start } = dependencyNode;
                    // Die alte Version entfernen
                    recorder.remove(start.offset, end.offset - start.offset);
                    // Die neue hinzufügen
                    recorder.insertRight(start.offset, JSON.stringify(dependency.version));
                    logging_1.logInfo(`Dependency ` + chalk_1.default.greenBright(`${dependency.name}`) + ` gefunden. ^ oder ~ entfernt.`);
                }
            }
            else if (semver.cmp(packageJsonDependency.version.replace(/([\^~])/g, ''), ">", dependency.version)) {
                logging_1.logWarn(`Dependency ` + chalk_1.default.greenBright(`${dependency.name}`) + ` gefunden. Die aktuelle Version ` + packageJsonDependency.version + ` ist größer als ` + dependency.version + `. Die Version bestehende Version wurde nicht aktualisiert.`);
            }
            else {
                logging_1.logInfo(`Dependency ` + chalk_1.default.greenBright(`${dependency.name}`) + ` gefunden. Die Version ist i.O.`);
            }
        }
    }
    tree.commitUpdate(recorder);
}
exports.updatePackageJsonDependency = updatePackageJsonDependency;
/**
 *
 * @param tree
 * @param context
 * @param dependency
 */
function deletePackageJsonDependency(tree, context, dependency) {
    files_1.deleteLineFromFile(tree, context, packageJsonPath, dependency.name);
}
exports.deletePackageJsonDependency = deletePackageJsonDependency;
/**
 * Versucht eine Dependency aus der package.json auslesen und gibt diese zurück.
 * @param tree
 * @param name
 */
function getPackageJsonDependency(tree, name) {
    const packageJson = readPackageJson(tree);
    let dependency = null;
    [NodeDependencyType.Default, NodeDependencyType.Dev, NodeDependencyType.Optional, NodeDependencyType.Peer].forEach(depType => {
        const depsNode = json_utils_1.findPropertyInAstObject(packageJson, depType);
        if (depsNode !== null && depsNode.kind === 'object') {
            const depNode = json_utils_1.findPropertyInAstObject(depsNode, name);
            if (depNode !== null && depNode.kind === 'string') {
                dependency = {
                    type: depType,
                    name: name,
                    version: depNode.value
                };
            }
        }
    });
    if (dependency) {
        return dependency;
    }
    else {
        throw logging_1.formattedSchematicsException(`Dependency ${name ? '"' + name + '"' : ''} nicht in der package.json gefunden.`);
    }
}
exports.getPackageJsonDependency = getPackageJsonDependency;
/**
 * Liest die package.json des Projekts aus und wirft Fehlermeldungen, sollte die package.json nicht gefunden oder
 * in einem falschen Format sein.
 * @param context
 * @param tree
 */
function readPackageJson(tree) {
    const buffer = tree.read(packageJsonPath);
    if (buffer === null) {
        throw logging_1.formattedSchematicsException('Konnte die package.json nicht lesen.');
    }
    const content = buffer.toString();
    const packageJson = core_1.parseJsonAst(content, core_1.JsonParseMode.Strict);
    if (packageJson.kind != 'object') {
        throw logging_1.formattedSchematicsException('Ungültige package.json, ein Object wurde erwartet.');
    }
    return packageJson;
}
//# sourceMappingURL=dependencies.js.map