"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const scripts_1 = require("./scripts");
const logging_1 = require("./logging");
const chalk_1 = require("chalk");
const tasks_1 = require("@angular-devkit/schematics/tasks");
/**
 * Konfig-Objekt für einige Util-Methoden.
 * Ermöglicht z.B. die Standard-Dauer des waitForTreeCallback-Aufrufs zu ändern
 */
exports.UtilConfig = {
    defaultWaitMS: 4000
};
function escapeRegExp(str) {
    return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
}
exports.escapeRegExp = escapeRegExp;
function replaceAll(str, find, replace) {
    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
}
exports.replaceAll = replaceAll;
/**
 * Wartet die übergebene Zeitspanne und ruft dann den Callback auf.
 * Gibt anschließend den Tree über ein Observable zurück.
 * @param tree
 * @param callback
 * @param waitMS
 */
exports.waitForTreeCallback = (tree, callback, waitMS = exports.UtilConfig.defaultWaitMS) => {
    return new rxjs_1.Observable((subscriber) => {
        rxjs_1.of(callback()).pipe(operators_1.delay(waitMS)).subscribe((callbackResult) => {
            if (callbackResult instanceof rxjs_1.Observable) {
                callbackResult.subscribe((result) => {
                    subscriber.next(result);
                    subscriber.complete();
                });
            }
            else {
                subscriber.next(callbackResult);
                subscriber.complete();
            }
        }, (error) => {
            subscriber.error(error.message);
        });
    });
};
/**
 * Prüft, ob das smoketest-Skript in der package.json enthalten ist.
 * Wenn nicht, wird dieses hinzugefügt.
 */
exports.checkSmoketestScriptExists = (tree, context) => {
    logging_1.logInfo(`Prüfe, ob das ${chalk_1.default.redBright('smoketest')}-Skript bereits existiert.`);
    const script = {
        name: 'smoketest',
        command: 'npm run test_single_run && npm run build-aot && npm run lint --bailOnLintError true',
        overwrite: true
    };
    scripts_1.controlPackageJsonScript(tree, context, script);
    logging_1.logSuccess('Prüfung abgeschlossen.');
};
/**
 * Führt npm install aus und wartet auf den Abschluss des Prozess für diese Schematic.
 * Wenn dieses eintritt, werden die Hinweise und ToDos ausgegeben.
 * @param context
 * @param toDoMessages
 */
exports.runInstallAndLogToDos = (context, ...toDoMessages) => {
    // diese log-Ausgaben werden erst ganz zum Schluss ausgeführt (nach Update und npm-install logs)
    process.addListener('exit', () => {
        logging_1.logInfo('\r\n');
        logging_1.logWarn('WICHTIGE HINWEISE ZUM UPDATE: \r\n');
        toDoMessages.forEach((message) => {
            logging_1.logInfo(message + '\r\n');
        });
    });
    // npm install starten
    context.addTask(new tasks_1.NodePackageInstallTask());
};
//# sourceMappingURL=util.js.map