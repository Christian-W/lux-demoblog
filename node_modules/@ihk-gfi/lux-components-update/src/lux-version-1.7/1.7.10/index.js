"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const project_1 = require("@schematics/angular/utility/project");
const validation_1 = require("../../utility/validation");
const dependencies_1 = require("../../utility/dependencies");
const logging_1 = require("../../utility/logging");
const files_1 = require("../../utility/files");
const chalk_1 = require("chalk");
const util_1 = require("../../utility/util");
/**
 * Haupt-Rule für diesen Schematic-Generator.
 * @param options
 */
exports.luxVersion = (options) => {
    return schematics_1.chain([
        setupProject(options),
        checkVersions(),
        updatePackageJson(),
        updateLuxStylesScss(options),
        updateLuxAppFooterButtonInfoConstructorParams(options),
        todosForUser()
    ]);
};
/**
 * Prüft, ob die Property "project" gesetzt ist und
 * erstellt wenn nötig einen Standard-Pfad zum Projekt, wenn keiner bekannt ist.
 * @param options
 */
function setupProject(options) {
    return (tree, context) => {
        logging_1.logNewUpdate('1.7.10');
        logging_1.logInfoWithDescriptor('Starte Konfiguration der Schematic.');
        return util_1.waitForTreeCallback(tree, () => {
            if (!options.project) {
                throw logging_1.formattedSchematicsException('Option "project" wird benötigt.');
            }
            const project = project_1.getProject(tree, options.project);
            if (options.path === undefined) {
                options.path = project.root;
            }
            util_1.checkSmoketestScriptExists(tree, context);
            logging_1.logSuccess(`Schematic-Konfiguration für Projekt "${options.project}" erfolgreich.`);
            return tree;
        });
    };
}
exports.setupProject = setupProject;
/**
 * Prüft ob die Versionen des Projekts mit den erforderlichen Versionen dieses Updates übereinstimmen.
 */
function checkVersions() {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Starte die Versionsprüfung.');
        return util_1.waitForTreeCallback(tree, () => {
            const minimumLuxComponentsVersion = '1.7.9';
            validation_1.validateLuxComponentsVersion(tree, context, minimumLuxComponentsVersion);
            const minimumNodeVersion = '8.0.0';
            validation_1.validateNodeVersion(context, minimumNodeVersion);
            logging_1.logSuccess(`Versionen erfolgreich geprüft.`);
            return tree;
        });
    };
}
exports.checkVersions = checkVersions;
/**
 * Aktualisiert die package.json des Projekts.
 */
function updatePackageJson() {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Aktualisiere LUX-Components Version auf 1.7.10');
        return util_1.waitForTreeCallback(tree, () => {
            const newDependency = {
                type: dependencies_1.NodeDependencyType.Default,
                version: '1.7.10',
                name: 'lux-components'
            };
            dependencies_1.updatePackageJsonDependency(tree, context, newDependency);
            logging_1.logSuccess(`package.json erfolgreich aktualisiert.`);
            return tree;
        });
    };
}
exports.updatePackageJson = updatePackageJson;
function updateLuxStylesScss(options) {
    return files_1.moveFilesToDirectory(options, 'files/theming', 'src/theming');
}
exports.updateLuxStylesScss = updateLuxStylesScss;
/**
 * Aktualisiert die Property "luxMargins" zu "luxMargin" in dem Projekt.
 */
function updateLuxAppFooterButtonInfoConstructorParams(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`Passe die Konstruktor-Aufrufe für LuxAppFooterButtonInfo's an.`);
        return util_1.waitForTreeCallback(tree, () => {
            const fullRegExp = /new LuxAppFooterButtonInfo\(((.|\n)*?)\)(;|,|(\r\n|\r|\n|\s))/gm;
            let fileCount = 0;
            files_1.iterateFilesAndModifyContent(tree, options.path + '/src/app', (filePath, content) => {
                let modifiedContent = content;
                // Zeilenumbrüche aus den LuxAppFooterButtonInfo entfernen
                let matchesWithLineBreaks = modifiedContent.match(fullRegExp);
                if (matchesWithLineBreaks) {
                    matchesWithLineBreaks.forEach((buttonInfo) => {
                        // Nur durchführen, wenn das Label keine runde Klammer ")" enthält.
                        if (buttonInfo.split(',').length > 1) {
                            let newTest = buttonInfo.replace(/(\n| )/g, '');
                            newTest = newTest.replace('newLuxAppFooterButtonInfo', 'new LuxAppFooterButtonInfo');
                            newTest = newTest.replace(/,/g, ', ');
                            modifiedContent = modifiedContent.replace(buttonInfo, newTest);
                        }
                    });
                }
                // Alle Vorkommnisse des Konstruktor-Aufrufs finden
                let matches = modifiedContent.match(fullRegExp);
                if (matches) {
                    matches.forEach((oldConstructorCall) => {
                        let parametersString = oldConstructorCall.match(new RegExp(/\(((.|\n)*?)\)(;|,|(\r\n|\r|\n|\s))/, 'gm'))[0];
                        parametersString = parametersString.replace('(', '').replace(/\)(;|,|(\r\n|\r|\n|\s))/gm, '');
                        // Die einzelnen Parameter aus dem Konstruktor erhalten
                        const parameters = parametersString.split(',');
                        // Nur wenn überhaupt Parameter gesetzt sind und wenn sie noch nicht geändert wurden.
                        // Das stellen wir darüber fest, das der zweite Parameter früher für disabled (boolean) stand und
                        // ein Pflichtfeld war. Es muss also vor der Umwandlung an der 3ten Stelle im Array stehen.
                        if (parameters.length > 3 && (parameters[2].trim() === 'false' || parameters[2].trim() === 'true')) {
                            //let newConstructorCall: string = 'new LuxAppFooterButtonInfo(';
                            let newConstructorCall = 'new LuxAppFooterButtonInfo(';
                            // cmd-Parameter an 2te Stelle verschieben ([label, cmd, color, disabled])
                            newConstructorCall += `${parameters[0]}, ${parameters[3]}, ${parameters[1]}, ${parameters[2]}, `;
                            // Die übrigen Parameter anhängen
                            parameters.forEach((parameter, index) => {
                                if (index > 3) {
                                    newConstructorCall += parameter.trim() + ', ';
                                }
                            });
                            newConstructorCall += ')';
                            // Mehrere spaces hintereinander entfernen
                            newConstructorCall = newConstructorCall.replace(', )', ')').replace(/  +/g, ' ');
                            if (oldConstructorCall.endsWith(',')) {
                                newConstructorCall += ',';
                            }
                            else if (oldConstructorCall.endsWith(';')) {
                                newConstructorCall += ';';
                            }
                            console.log(newConstructorCall, oldConstructorCall);
                            modifiedContent = util_1.replaceAll(modifiedContent, oldConstructorCall, newConstructorCall);
                        }
                    });
                    // Den angepassten Content einsetzen
                    if (modifiedContent !== content) {
                        tree.overwrite(filePath, modifiedContent);
                        fileCount++;
                    }
                }
            }, '.ts');
            logging_1.logInfo(`${fileCount} Typescript-Dateien angepasst.`);
            logging_1.logSuccess(`Konstruktoraufrufe erfolgreich angepasst.`);
            return tree;
        });
    };
}
exports.updateLuxAppFooterButtonInfoConstructorParams = updateLuxAppFooterButtonInfoConstructorParams;
/**
 * Gibt die offen stehenden ToDos (Aufgaben, die der Generator nicht übernehmen konnte) für den User aus.
 */
function todosForUser() {
    return (tree, context) => {
        util_1.runInstallAndLogToDos(context, `Die ${chalk_1.default.blueBright('LuxSliderComponent')} zeigt jetzt standardmäßig immer das ThumbLabel an.\r\n${logging_1.TAB}Dies ist bei Bedarf über die Property ${chalk_1.default.redBright('luxThumbLabelAlways')} abschaltbar.`, `Die Funktionen ${chalk_1.default.redBright('sendButtonCommand')} und ${chalk_1.default.redBright('getButtonObservable')} vom ${chalk_1.default.blueBright('LuxAppFooterButtonService')} sind nun @deprecated.\r\n` +
            `${logging_1.TAB}Stattdessen bitte die neuen ${chalk_1.default.redBright('onClick')}-Callbackfunktionen bei Erstellung von ${chalk_1.default.blueBright('LuxAppFooterButtonInfo')}-Objekten nutzen.`, `Die ${chalk_1.default.blueBright('LuxStepperComponent')} wurde intern überarbeitet, bitte prüfen ob alles noch wie gewünscht funktioniert.`, `Bitte starten Sie ${chalk_1.default.redBright('npm run smoketest')} um möglichen Fehlern vorzugreifen.`, `Weitere Informationen: https://confluence.gfi.ihk.de/display/EVA/Update+Guide#UpdateGuide-UmstellungaufVersion1.7.10`);
        return tree;
    };
}
exports.todosForUser = todosForUser;
//# sourceMappingURL=index.js.map