"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const project_1 = require("@schematics/angular/utility/project");
const validation_1 = require("../../utility/validation");
const dependencies_1 = require("../../utility/dependencies");
const logging_1 = require("../../utility/logging");
const chalk_1 = require("chalk");
const util_1 = require("../../utility/util");
const files_1 = require("../../utility/files");
/**
 * Haupt-Rule für diesen Schematic-Generator.
 * @param options
 */
exports.luxVersion = (options) => {
    return schematics_1.chain([
        setupProject(options),
        checkVersions(),
        updatePackageJson(),
        updateModulesForCommonModule(options),
        updateModulesForErrorModule(options),
        todosForUser()
    ]);
};
/**
 * Prüft, ob die Property "project" gesetzt ist und
 * erstellt wenn nötig einen Standard-Pfad zum Projekt, wenn keiner bekannt ist.
 * @param options
 */
function setupProject(options) {
    return (tree, context) => {
        logging_1.logNewUpdate('1.7.14');
        logging_1.logInfoWithDescriptor('Starte Konfiguration der Schematic.');
        return util_1.waitForTreeCallback(tree, () => {
            if (!options.project) {
                throw logging_1.formattedSchematicsException('Option "project" wird benötigt.');
            }
            const project = project_1.getProject(tree, options.project);
            if (options.path === undefined) {
                options.path = project.root;
            }
            util_1.checkSmoketestScriptExists(tree, context);
            logging_1.logSuccess(`Schematic-Konfiguration für Projekt "${options.project}" erfolgreich.`);
            return tree;
        });
    };
}
exports.setupProject = setupProject;
/**
 * Prüft ob die Versionen des Projekts mit den erforderlichen Versionen dieses Updates übereinstimmen.
 */
function checkVersions() {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Starte die Versionsprüfung.');
        return util_1.waitForTreeCallback(tree, () => {
            const minimumLuxComponentsVersion = '1.7.13';
            validation_1.validateLuxComponentsVersion(tree, context, minimumLuxComponentsVersion);
            const minimumNodeVersion = '8.0.0';
            validation_1.validateNodeVersion(context, minimumNodeVersion);
            logging_1.logSuccess(`Versionen erfolgreich geprüft.`);
            return tree;
        });
    };
}
exports.checkVersions = checkVersions;
/**
 * Aktualisiert die package.json des Projekts.
 */
function updatePackageJson() {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Aktualisiere LUX-Components Version auf 1.7.14.');
        return util_1.waitForTreeCallback(tree, () => {
            const newDependency = {
                type: dependencies_1.NodeDependencyType.Default,
                version: '1.7.14',
                name: 'lux-components'
            };
            dependencies_1.updatePackageJsonDependency(tree, context, newDependency);
            logging_1.logSuccess(`package.json erfolgreich aktualisiert.`);
            return tree;
        });
    };
}
exports.updatePackageJson = updatePackageJson;
/**
 * Sucht nach Components die zuvor im LuxLayoutModule waren, nun aber in LuxCommonModule verschoben worden sind.
 * Aktualisiert das passende Modul entsprechend.
 * @param options
 */
function updateModulesForCommonModule(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Aktualisiere die Components aus LuxCommonModule.');
        return util_1.waitForTreeCallback(tree, () => {
            const luxCommonComponentTags = [
                'lux-badge',
                'lux-label',
                'lux-message-box',
                'lux-message',
                'lux-progress',
                'lux-spinner',
                'lux-table',
                'lux-table-column',
                'lux-table-column-content',
                'lux-table-column-footer',
                'lux-table-column-header',
            ];
            const luxCommonComponentNames = [
                'LuxBadgeComponent',
                'LuxLabelComponent',
                'LuxMessageBoxComponent',
                'LuxMessageComponent',
                'LuxProgressComponent',
                'LuxSpinnerComponent',
                'LuxTableComponent',
                'LuxTableColumnComponent',
                'LuxTableColumnContentComponent',
                'LuxTableColumnFooterComponent',
                'LuxTableColumnHeaderComponent',
            ];
            files_1.searchInComponentAndModifyModule(tree, options.path + '/src/app', [...luxCommonComponentTags, ...luxCommonComponentNames], (filePath, content) => {
                if (content.indexOf('LuxCommonModule') === -1) {
                    // Den Import anpassen import { LuxLookupModule } from 'lux-components';
                    content = 'import { LuxCommonModule } from \'lux-components\';\n' + content;
                    // Das imports-Array anpassen
                    const matches = content.match(/imports:(.*)\[((.|\n)*?)\]/gm);
                    if (matches && matches.length > 0) {
                        let importString = matches[0];
                        importString = importString.trim().replace(/\s\s+/g, '');
                        let importEntries = importString.substring(importString.indexOf('[') + 1, importString.length - 1);
                        if (!importEntries.trim().endsWith(',')) {
                            importEntries = importEntries.trim() + ',';
                        }
                        importEntries += 'LuxCommonModule';
                        importString = 'imports: [\n\t\t' + importEntries + '\n\t]';
                        importString = importString.replace(/,/gm, ',\n\t\t');
                        content = content.replace(matches[0], importString);
                        tree.overwrite(filePath, content);
                    }
                }
            }, '.ts', '.html');
            logging_1.logSuccess(`Module erfolgreich angepasst.`);
            return tree;
        });
    };
}
exports.updateModulesForCommonModule = updateModulesForCommonModule;
/**
 * Sucht nach Components die zuvor im LuxLayoutModule waren, nun aber in LuxErrorModule verschoben worden sind.
 * Aktualisiert das passende Modul entsprechend.
 * @param options
 */
function updateModulesForErrorModule(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Aktualisiere die Components aus LuxErrorModule.');
        return util_1.waitForTreeCallback(tree, () => {
            const luxErrorPageNames = [
                'LuxErrorPageComponent',
                'LuxErrorService',
                'LuxErrorStoreService',
                'ILuxError',
                'ILuxErrorPageConfig'
            ];
            files_1.searchInComponentAndModifyModule(tree, options.path + '/src/app', luxErrorPageNames, (filePath, content) => {
                if (content.indexOf('LuxErrorModule') === -1) {
                    // Den Import anpassen import { LuxLookupModule } from 'lux-components';
                    content = 'import { LuxErrorModule } from \'lux-components\';\n' + content;
                    // Das imports-Array anpassen
                    const matches = content.match(/imports:(.*)\[((.|\n)*?)\]/gm);
                    if (matches && matches.length > 0) {
                        let importString = matches[0];
                        importString = importString.trim().replace(/\s\s+/g, '');
                        let importEntries = importString.substring(importString.indexOf('[') + 1, importString.length - 1);
                        if (!importEntries.trim().endsWith(',')) {
                            importEntries = importEntries.trim() + ',';
                        }
                        importEntries += 'LuxErrorModule';
                        importString = 'imports: [\n\t\t' + importEntries + '\n\t]';
                        importString = importString.replace(/,/gm, ',\n\t\t');
                        content = content.replace(matches[0], importString);
                        tree.overwrite(filePath, content);
                    }
                }
            }, '.ts');
            logging_1.logSuccess(`Module erfolgreich angepasst.`);
            return tree;
        });
    };
}
exports.updateModulesForErrorModule = updateModulesForErrorModule;
/**
 * Gibt die offen stehenden ToDos (Aufgaben, die der Generator nicht übernehmen konnte) für den User aus.
 */
function todosForUser() {
    return (tree, context) => {
        util_1.runInstallAndLogToDos(context, `Bitte starten Sie ${chalk_1.default.redBright('npm run smoketest')} um möglichen Fehlern vorzugreifen.`, `Weitere Informationen: https://confluence.gfi.ihk.de/display/AF/Update+Guide#UpdateGuide-UmstellungaufVersion1.7.14`);
        return tree;
    };
}
exports.todosForUser = todosForUser;
//# sourceMappingURL=index.js.map