"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const project_1 = require("@schematics/angular/utility/project");
const chalk_1 = require("chalk");
const dependencies_1 = require("../../utility/dependencies");
const files_1 = require("../../utility/files");
const html_1 = require("../../utility/html");
const validation_1 = require("../../utility/validation");
const logging_1 = require("../../utility/logging");
const util_1 = require("../../utility/util");
const htmlparser2 = require('htmlparser2');
const cheerio = require('cheerio');
/**
 * Haupt-Rule für diesen Schematic-Generator.
 * @param options
 */
exports.luxVersion = (options) => {
    return schematics_1.chain([
        setupProject(options),
        checkVersions(),
        updateLuxList(options),
        updateLuxTab(options),
        updateLuxMenu(options),
        updateInterfaceNames(options),
        updateHammerConfig(options),
        updateLuxStylesScss(options),
        updateLuxAppMenuLeft(options),
        updatePackageJson(),
        todosForUser()
    ]);
};
/**
 * Diese Methode entfernt das alte Appheadermenü und erstetzt dieses durch das neue Appheadermenü.
 */
function updateLuxAppMenuLeft(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`` + 'Ersetze das alte AppHeadermenü durch das neue Appheadermenü.');
        files_1.iterateFilesAndModifyContent(tree, options.path, (filePath, content) => {
            const dom = htmlparser2.parseDOM(content, {
                withDomLvl1: true,
                normalizeWhitespace: false,
                xmlMode: true,
                decodeEntities: false
            });
            // Dekodierung deaktivieren, ansonsten werden Umlaute, &&-Operatoren, etc. von Cheerio verstümmelt
            const $ = cheerio.load(dom, { decodeEntities: false });
            const menuItemsOld = $('lux-app-header-left-nav').children('lux-menu-item');
            let newMenu = '';
            if (menuItemsOld.length > 0) {
                newMenu = '\n<lux-side-nav>\n';
                menuItemsOld.each(function (i, elem) {
                    newMenu += '<lux-side-nav-item ';
                    const luxLabel = $(elem).attr('luxLabel');
                    if (luxLabel) {
                        newMenu += 'luxLabel="' + luxLabel + '" ';
                    }
                    const luxIconName = $(elem).attr('luxIconName');
                    if (luxIconName) {
                        newMenu += 'luxIconName="' + luxIconName + '" ';
                    }
                    const luxClicked = $(elem).attr('(luxClicked)');
                    if (luxClicked) {
                        newMenu += '(luxClicked)="' + luxClicked + '" ';
                    }
                    const luxTagId = $(elem).attr('luxTagId');
                    if (luxTagId) {
                        newMenu += 'luxTagId="' + luxTagId + '" ';
                    }
                    newMenu += '></lux-side-nav-item>\n';
                });
                newMenu += '</lux-side-nav>\n';
                // Leider kann man das Menü nicht mit Cheerio hinzufügen da Cheerio alle
                // Attribute in Lowercase (z.B. luxLabel => luxlabel) umwandelt.
                // Deshalb wird hier nur ein Platzhalter an der richtigen Stelle hinterlassen.
                // Der Platzhalter wird weiter unten über einen Regulären Ausdruck ersetzt.
                $('lux-app-header').prepend('\nmenuPlaceholder45853489459');
            }
            $('lux-app-header-left-nav').remove();
            let modifiedContent = $.xml();
            if (menuItemsOld.length > 0) {
                // Hier wird der Platzhalter von oben durch das konkrete Menü ersetzt.
                modifiedContent = modifiedContent.replace('menuPlaceholder45853489459', newMenu);
                tree.overwrite(filePath, modifiedContent);
            }
        }, 'app.component.html');
        return tree;
    };
}
exports.updateLuxAppMenuLeft = updateLuxAppMenuLeft;
/**
 * Diese Methode entfernt das obsolete Attribut "luxListItems".
 */
function updateLuxList(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`` + 'Entferne das obsolete Attribut "luxListItems"');
        files_1.iterateFilesAndModifyContent(tree, options.path, (filePath, content) => {
            const info = html_1.removeAttribute(content, 'lux-list', 'luxItems');
            if (info.updated) {
                tree.overwrite(filePath, info.content);
            }
        }, '.html');
        return tree;
    };
}
exports.updateLuxList = updateLuxList;
/**
 * Diese Methode setzt die I-Präfixe für die Klassen LuxMessage, LuxMessageCloseEvent und LuxMessageChangeEvent.
 */
function updateInterfaceNames(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`` + 'Setze die I-Präfixe für die Klassen "LuxMessage", "LuxMessageCloseEvent" und "LuxMessageChangeEvent".');
        files_1.iterateFilesAndModifyContent(tree, options.path, (filePath, content) => {
            let modifiedContent = content.replace(/(\W)(LuxMessage)(\W)/g, '$1I$2$3');
            modifiedContent = modifiedContent.replace(/(\W)(LuxMessageCloseEvent)(\W)/g, '$1I$2$3');
            modifiedContent = modifiedContent.replace(/(\W)(LuxMessageChangeEvent)(\W)/g, '$1I$2$3');
            if (content !== modifiedContent) {
                tree.overwrite(filePath, modifiedContent);
            }
        }, '.ts');
        return tree;
    };
}
exports.updateInterfaceNames = updateInterfaceNames;
/**
 * Diese Methode benennt die Klasse LuxHammerConfig in LuxComponentsHammerConfig um.
 */
function updateHammerConfig(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`` + 'Benenne die Klasse "LuxHammerConfig" in "LuxComponentsHammerConfig" um.');
        files_1.iterateFilesAndModifyContent(tree, options.path, (filePath, content) => {
            const modifiedContent = content.replace(/(\W)(LuxHammerConfig)(\W)/g, '$1LuxComponentsHammerConfig$3');
            if (content !== modifiedContent) {
                tree.overwrite(filePath, modifiedContent);
            }
        }, '.ts');
        return tree;
    };
}
exports.updateHammerConfig = updateHammerConfig;
/**
 * Diese Methode benennt das Attribut "luxText" in allen Tabs zu "luxTitle" um.
 */
function updateLuxTab(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`` + 'LUX-TAB: Die Property "luxText" wird zu "luxTitle" umbenannt."');
        files_1.iterateFilesAndModifyContent(tree, options.path, (filePath, content) => {
            const info = html_1.renameAttribute(content, 'lux-tab', 'luxText', 'luxTitle');
            if (info.updated) {
                tree.overwrite(filePath, info.content);
            }
        }, '.html');
        return tree;
    };
}
exports.updateLuxTab = updateLuxTab;
/**
 * Diese Methode benennt das Attribut "luxIconName" in allen Menüs zu "luxMenuIconName" um.
 */
function updateLuxMenu(options) {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor(`` + 'LUX-MENU: Die Property "luxIconName" wird zu "luxMenuIconName" umbenannt."');
        files_1.iterateFilesAndModifyContent(tree, options.path, (filePath, content) => {
            const info = html_1.renameAttribute(content, 'lux-menu', 'luxIconName', 'luxMenuIconName');
            if (info.updated) {
                tree.overwrite(filePath, info.content);
            }
        }, '.html');
        return tree;
    };
}
exports.updateLuxMenu = updateLuxMenu;
function updateLuxStylesScss(options) {
    return files_1.moveFilesToDirectory(options, 'files/theming/', 'src/theming/');
}
exports.updateLuxStylesScss = updateLuxStylesScss;
/**
 * Aktualisiert die package.json des Projekts.
 * Fügt die neue Dependency hinzu und entfernt die alte.
 */
function updatePackageJson() {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Updating lux-components to v.1.7.8');
        const luxComponentsDependency = {
            type: dependencies_1.NodeDependencyType.Default,
            version: '1.7.8',
            name: 'lux-components'
        };
        dependencies_1.updatePackageJsonDependency(tree, context, luxComponentsDependency);
        logging_1.logSuccess(`package.json successfully updated.`);
        return tree;
    };
}
exports.updatePackageJson = updatePackageJson;
/**
 * Prüft, ob die Property "project" gesetzt ist und
 * erstellt wenn nötig einen Standard-Pfad zum Projekt, wenn keiner bekannt ist.
 * @param options
 */
function setupProject(options) {
    return (tree, context) => {
        logging_1.logNewUpdate('1.7.8');
        logging_1.logInfoWithDescriptor('Starting setup');
        if (!options.project) {
            throw logging_1.formattedSchematicsException('Option "project" wird benötigt.');
        }
        const project = project_1.getProject(tree, options.project);
        if (options.path === undefined) {
            options.path = project.root;
        }
        util_1.checkSmoketestScriptExists(tree, context);
        logging_1.logSuccess(`Schematic-Konfiguration für Projekt "${options.project}" erfolgreich.`);
        return tree;
    };
}
exports.setupProject = setupProject;
/**
 * Prüft ob die Versionen des Projekts mit den erforderlichen Versionen dieses Updates übereinstimmen.
 */
function checkVersions() {
    return (tree, context) => {
        logging_1.logInfoWithDescriptor('Starting version check');
        const minimumLuxComponentsVersion = '1.7.7';
        validation_1.validateLuxComponentsVersion(tree, context, minimumLuxComponentsVersion);
        const minimumNodeVersion = '8.0.0';
        validation_1.validateNodeVersion(context, minimumNodeVersion);
        logging_1.logSuccess(`Checked the versions successfully.`);
        return tree;
    };
}
exports.checkVersions = checkVersions;
/**
 * Gibt die offen stehenden ToDos (Aufgaben, die der Generator nicht übernehmen konnte) für den User aus.
 */
function todosForUser() {
    return (tree, context) => {
        util_1.runInstallAndLogToDos(context, `Die Properties ${chalk_1.default.redBright('luxNoServerFilter')}, ${chalk_1.default.redBright('luxNoServerPagination')} und ${chalk_1.default.redBright('luxNoServerSort')} aus dem Interface ${chalk_1.default.blueBright('ILuxTableHttpDao')} wurden ersatzlos gestrichen.`, `Prüfen Sie, ob die LuxTabs noch einen Abstand haben.`, `Bitte starten Sie ${chalk_1.default.redBright('npm run smoketest')} um möglichen Fehlern vorzugreifen.`, `Weitere Informationen: https://confluence.gfi.ihk.de/display/EVA/Update+Guide#UpdateGuide-UmstellungaufVersion1.7.8`);
        return tree;
    };
}
exports.todosForUser = todosForUser;
//# sourceMappingURL=index.js.map