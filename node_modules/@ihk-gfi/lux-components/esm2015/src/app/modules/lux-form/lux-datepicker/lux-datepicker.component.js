import * as tslib_1 from "tslib";
import { Platform } from '@angular/cdk/platform';
import { ChangeDetectorRef, Component, DoCheck, ElementRef, Input, OnChanges, OnDestroy, OnInit, Optional, SimpleChanges, ViewChild } from '@angular/core';
import { ControlContainer } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS, MatDatepicker } from '@angular/material';
import { MAT_DATE_LOCALE } from '@angular/material/core';
import { LuxComponentsConfigService } from '../../lux-components-config/lux-components-config.service';
import { LuxConsoleService } from '../../lux-util/lux-console.service';
import { LuxMediaQueryObserverService } from '../../lux-util/lux-media-query-observer.service';
import { LuxUtil } from '../../lux-util/lux-util';
import { LuxFormInputBaseClass } from '../lux-form-model/lux-form-input-base.class';
import { LuxDatepickerAdapter } from './lux-datepicker-adapter';
export const APP_DATE_FORMATS = {
    parse: {
        dateInput: { month: '2-digit', year: 'numeric', day: '2-digit' }
    },
    display: {
        dateInput: { month: '2-digit', year: 'numeric', day: '2-digit' },
        monthYearLabel: { year: 'numeric', month: 'long' },
        dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },
        monthYearA11yLabel: { year: 'numeric', month: 'long' }
    }
};
let LuxDatepickerComponent = class LuxDatepickerComponent extends LuxFormInputBaseClass {
    constructor(controlContainer, dateAdapter, mediaObserver, elementRef, cdr, logger, config) {
        super(controlContainer, cdr, logger, config);
        this.dateAdapter = dateAdapter;
        this.mediaObserver = mediaObserver;
        this.elementRef = elementRef;
        this.luxStartView = 'month';
        this.luxTouchUi = false;
        this.luxOpened = false;
        this.luxStartDate = null;
        this.luxShowToggle = true;
        this.luxLocale = 'de-DE';
        this.luxCustomFilter = undefined;
        this.luxMaxDate = undefined;
        this.luxMinDate = undefined;
        // den Standard-Wert für Autocomplete für Datepicker ausschalten
        this.luxAutocomplete = 'off';
        this.dateAdapter.setLocale(this.luxLocale);
    }
    get luxValue() {
        return this.getValue();
    }
    set luxValue(value) {
        this.setValue(value);
    }
    ngOnChanges(simpleChanges) {
        super.ngOnChanges(simpleChanges);
        if (simpleChanges.luxOpened) {
            // Evtl. gibt es ohne das Timeout sonst Fehler, weil der matDatepicker noch nicht gesetzt ist
            setTimeout(() => {
                this.triggerOpenClose();
            });
        }
        if (simpleChanges.luxLocale && simpleChanges.luxLocale.currentValue) {
            this.dateAdapter.setLocale(simpleChanges.luxLocale.currentValue);
        }
        if (simpleChanges.luxMaxDate && typeof simpleChanges.luxMaxDate.currentValue === 'string') {
            this.max = this.dateAdapter.parse(simpleChanges.luxMaxDate.currentValue, {});
        }
        if (simpleChanges.luxMinDate && typeof simpleChanges.luxMinDate.currentValue === 'string') {
            this.min = this.dateAdapter.parse(simpleChanges.luxMinDate.currentValue, {});
        }
        if (simpleChanges.luxStartDate && typeof simpleChanges.luxStartDate.currentValue === 'string') {
            this.start = this.dateAdapter.parse(simpleChanges.luxStartDate.currentValue, {});
        }
    }
    ngOnInit() {
        super.ngOnInit();
        this.originalTouchUi = this.luxTouchUi;
        this.mediaSubscription = this.mediaObserver.getMediaQueryChangedAsObservable().subscribe(() => {
            this.checkMediaObserver();
        });
    }
    ngOnDestroy() {
        this.mediaSubscription.unsubscribe();
    }
    /**
     * Erzeugt für die Unter- bzw. Überschreitung
     * @param value
     * @param errors
     */
    errorMessageModifier(value, errors) {
        if (errors.matDatepickerMin) {
            return 'Das Datum unterschreitet den Minimalwert';
        }
        else if (errors.matDatepickerMax) {
            return 'Das Datum überschreitet den Maximalwert';
        }
        else if (errors.required) {
            if (this.datepickerInput && this.datepickerInput.nativeElement.value) {
                return 'Das Datum ist ungültig';
            }
            else {
                return 'Das Datum darf nicht leer sein';
            }
        }
        return undefined;
    }
    /**
     * Checkt ob eine mobile Media-Query vorliegt.
     * Wenn ja, wird automagisch die TouchUI aktiviert.
     * Wenn nein, wird der vom Aufrufer/originale luxTouchUI-Wert genutzt.
     */
    checkMediaObserver() {
        if (this.mediaObserver.isXS() || this.mediaObserver.isSM()) {
            this.luxTouchUi = true;
        }
        else {
            this.luxTouchUi = this.originalTouchUi;
        }
    }
    /**
     * Führt .open() bzw. .close() vom MatDatepicker aus, abhängig vom Wert für luxOpened.
     */
    triggerOpenClose() {
        if (this.luxOpened) {
            this.matDatepicker.open();
        }
        else {
            this.matDatepicker.close();
        }
    }
    /**
     * Aktualisiert den FormControl-Value und den Wert im Parent über valueChange mithilfe des übergebenen ISO-Strings.
     * @param isoValue
     */
    setISOValue(isoValue) {
        setTimeout(() => {
            this.previousISO = isoValue;
            // valueChange-Emitter anstoßen
            this.notifyFormValueChanged(isoValue);
            // "silently" den FormControl auf den (potentiell) geänderten Wert aktualisieren
            this.formControl.setValue(isoValue, {
                emitEvent: false,
                emitModelToViewChange: false,
                emitViewToModelChange: false
            });
            // Per Hand dem Input-Element einen formatierten String übergeben
            if (!this.datepickerInput.nativeElement.value && isoValue) {
                this.datepickerInput.nativeElement.value = this.dateAdapter.format(isoValue, APP_DATE_FORMATS.display.dateInput);
            }
        });
    }
    // region overridden methods
    setValue(value) {
        if (value !== this.luxValue) {
            if (!this.formControl) {
                this._initialValue = value;
                return;
            }
            this.formControl.setValue(value);
        }
    }
    initFormValueSubscription() {
        // Aktualisierungen an dem FormControl-Value sollen auch via EventEmitter bekannt gemacht werden
        this._formValueChangeSubscr = this.formControl.valueChanges.subscribe((value) => {
            this.updateDateValue(value);
        });
        if (this.formControl.value) {
            // Es kann vorkommen, dass der initiale Wert nicht im ISO-Format angegeben ist.
            // Dann muss der Wert noch umgewandelt werden.
            this.updateDateValue(this.formControl.value);
        }
        else if (this._initialValue !== null && this._initialValue !== undefined) {
            // Vorhandenen Initialwert setzen
            this.formControl.setValue(this._initialValue);
        }
    }
    updateDateValue(value) {
        if (!value) {
            this.setISOValue(value);
            return;
        }
        // Nachfolgend erstellen
        if (typeof value === 'string') {
            value = this.dateAdapter.parse(value, {});
        }
        const eventDate = value;
        const tempDate = new Date(0);
        tempDate.setUTCFullYear(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());
        tempDate.setUTCHours(0, 0, 0, 0);
        // Sicherheitshalber noch einmal prüfen, kann vorkommen das ein unsinniger Wert eingetragen wird
        // z.B. 'asdf', das führt zu InvalidDate's
        if (LuxUtil.isDate(tempDate) && this.previousISO !== tempDate.toISOString()) {
            this.setISOValue(tempDate.toISOString());
        }
    }
};
LuxDatepickerComponent.ctorParameters = () => [
    { type: ControlContainer, decorators: [{ type: Optional }] },
    { type: DateAdapter },
    { type: LuxMediaQueryObserverService },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: LuxConsoleService },
    { type: LuxComponentsConfigService }
];
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxDatepickerComponent.prototype, "luxStartView", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], LuxDatepickerComponent.prototype, "luxTouchUi", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], LuxDatepickerComponent.prototype, "luxOpened", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxDatepickerComponent.prototype, "luxStartDate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], LuxDatepickerComponent.prototype, "luxShowToggle", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxDatepickerComponent.prototype, "luxLocale", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], LuxDatepickerComponent.prototype, "luxCustomFilter", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxDatepickerComponent.prototype, "luxMaxDate", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxDatepickerComponent.prototype, "luxMinDate", void 0);
tslib_1.__decorate([
    ViewChild(MatDatepicker, { static: false }),
    tslib_1.__metadata("design:type", MatDatepicker)
], LuxDatepickerComponent.prototype, "matDatepicker", void 0);
tslib_1.__decorate([
    ViewChild('datepickerInput', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], LuxDatepickerComponent.prototype, "datepickerInput", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], LuxDatepickerComponent.prototype, "luxValue", null);
LuxDatepickerComponent = tslib_1.__decorate([
    Component({
        selector: 'lux-datepicker',
        template: "<lux-form-control [luxFormComponent]=\"this\" [formGroup]=\"formGroup\" #datepickerFormControl *ngIf=\"formGroup\">\n  <div class=\"lux-input-row\" fxLayout=\"row\">\n    <input\n      fxFlex=\"auto\"\n      matInput\n      luxTagIdHandler\n      [luxTagId]=\"luxTagId\"\n      [matDatepicker]=\"datepicker\"\n      [min]=\"min\"\n      [max]=\"max\"\n      [matDatepickerFilter]=\"luxCustomFilter\"\n      [placeholder]=\"luxPlaceholder\"\n      [required]=\"luxRequired\"\n      [readonly]=\"luxReadonly\"\n      [formControl]=\"formControl\"\n      [autocomplete]=\"luxAutocomplete\"\n      (blur)=\"luxBlur.emit($event)\"\n      (focus)=\"luxFocus.emit($event)\"\n      (focusin)=\"luxFocusIn.emit($event)\"\n      (focusout)=\"luxFocusOut.emit($event)\"\n      [id]=\"uid\"\n      [luxAriaDescribedby]=\"uid + '-error ' + uid + '-hint'\"\n      #datepickerInput\n    />\n    <mat-datepicker-toggle\n      [disabled]=\"luxDisabled || luxReadonly\"\n      [for]=\"datepicker\"\n      *ngIf=\"luxShowToggle\"\n      fxFlex=\"auto\"\n      matSuffix\n    ></mat-datepicker-toggle>\n    <mat-datepicker\n      [startView]=\"luxStartView\"\n      [startAt]=\"start\"\n      [touchUi]=\"luxTouchUi\"\n      [disabled]=\"luxDisabled || luxReadonly\"\n      [panelClass]=\"'lux-datepicker-panel'\"\n      #datepicker\n    >\n    </mat-datepicker>\n  </div>\n</lux-form-control>\n",
        providers: [
            { provide: DateAdapter, useClass: LuxDatepickerAdapter, deps: [MAT_DATE_LOCALE, Platform] },
            { provide: MAT_DATE_FORMATS, useValue: APP_DATE_FORMATS }
        ]
    }),
    tslib_1.__param(0, Optional()),
    tslib_1.__metadata("design:paramtypes", [ControlContainer,
        DateAdapter,
        LuxMediaQueryObserverService,
        ElementRef,
        ChangeDetectorRef,
        LuxConsoleService,
        LuxComponentsConfigService])
], LuxDatepickerComponent);
export { LuxDatepickerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LWRhdGVwaWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGloay1nZmkvbHV4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJzcmMvYXBwL21vZHVsZXMvbHV4LWZvcm0vbHV4LWRhdGVwaWNrZXIvbHV4LWRhdGVwaWNrZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDakQsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsT0FBTyxFQUNQLFVBQVUsRUFDVixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxNQUFNLEVBQ04sUUFBUSxFQUNSLGFBQWEsRUFDYixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFekQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sMkRBQTJELENBQUM7QUFDdkcsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDdkUsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0saURBQWlELENBQUM7QUFDL0YsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2xELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQ3BGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRWhFLE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFHO0lBQzlCLEtBQUssRUFBRTtRQUNMLFNBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFB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RUFBRSxDQUFDO3NDQUFnQixhQUFhOzZEQUFNO0FBQ1o7SUFBbEUsU0FBUyxDQUFDLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLENBQUM7c0NBQWtCLFVBQVU7K0RBQUM7QUFNdEY7SUFBUixLQUFLLEVBQUU7OztzREFFUDtBQTVCVSxzQkFBc0I7SUFSbEMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLGdCQUFnQjtRQUMxQiwyMkNBQThDO1FBQzlDLFNBQVMsRUFBRTtZQUNULEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsSUFBSSxFQUFFLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxFQUFFO1lBQzNGLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRTtTQUMxRDtLQUNGLENBQUM7SUFnQ0csbUJBQUEsUUFBUSxFQUFFLENBQUE7NkNBQW1CLGdCQUFnQjtRQUN6QixXQUFXO1FBQ1QsNEJBQTRCO1FBQy9CLFVBQVU7UUFDekIsaUJBQWlCO1FBQ2QsaUJBQWlCO1FBQ2pCLDBCQUEwQjtHQXJDekIsc0JBQXNCLENBNE1sQztTQTVNWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBEb0NoZWNrLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xDb250YWluZXIgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEYXRlQWRhcHRlciwgTUFUX0RBVEVfRk9STUFUUywgTWF0RGF0ZXBpY2tlciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IE1BVF9EQVRFX0xPQ0FMRSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMdXhDb21wb25lbnRzQ29uZmlnU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC1jb21wb25lbnRzLWNvbmZpZy9sdXgtY29tcG9uZW50cy1jb25maWcuc2VydmljZSc7XG5pbXBvcnQgeyBMdXhDb25zb2xlU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC11dGlsL2x1eC1jb25zb2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgTHV4TWVkaWFRdWVyeU9ic2VydmVyU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC11dGlsL2x1eC1tZWRpYS1xdWVyeS1vYnNlcnZlci5zZXJ2aWNlJztcbmltcG9ydCB7IEx1eFV0aWwgfSBmcm9tICcuLi8uLi9sdXgtdXRpbC9sdXgtdXRpbCc7XG5pbXBvcnQgeyBMdXhGb3JtSW5wdXRCYXNlQ2xhc3MgfSBmcm9tICcuLi9sdXgtZm9ybS1tb2RlbC9sdXgtZm9ybS1pbnB1dC1iYXNlLmNsYXNzJztcbmltcG9ydCB7IEx1eERhdGVwaWNrZXJBZGFwdGVyIH0gZnJvbSAnLi9sdXgtZGF0ZXBpY2tlci1hZGFwdGVyJztcblxuZXhwb3J0IGNvbnN0IEFQUF9EQVRFX0ZPUk1BVFMgPSB7XG4gIHBhcnNlOiB7XG4gICAgZGF0ZUlucHV0OiB7IG1vbnRoOiAnMi1kaWdpdCcsIHllYXI6ICdudW1lcmljJywgZGF5OiAnMi1kaWdpdCcgfVxuICB9LFxuICBkaXNwbGF5OiB7XG4gICAgZGF0ZUlucHV0OiB7IG1vbnRoOiAnMi1kaWdpdCcsIHllYXI6ICdudW1lcmljJywgZGF5OiAnMi1kaWdpdCcgfSxcbiAgICBtb250aFllYXJMYWJlbDogeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfSxcbiAgICBkYXRlQTExeUxhYmVsOiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSxcbiAgICBtb250aFllYXJBMTF5TGFiZWw6IHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH1cbiAgfVxufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbHV4LWRhdGVwaWNrZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vbHV4LWRhdGVwaWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTHV4RGF0ZXBpY2tlckFkYXB0ZXIsIGRlcHM6IFtNQVRfREFURV9MT0NBTEUsIFBsYXRmb3JtXSB9LFxuICAgIHsgcHJvdmlkZTogTUFUX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IEFQUF9EQVRFX0ZPUk1BVFMgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIEx1eERhdGVwaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBMdXhGb3JtSW5wdXRCYXNlQ2xhc3MgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBEb0NoZWNrIHtcbiAgcHJpdmF0ZSBvcmlnaW5hbFRvdWNoVWk7XG4gIHByaXZhdGUgbWVkaWFTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBwcmV2aW91c0lTTzogc3RyaW5nO1xuXG4gIG1pbjogRGF0ZTtcbiAgbWF4OiBEYXRlO1xuICBzdGFydDogRGF0ZTtcblxuICBASW5wdXQoKSBsdXhTdGFydFZpZXc6ICdtb250aCcgfCAneWVhcicgPSAnbW9udGgnO1xuICBASW5wdXQoKSBsdXhUb3VjaFVpOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGx1eE9wZW5lZDogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoKSBsdXhTdGFydERhdGU6IHN0cmluZyA9IG51bGw7XG4gIEBJbnB1dCgpIGx1eFNob3dUb2dnbGU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBsdXhMb2NhbGU6IHN0cmluZyA9ICdkZS1ERSc7XG4gIEBJbnB1dCgpIGx1eEN1c3RvbUZpbHRlcjogYW55ID0gdW5kZWZpbmVkO1xuICBASW5wdXQoKSBsdXhNYXhEYXRlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gIEBJbnB1dCgpIGx1eE1pbkRhdGU6IHN0cmluZyA9IHVuZGVmaW5lZDtcblxuICBAVmlld0NoaWxkKE1hdERhdGVwaWNrZXIsIHsgc3RhdGljOiBmYWxzZSB9KSBtYXREYXRlcGlja2VyOiBNYXREYXRlcGlja2VyPGFueT47XG4gIEBWaWV3Q2hpbGQoJ2RhdGVwaWNrZXJJbnB1dCcsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiBmYWxzZSB9KSBkYXRlcGlja2VySW5wdXQ6IEVsZW1lbnRSZWY7XG5cbiAgZ2V0IGx1eFZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBsdXhWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBjb250cm9sQ29udGFpbmVyOiBDb250cm9sQ29udGFpbmVyLFxuICAgIHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPERhdGU+LFxuICAgIHByaXZhdGUgbWVkaWFPYnNlcnZlcjogTHV4TWVkaWFRdWVyeU9ic2VydmVyU2VydmljZSxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBsb2dnZXI6IEx1eENvbnNvbGVTZXJ2aWNlLFxuICAgIGNvbmZpZzogTHV4Q29tcG9uZW50c0NvbmZpZ1NlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoY29udHJvbENvbnRhaW5lciwgY2RyLCBsb2dnZXIsIGNvbmZpZyk7XG4gICAgLy8gZGVuIFN0YW5kYXJkLVdlcnQgZsO8ciBBdXRvY29tcGxldGUgZsO8ciBEYXRlcGlja2VyIGF1c3NjaGFsdGVuXG4gICAgdGhpcy5sdXhBdXRvY29tcGxldGUgPSAnb2ZmJztcbiAgICB0aGlzLmRhdGVBZGFwdGVyLnNldExvY2FsZSh0aGlzLmx1eExvY2FsZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhzaW1wbGVDaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgc3VwZXIubmdPbkNoYW5nZXMoc2ltcGxlQ2hhbmdlcyk7XG4gICAgaWYgKHNpbXBsZUNoYW5nZXMubHV4T3BlbmVkKSB7XG4gICAgICAvLyBFdnRsLiBnaWJ0IGVzIG9obmUgZGFzIFRpbWVvdXQgc29uc3QgRmVobGVyLCB3ZWlsIGRlciBtYXREYXRlcGlja2VyIG5vY2ggbmljaHQgZ2VzZXR6dCBpc3RcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXJPcGVuQ2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2ltcGxlQ2hhbmdlcy5sdXhMb2NhbGUgJiYgc2ltcGxlQ2hhbmdlcy5sdXhMb2NhbGUuY3VycmVudFZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGVBZGFwdGVyLnNldExvY2FsZShzaW1wbGVDaGFuZ2VzLmx1eExvY2FsZS5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc2ltcGxlQ2hhbmdlcy5sdXhNYXhEYXRlICYmIHR5cGVvZiBzaW1wbGVDaGFuZ2VzLmx1eE1heERhdGUuY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5tYXggPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKHNpbXBsZUNoYW5nZXMubHV4TWF4RGF0ZS5jdXJyZW50VmFsdWUsIHt9KTtcbiAgICB9XG4gICAgaWYgKHNpbXBsZUNoYW5nZXMubHV4TWluRGF0ZSAmJiB0eXBlb2Ygc2ltcGxlQ2hhbmdlcy5sdXhNaW5EYXRlLmN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShzaW1wbGVDaGFuZ2VzLmx1eE1pbkRhdGUuY3VycmVudFZhbHVlLCB7fSk7XG4gICAgfVxuICAgIGlmIChzaW1wbGVDaGFuZ2VzLmx1eFN0YXJ0RGF0ZSAmJiB0eXBlb2Ygc2ltcGxlQ2hhbmdlcy5sdXhTdGFydERhdGUuY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2Uoc2ltcGxlQ2hhbmdlcy5sdXhTdGFydERhdGUuY3VycmVudFZhbHVlLCB7fSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB0aGlzLm9yaWdpbmFsVG91Y2hVaSA9IHRoaXMubHV4VG91Y2hVaTtcbiAgICB0aGlzLm1lZGlhU3Vic2NyaXB0aW9uID0gdGhpcy5tZWRpYU9ic2VydmVyLmdldE1lZGlhUXVlcnlDaGFuZ2VkQXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tNZWRpYU9ic2VydmVyKCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLm1lZGlhU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogRXJ6ZXVndCBmw7xyIGRpZSBVbnRlci0gYnp3LiDDnGJlcnNjaHJlaXR1bmdcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBlcnJvcnNcbiAgICovXG4gIGVycm9yTWVzc2FnZU1vZGlmaWVyKHZhbHVlLCBlcnJvcnMpIHtcbiAgICBpZiAoZXJyb3JzLm1hdERhdGVwaWNrZXJNaW4pIHtcbiAgICAgIHJldHVybiAnRGFzIERhdHVtIHVudGVyc2NocmVpdGV0IGRlbiBNaW5pbWFsd2VydCc7XG4gICAgfSBlbHNlIGlmIChlcnJvcnMubWF0RGF0ZXBpY2tlck1heCkge1xuICAgICAgcmV0dXJuICdEYXMgRGF0dW0gw7xiZXJzY2hyZWl0ZXQgZGVuIE1heGltYWx3ZXJ0JztcbiAgICB9IGVsc2UgaWYgKGVycm9ycy5yZXF1aXJlZCkge1xuICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuZGF0ZXBpY2tlcklucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdEYXMgRGF0dW0gaXN0IHVuZ8O8bHRpZyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0RhcyBEYXR1bSBkYXJmIG5pY2h0IGxlZXIgc2Vpbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Qgb2IgZWluZSBtb2JpbGUgTWVkaWEtUXVlcnkgdm9ybGllZ3QuXG4gICAqIFdlbm4gamEsIHdpcmQgYXV0b21hZ2lzY2ggZGllIFRvdWNoVUkgYWt0aXZpZXJ0LlxuICAgKiBXZW5uIG5laW4sIHdpcmQgZGVyIHZvbSBBdWZydWZlci9vcmlnaW5hbGUgbHV4VG91Y2hVSS1XZXJ0IGdlbnV0enQuXG4gICAqL1xuICBwcml2YXRlIGNoZWNrTWVkaWFPYnNlcnZlcigpIHtcbiAgICBpZiAodGhpcy5tZWRpYU9ic2VydmVyLmlzWFMoKSB8fCB0aGlzLm1lZGlhT2JzZXJ2ZXIuaXNTTSgpKSB7XG4gICAgICB0aGlzLmx1eFRvdWNoVWkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmx1eFRvdWNoVWkgPSB0aGlzLm9yaWdpbmFsVG91Y2hVaTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRsO8aHJ0IC5vcGVuKCkgYnp3LiAuY2xvc2UoKSB2b20gTWF0RGF0ZXBpY2tlciBhdXMsIGFiaMOkbmdpZyB2b20gV2VydCBmw7xyIGx1eE9wZW5lZC5cbiAgICovXG4gIHByaXZhdGUgdHJpZ2dlck9wZW5DbG9zZSgpIHtcbiAgICBpZiAodGhpcy5sdXhPcGVuZWQpIHtcbiAgICAgIHRoaXMubWF0RGF0ZXBpY2tlci5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF0RGF0ZXBpY2tlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBa3R1YWxpc2llcnQgZGVuIEZvcm1Db250cm9sLVZhbHVlIHVuZCBkZW4gV2VydCBpbSBQYXJlbnQgw7xiZXIgdmFsdWVDaGFuZ2UgbWl0aGlsZmUgZGVzIMO8YmVyZ2ViZW5lbiBJU08tU3RyaW5ncy5cbiAgICogQHBhcmFtIGlzb1ZhbHVlXG4gICAqL1xuICBwcml2YXRlIHNldElTT1ZhbHVlKGlzb1ZhbHVlOiBzdHJpbmcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucHJldmlvdXNJU08gPSBpc29WYWx1ZTtcblxuICAgICAgLy8gdmFsdWVDaGFuZ2UtRW1pdHRlciBhbnN0b8OfZW5cbiAgICAgIHRoaXMubm90aWZ5Rm9ybVZhbHVlQ2hhbmdlZChpc29WYWx1ZSk7XG5cbiAgICAgIC8vIFwic2lsZW50bHlcIiBkZW4gRm9ybUNvbnRyb2wgYXVmIGRlbiAocG90ZW50aWVsbCkgZ2XDpG5kZXJ0ZW4gV2VydCBha3R1YWxpc2llcmVuXG4gICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKGlzb1ZhbHVlLCB7XG4gICAgICAgIGVtaXRFdmVudDogZmFsc2UsXG4gICAgICAgIGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UsXG4gICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQZXIgSGFuZCBkZW0gSW5wdXQtRWxlbWVudCBlaW5lbiBmb3JtYXRpZXJ0ZW4gU3RyaW5nIMO8YmVyZ2ViZW5cbiAgICAgIGlmICghdGhpcy5kYXRlcGlja2VySW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSAmJiBpc29WYWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXJJbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5kYXRlQWRhcHRlci5mb3JtYXQoXG4gICAgICAgICAgPGFueT5pc29WYWx1ZSxcbiAgICAgICAgICBBUFBfREFURV9GT1JNQVRTLmRpc3BsYXkuZGF0ZUlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyByZWdpb24gb3ZlcnJpZGRlbiBtZXRob2RzXG5cbiAgcHJvdGVjdGVkIHNldFZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMubHV4VmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5mb3JtQ29udHJvbCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGluaXRGb3JtVmFsdWVTdWJzY3JpcHRpb24oKSB7XG4gICAgLy8gQWt0dWFsaXNpZXJ1bmdlbiBhbiBkZW0gRm9ybUNvbnRyb2wtVmFsdWUgc29sbGVuIGF1Y2ggdmlhIEV2ZW50RW1pdHRlciBiZWthbm50IGdlbWFjaHQgd2VyZGVuXG4gICAgdGhpcy5fZm9ybVZhbHVlQ2hhbmdlU3Vic2NyID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZURhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5mb3JtQ29udHJvbC52YWx1ZSkge1xuICAgICAgLy8gRXMga2FubiB2b3Jrb21tZW4sIGRhc3MgZGVyIGluaXRpYWxlIFdlcnQgbmljaHQgaW0gSVNPLUZvcm1hdCBhbmdlZ2ViZW4gaXN0LlxuICAgICAgLy8gRGFubiBtdXNzIGRlciBXZXJ0IG5vY2ggdW1nZXdhbmRlbHQgd2VyZGVuLlxuICAgICAgdGhpcy51cGRhdGVEYXRlVmFsdWUodGhpcy5mb3JtQ29udHJvbC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgIT09IG51bGwgJiYgdGhpcy5faW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFZvcmhhbmRlbmVuIEluaXRpYWx3ZXJ0IHNldHplblxuICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLl9pbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGF0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLnNldElTT1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOYWNoZm9sZ2VuZCBlcnN0ZWxsZW5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKHZhbHVlLCB7fSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnREYXRlOiBEYXRlID0gdmFsdWU7XG4gICAgY29uc3QgdGVtcERhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgICB0ZW1wRGF0ZS5zZXRVVENGdWxsWWVhcihldmVudERhdGUuZ2V0RnVsbFllYXIoKSwgZXZlbnREYXRlLmdldE1vbnRoKCksIGV2ZW50RGF0ZS5nZXREYXRlKCkpO1xuICAgIHRlbXBEYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgLy8gU2ljaGVyaGVpdHNoYWxiZXIgbm9jaCBlaW5tYWwgcHLDvGZlbiwga2FubiB2b3Jrb21tZW4gZGFzIGVpbiB1bnNpbm5pZ2VyIFdlcnQgZWluZ2V0cmFnZW4gd2lyZFxuICAgIC8vIHouQi4gJ2FzZGYnLCBkYXMgZsO8aHJ0IHp1IEludmFsaWREYXRlJ3NcbiAgICBpZiAoTHV4VXRpbC5pc0RhdGUodGVtcERhdGUpICYmIHRoaXMucHJldmlvdXNJU08gIT09IHRlbXBEYXRlLnRvSVNPU3RyaW5nKCkpIHtcbiAgICAgIHRoaXMuc2V0SVNPVmFsdWUodGVtcERhdGUudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG59XG4iXX0=