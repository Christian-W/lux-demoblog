import * as tslib_1 from "tslib";
var LuxMenuComponent_1;
import { AfterViewChecked, ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, HostListener, Input, OnDestroy, Output, QueryList, ViewChild } from '@angular/core';
import { LuxMenuItemComponent } from './lux-menu-subcomponents/lux-menu-item.component';
import { LuxMenuTriggerComponent } from './lux-menu-subcomponents/lux-menu-trigger.component';
// @dynamic Erklärung steht in der Datei "lux-decorators.ts".
let LuxMenuComponent = LuxMenuComponent_1 = class LuxMenuComponent {
    constructor(cdr) {
        this.cdr = cdr;
        // Alle verfgb. MenuItems als Array
        this._menuItems = [];
        this.menuItemSubstcriptions = [];
        this.hideToggle = false;
        this.luxMenuClosed = new EventEmitter();
        this.luxMenuIconName = 'menu';
        this.luxToggleDisabled = false;
        this._luxDisplayExtended = false;
        this.luxDisplayMenuLeft = true;
        this.luxMaximumExtended = 5;
        this.canvas = document.createElement('canvas');
    }
    get luxDisplayExtended() {
        return this._luxDisplayExtended;
    }
    set luxDisplayExtended(value) {
        this._luxDisplayExtended = value;
        if (this.menuTriggerElRef) {
            this.updateExtendedMenuItems();
        }
    }
    windowResize() {
        this.updateExtendedMenuItems();
    }
    get menuItems() {
        return this._menuItems;
    }
    set menuItems(menuItems) {
        this._menuItems = menuItems ? menuItems : [];
        this.menuItems.forEach(item => {
            this.menuItemSubstcriptions.push(item.luxHiddenChange.subscribe(() => {
                this.updateExtendedMenuItems();
            }));
            this.menuItemSubstcriptions.push(item.luxAlwaysVisibleChange.subscribe(() => {
                this.updateExtendedMenuItems();
            }));
            this.menuItemSubstcriptions.push(item.luxHideLabelIfExtendedChange.subscribe(() => {
                this.updateExtendedMenuItems();
            }));
        });
        this.cdr.detectChanges();
    }
    ngAfterViewChecked() {
        this.luxMenuItemComponents.changes.subscribe(() => {
            this.menuItems = this.luxMenuItemComponents.toArray();
            this.calculateMenuItemWidths();
        });
        this.menuItems = this.luxMenuItemComponents.toArray();
        this.calculateMenuItemWidths();
        this.updateExtendedMenuItems();
    }
    ngOnDestroy() {
        this.menuItemSubstcriptions.forEach(menuItemSubscription => {
            menuItemSubscription.unsubscribe();
        });
    }
    /**
     * Wird beim Klick auf ein MenuItem aufgerufen.
     *
     * @param menuItem
     * @param $event
     */
    menuItemClicked(menuItem, $event) {
        menuItem.clicked($event);
    }
    /**
     * Wird nach dem Schließen des Menus aufgerufen und emitted die Output-Property.
     * Setzt den Fokus auf den Default-Trigger (Custom-Trigger => eigene Verantwortung).
     */
    onMenuClosed() {
        this.luxMenuClosed.emit();
        if (this.defaultTriggerElRef) {
            this.defaultTriggerElRef.nativeElement.children.item(0).focus();
        }
    }
    /**
     * Berechnet anhand der verfügbaren Breite des Containers (CSS-Class: lux-menu-extended) und der maximalen Anzahl an
     * extended MenuItems die Anzahl an möglichen MenuItems, die außerhalb des eigentlichen Menus dargestellt werden können.
     */
    updateExtendedMenuItems() {
        if (!this.luxDisplayExtended) {
            this.hideToggle = false;
            this.menuItems.forEach((menuItem) => {
                menuItem.extended = false;
            });
            return;
        }
        const menuTriggerWidth = this.menuTriggerElRef.nativeElement.offsetWidth;
        let availableWidth = this.menuExtendedContainer.nativeElement.offsetWidth;
        let count = 0;
        availableWidth -= menuTriggerWidth;
        // mit condition sind hier die Zustände luxVisible = true || false gemeint
        for (const condition of [true, false]) {
            for (let i = this.menuItems.length - 1; i >= 0; i--) {
                const menuItem = this.menuItems[i];
                if (menuItem.luxHidden) {
                    continue;
                }
                if (menuItem.luxAlwaysVisible === condition) {
                    // Wenn es das letzte Menüitem ist, wird geprüft, ob es anstelle des
                    // Menüitemtriggers dargestellt werden kann.
                    if (i === 0 && availableWidth + menuTriggerWidth >= menuItem.width) {
                        availableWidth += menuTriggerWidth;
                    }
                    availableWidth -= menuItem.width;
                    if (availableWidth >= 0 && count < this.luxMaximumExtended) {
                        menuItem.extended = true;
                        count++;
                    }
                    else {
                        menuItem.extended = false;
                    }
                }
            }
        }
        // die Anzahl der extended dargestellten Items der Gesamtzahl entspricht blenden wir den Toggle aus
        const extendedMenuItemCount = this.menuItems.filter((item) => item.extended && !item.luxHidden).length;
        const visibleMenuItemCount = this.menuItems.filter((item) => !item.luxHidden).length;
        this.hideToggle = extendedMenuItemCount === visibleMenuItemCount;
        this.cdr.detectChanges();
    }
    /**
     * Berechnet die Breite für jedes Menuitem und speichert diese abhängig davon ob das Item immer sichtbar sein soll oder nicht
     * in 2 verschiedenen Maps.
     */
    calculateMenuItemWidths() {
        this.menuItems.forEach((menuItem) => {
            menuItem.extended = false;
            menuItem.width = this.getMenuItemWidth(menuItem);
        });
    }
    /**
     * Gibt die berechnete Breite des MenuItems zurück.
     * Diese setzt sich aus dem Padding (links und rechts, je 16px), dem Icon (wenn vorhanden, 15px) und der berechneten
     * Textbreite zusammen.
     * @param menuItem
     */
    getMenuItemWidth(menuItem) {
        if (!menuItem) {
            return 0;
        }
        return (LuxMenuComponent_1.PADDING_PX +
            (menuItem.luxIconName ? LuxMenuComponent_1.ICON_PX : 0) +
            (!menuItem.luxHideLabelIfExtended ? this.getTextWidth(menuItem.luxLabel) : 0) +
            LuxMenuComponent_1.MARGIN_PX);
    }
    /**
     * Berechnet mithilfe eines Canvas-Objekts die Breite eines einzelnen Textes
     * @param text
     */
    getTextWidth(text) {
        if (!text) {
            return 0;
        }
        const canvas = this.canvas;
        const context = canvas.getContext('2d');
        context.font = `${LuxMenuComponent_1.FONT_PX}px sans-serif`;
        const metrics = context.measureText(text);
        // zusätzlich nutzen wir hier einen Standard-Offset von 20px
        return metrics.width + 20;
    }
    hasVisibleMenuItems() {
        let hasVisibleMenuItems = false;
        for (let i = 0; i < this.menuItems.length; i++) {
            const element = this.menuItems[i];
            if (!element.luxHidden && !element.extended) {
                hasVisibleMenuItems = true;
                break;
            }
        }
        return hasVisibleMenuItems;
    }
};
// Diese Werte müssen angepasst werden, sollte das Styling dieser Component entsprechend geändert worden sein
LuxMenuComponent.PADDING_PX = 16;
LuxMenuComponent.MARGIN_PX = 8;
LuxMenuComponent.FONT_PX = 14;
LuxMenuComponent.ICON_PX = 22;
LuxMenuComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
tslib_1.__decorate([
    ViewChild('defaultTrigger', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], LuxMenuComponent.prototype, "defaultTriggerElRef", void 0);
tslib_1.__decorate([
    ViewChild('menuTrigger', { read: ElementRef, static: false }),
    tslib_1.__metadata("design:type", ElementRef)
], LuxMenuComponent.prototype, "menuTriggerElRef", void 0);
tslib_1.__decorate([
    ViewChild('menuExtendedContainer', { read: ElementRef, static: true }),
    tslib_1.__metadata("design:type", ElementRef)
], LuxMenuComponent.prototype, "menuExtendedContainer", void 0);
tslib_1.__decorate([
    ContentChildren(LuxMenuItemComponent),
    tslib_1.__metadata("design:type", QueryList)
], LuxMenuComponent.prototype, "luxMenuItemComponents", void 0);
tslib_1.__decorate([
    ContentChild(LuxMenuTriggerComponent, { static: false }),
    tslib_1.__metadata("design:type", LuxMenuTriggerComponent)
], LuxMenuComponent.prototype, "luxMenuTriggerComponent", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], LuxMenuComponent.prototype, "luxMenuClosed", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxMenuComponent.prototype, "luxMenuIconName", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxMenuComponent.prototype, "luxClassName", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxMenuComponent.prototype, "luxTagId", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], LuxMenuComponent.prototype, "luxToggleDisabled", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], LuxMenuComponent.prototype, "luxDisplayExtended", null);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], LuxMenuComponent.prototype, "luxDisplayMenuLeft", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], LuxMenuComponent.prototype, "luxMaximumExtended", void 0);
tslib_1.__decorate([
    HostListener('window:resize'),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], LuxMenuComponent.prototype, "windowResize", null);
LuxMenuComponent = LuxMenuComponent_1 = tslib_1.__decorate([
    Component({
        selector: 'lux-menu',
        template: "<div fxLayout=\"row\" fxLayoutAlign=\"end\">\n  <div class=\"lux-menu-extended\" fxFlex=\"auto\" fxLayout=\"row\" fxLayoutAlign=\"end center\" #menuExtendedContainer>\n    <!-- Trigger, wenn luxDisplayMenuLeft === false -->\n    <ng-container *ngIf=\"!luxDisplayMenuLeft\">\n      <ng-container [ngTemplateOutlet]=\"menuTriggerTemplate\"></ng-container>\n    </ng-container>\n    <ng-container *ngFor=\"let menuItem of menuItems\">\n      <lux-button\n        class=\"lux-menu-item\"\n        [luxLabel]=\"menuItem.luxHideLabelIfExtended ? '' : menuItem.luxLabel\"\n        [luxColor]=\"menuItem.luxColor\"\n        [luxRaised]=\"menuItem.luxRaised\"\n        [luxIconName]=\"menuItem.luxIconName\"\n        [luxDisabled]=\"menuItem.luxDisabled\"\n        [luxTagId]=\"menuItem.luxTagId\"\n        [luxRounded]=\"menuItem.luxRounded\"\n        [luxIconAlignWithLabel]=\"menuItem.luxIconAlignWithLabel\"\n        (luxClicked)=\"menuItemClicked(menuItem, $event)\"\n        luxAriaLabel=\"{{ menuItem.luxLabel }}\"\n        luxAriaLabelSelector=\"button\"\n        luxTabIndex=\"0\"\n        [luxApplyToChildren]=\"['button']\"\n        [ngClass]=\"{ 'lux-display-none': !menuItem.extended || menuItem.luxHidden }\"\n      >\n      </lux-button>\n    </ng-container>\n    <!-- Trigger, wenn luxDisplayMenuLeft === true -->\n    <ng-container *ngIf=\"luxDisplayMenuLeft\">\n      <ng-container [ngTemplateOutlet]=\"menuTriggerTemplate\"></ng-container>\n    </ng-container>\n  </div>\n</div>\n\n<!-- Das eigentliche Material-Menu -->\n<mat-menu [classList]=\"'lux-menu-panel ' + luxClassName\" (closed)=\"onMenuClosed()\" #menu=\"matMenu\">\n  <!-- Alle darin angezeigten MenuItems (Voraussgesetzt diese sind nicht als extended gekennzeichnet) -->\n  <ng-container *ngFor=\"let menuItem of menuItems\">\n    <button\n      mat-menu-item\n      class=\"lux-menu-item\"\n      fxLayout=\"row\"\n      fxLayoutAlign=\"space-between center\"\n      [disabled]=\"menuItem.luxDisabled\"\n      luxTagIdHandler\n      [luxTagId]=\"menuItem.luxTagId\"\n      (click)=\"menuItemClicked(menuItem, $event)\"\n      *ngIf=\"!menuItem.extended && !menuItem.luxHidden\"\n    >\n      <lux-icon\n        [luxIconName]=\"menuItem.luxIconName\"\n        luxPadding=\"0\"\n        luxIconSize=\"2x\"\n        fxFlex=\"0 0 30px\"\n        fxLayout=\"row\"\n        fxLayoutAlign=\"center center\"\n      ></lux-icon>\n      <span class=\"lux-button-label\" fxFlex=\"auto\">\n        {{ menuItem.luxLabel }}\n      </span>\n    </button>\n  </ng-container>\n</mat-menu>\n\n<!-- Der Trigger des Menus -->\n<ng-template #menuTriggerTemplate>\n  <div\n    [matMenuTriggerFor]=\"menu\"\n    class=\"lux-menu-trigger\"\n    fxFlex=\"0 0 auto\"\n    [ngClass]=\"{ 'lux-display-none': hideToggle }\"\n    fxFlexAlign=\"center\"\n    #menuTrigger\n  >\n    <!-- Custom-Trigger, der \u00FCber Content-Projection geladen werden kann -->\n    <ng-content select=\"lux-menu-trigger\"> </ng-content>\n    <!-- Default-Trigger -->\n    <lux-button\n      class=\"lux-menu-trigger-default\"\n      luxTagId=\"lux-menu-default-trigger\"\n      [luxIconName]=\"luxMenuIconName\"\n      luxAriaLabel=\"Menu\"\n      luxAriaLabelSelector=\"button\"\n      luxTabIndex=\"0\"\n      [luxApplyToChildren]=\"['button']\"\n      [luxDisabled]=\"luxToggleDisabled\"\n      #defaultTrigger\n      *ngIf=\"!luxMenuTriggerComponent && hasVisibleMenuItems()\"\n    >\n    </lux-button>\n  </div>\n</ng-template>\n\n<ng-content select=\"lux-menu-item\"></ng-content>\n",
        styles: ["@charset \"UTF-8\";:host{display:block;width:100%}::ng-deep .lux-menu-panel .lux-menu-item{padding:0 8px;font-size:16px}::ng-deep .lux-menu-panel .lux-menu-item lux-icon{min-width:25px;max-width:25px}.lux-display-none{display:none!important}.lux-menu-extended{overflow:hidden;min-width:0;padding:4px 0;position:relative}.lux-menu-extended>lux-button{margin-right:8px}.lux-menu-extended>lux-button ::ng-deep button{padding-left:8px!important;padding-right:8px!important}.lux-menu-extended>lux-button ::ng-deep lux-icon i,.lux-menu-extended>lux-button ::ng-deep lux-icon mat-icon{width:15px;font-size:18px!important}.lux-menu-trigger ::ng-deep button{height:45px;min-width:45px;padding-left:8px!important;padding-right:8px!important}.lux-menu-trigger ::ng-deep button .mat-button-wrapper{display:inherit;font-weight:400}.lux-menu-trigger ::ng-deep button .mat-button-wrapper i,.lux-menu-trigger ::ng-deep button .mat-button-wrapper mat-icon{padding:0;font-size:18px!important}::ng-deep .lux-menu-item lux-icon i,::ng-deep .lux-menu-item lux-icon mat-icon{font-size:15px}"]
    }),
    tslib_1.__metadata("design:paramtypes", [ChangeDetectorRef])
], LuxMenuComponent);
export { LuxMenuComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LW1lbnUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGloay1nZmkvbHV4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJzcmMvYXBwL21vZHVsZXMvbHV4LWFjdGlvbi9sdXgtbWVudS9sdXgtbWVudS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsWUFBWSxFQUNaLGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNWLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGtEQUFrRCxDQUFDO0FBQ3hGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHFEQUFxRCxDQUFDO0FBRTlGLDZEQUE2RDtBQU03RCxJQUFhLGdCQUFnQix3QkFBN0IsTUFBYSxnQkFBZ0I7SUErRTNCLFlBQW9CLEdBQXNCO1FBQXRCLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBeEUxQyxtQ0FBbUM7UUFDM0IsZUFBVSxHQUEyQixFQUFFLENBQUM7UUFLeEMsMkJBQXNCLEdBQW1CLEVBQUUsQ0FBQztRQUVwRCxlQUFVLEdBQVksS0FBSyxDQUFDO1FBUWxCLGtCQUFhLEdBQXVCLElBQUksWUFBWSxFQUFRLENBQUM7UUFFOUQsb0JBQWUsR0FBVyxNQUFNLENBQUM7UUFHakMsc0JBQWlCLEdBQVksS0FBSyxDQUFDO1FBRTVDLHdCQUFtQixHQUFZLEtBQUssQ0FBQztRQWM1Qix1QkFBa0IsR0FBWSxJQUFJLENBQUM7UUFDbkMsdUJBQWtCLEdBQVcsQ0FBQyxDQUFDO1FBbUN0QyxJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDakQsQ0FBQztJQWpERCxJQUFJLGtCQUFr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RS9CLGdCQUFnQixDQWdQNUI7U0FoUFksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdExpc3RlbmVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMdXhNZW51SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbHV4LW1lbnUtc3ViY29tcG9uZW50cy9sdXgtbWVudS1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBMdXhNZW51VHJpZ2dlckNvbXBvbmVudCB9IGZyb20gJy4vbHV4LW1lbnUtc3ViY29tcG9uZW50cy9sdXgtbWVudS10cmlnZ2VyLmNvbXBvbmVudCc7XG5cbi8vIEBkeW5hbWljIEVya2zDpHJ1bmcgc3RlaHQgaW4gZGVyIERhdGVpIFwibHV4LWRlY29yYXRvcnMudHNcIi5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2x1eC1tZW51JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2x1eC1tZW51LmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbHV4LW1lbnUuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBMdXhNZW51Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgLy8gRGllc2UgV2VydGUgbcO8c3NlbiBhbmdlcGFzc3Qgd2VyZGVuLCBzb2xsdGUgZGFzIFN0eWxpbmcgZGllc2VyIENvbXBvbmVudCBlbnRzcHJlY2hlbmQgZ2XDpG5kZXJ0IHdvcmRlbiBzZWluXG4gIHN0YXRpYyByZWFkb25seSBQQURESU5HX1BYID0gMTY7XG4gIHN0YXRpYyByZWFkb25seSBNQVJHSU5fUFggPSA4O1xuICBzdGF0aWMgcmVhZG9ubHkgRk9OVF9QWCA9IDE0O1xuICBzdGF0aWMgcmVhZG9ubHkgSUNPTl9QWCA9IDIyO1xuXG4gIC8vIEFsbGUgdmVyZmdiLiBNZW51SXRlbXMgYWxzIEFycmF5XG4gIHByaXZhdGUgX21lbnVJdGVtczogTHV4TWVudUl0ZW1Db21wb25lbnRbXSA9IFtdO1xuXG4gIC8vIERhcyBDYW52YXMgd2lyZCBnZW51dHp0IHVtIGRpZSBCcmVpdGUgcG90ZW50aWVsbGVyIE1lbnVJdGVtLVRleHRlIHp1IGJlcmVjaG5lblxuICBwcml2YXRlIHJlYWRvbmx5IGNhbnZhcztcblxuICBwcml2YXRlIG1lbnVJdGVtU3Vic3RjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgaGlkZVRvZ2dsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ2RlZmF1bHRUcmlnZ2VyJywgeyByZWFkOiBFbGVtZW50UmVmLCBzdGF0aWM6IGZhbHNlIH0pIGRlZmF1bHRUcmlnZ2VyRWxSZWY6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ21lbnVUcmlnZ2VyJywgeyByZWFkOiBFbGVtZW50UmVmLCBzdGF0aWM6IGZhbHNlIH0pIG1lbnVUcmlnZ2VyRWxSZWY6IEVsZW1lbnRSZWY7XG4gIEBWaWV3Q2hpbGQoJ21lbnVFeHRlbmRlZENvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiB0cnVlIH0pIG1lbnVFeHRlbmRlZENvbnRhaW5lcjogRWxlbWVudFJlZjtcbiAgQENvbnRlbnRDaGlsZHJlbihMdXhNZW51SXRlbUNvbXBvbmVudCkgbHV4TWVudUl0ZW1Db21wb25lbnRzOiBRdWVyeUxpc3Q8THV4TWVudUl0ZW1Db21wb25lbnQ+O1xuICBAQ29udGVudENoaWxkKEx1eE1lbnVUcmlnZ2VyQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSkgbHV4TWVudVRyaWdnZXJDb21wb25lbnQ6IEx1eE1lbnVUcmlnZ2VyQ29tcG9uZW50O1xuXG4gIEBPdXRwdXQoKSBsdXhNZW51Q2xvc2VkOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgQElucHV0KCkgbHV4TWVudUljb25OYW1lOiBzdHJpbmcgPSAnbWVudSc7XG4gIEBJbnB1dCgpIGx1eENsYXNzTmFtZTogc3RyaW5nO1xuICBASW5wdXQoKSBsdXhUYWdJZDogc3RyaW5nO1xuICBASW5wdXQoKSBsdXhUb2dnbGVEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIF9sdXhEaXNwbGF5RXh0ZW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgbHV4RGlzcGxheUV4dGVuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9sdXhEaXNwbGF5RXh0ZW5kZWQ7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbHV4RGlzcGxheUV4dGVuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fbHV4RGlzcGxheUV4dGVuZGVkID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5tZW51VHJpZ2dlckVsUmVmKSB7XG4gICAgICB0aGlzLnVwZGF0ZUV4dGVuZGVkTWVudUl0ZW1zKCk7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCkgbHV4RGlzcGxheU1lbnVMZWZ0OiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCkgbHV4TWF4aW11bUV4dGVuZGVkOiBudW1iZXIgPSA1O1xuXG4gIEBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpyZXNpemUnKSB3aW5kb3dSZXNpemUoKSB7XG4gICAgdGhpcy51cGRhdGVFeHRlbmRlZE1lbnVJdGVtcygpO1xuICB9XG5cbiAgZ2V0IG1lbnVJdGVtcygpOiBMdXhNZW51SXRlbUNvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gdGhpcy5fbWVudUl0ZW1zO1xuICB9XG5cbiAgc2V0IG1lbnVJdGVtcyhtZW51SXRlbXM6IEx1eE1lbnVJdGVtQ29tcG9uZW50W10pIHtcbiAgICB0aGlzLl9tZW51SXRlbXMgPSBtZW51SXRlbXMgPyBtZW51SXRlbXMgOiBbXTtcblxuICAgIHRoaXMubWVudUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICB0aGlzLm1lbnVJdGVtU3Vic3RjcmlwdGlvbnMucHVzaChcbiAgICAgICAgaXRlbS5sdXhIaWRkZW5DaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUV4dGVuZGVkTWVudUl0ZW1zKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5tZW51SXRlbVN1YnN0Y3JpcHRpb25zLnB1c2goXG4gICAgICAgIGl0ZW0ubHV4QWx3YXlzVmlzaWJsZUNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMudXBkYXRlRXh0ZW5kZWRNZW51SXRlbXMoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLm1lbnVJdGVtU3Vic3RjcmlwdGlvbnMucHVzaChcbiAgICAgICAgaXRlbS5sdXhIaWRlTGFiZWxJZkV4dGVuZGVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVFeHRlbmRlZE1lbnVJdGVtcygpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgdGhpcy5sdXhNZW51SXRlbUNvbXBvbmVudHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5tZW51SXRlbXMgPSB0aGlzLmx1eE1lbnVJdGVtQ29tcG9uZW50cy50b0FycmF5KCk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1lbnVJdGVtV2lkdGhzKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lbnVJdGVtcyA9IHRoaXMubHV4TWVudUl0ZW1Db21wb25lbnRzLnRvQXJyYXkoKTtcbiAgICB0aGlzLmNhbGN1bGF0ZU1lbnVJdGVtV2lkdGhzKCk7XG4gICAgdGhpcy51cGRhdGVFeHRlbmRlZE1lbnVJdGVtcygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5tZW51SXRlbVN1YnN0Y3JpcHRpb25zLmZvckVhY2gobWVudUl0ZW1TdWJzY3JpcHRpb24gPT4ge1xuICAgICAgbWVudUl0ZW1TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaXJkIGJlaW0gS2xpY2sgYXVmIGVpbiBNZW51SXRlbSBhdWZnZXJ1ZmVuLlxuICAgKlxuICAgKiBAcGFyYW0gbWVudUl0ZW1cbiAgICogQHBhcmFtICRldmVudFxuICAgKi9cbiAgbWVudUl0ZW1DbGlja2VkKG1lbnVJdGVtOiBMdXhNZW51SXRlbUNvbXBvbmVudCwgJGV2ZW50KSB7XG4gICAgbWVudUl0ZW0uY2xpY2tlZCgkZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpcmQgbmFjaCBkZW0gU2NobGllw59lbiBkZXMgTWVudXMgYXVmZ2VydWZlbiB1bmQgZW1pdHRlZCBkaWUgT3V0cHV0LVByb3BlcnR5LlxuICAgKiBTZXR6dCBkZW4gRm9rdXMgYXVmIGRlbiBEZWZhdWx0LVRyaWdnZXIgKEN1c3RvbS1UcmlnZ2VyID0+IGVpZ2VuZSBWZXJhbnR3b3J0dW5nKS5cbiAgICovXG4gIG9uTWVudUNsb3NlZCgpIHtcbiAgICB0aGlzLmx1eE1lbnVDbG9zZWQuZW1pdCgpO1xuICAgIGlmICh0aGlzLmRlZmF1bHRUcmlnZ2VyRWxSZWYpIHtcbiAgICAgICg8YW55PnRoaXMuZGVmYXVsdFRyaWdnZXJFbFJlZi5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLml0ZW0oMCkpLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJlcmVjaG5ldCBhbmhhbmQgZGVyIHZlcmbDvGdiYXJlbiBCcmVpdGUgZGVzIENvbnRhaW5lcnMgKENTUy1DbGFzczogbHV4LW1lbnUtZXh0ZW5kZWQpIHVuZCBkZXIgbWF4aW1hbGVuIEFuemFobCBhblxuICAgKiBleHRlbmRlZCBNZW51SXRlbXMgZGllIEFuemFobCBhbiBtw7ZnbGljaGVuIE1lbnVJdGVtcywgZGllIGF1w59lcmhhbGIgZGVzIGVpZ2VudGxpY2hlbiBNZW51cyBkYXJnZXN0ZWxsdCB3ZXJkZW4ga8O2bm5lbi5cbiAgICovXG4gIHVwZGF0ZUV4dGVuZGVkTWVudUl0ZW1zKCkge1xuICAgIGlmICghdGhpcy5sdXhEaXNwbGF5RXh0ZW5kZWQpIHtcbiAgICAgIHRoaXMuaGlkZVRvZ2dsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5tZW51SXRlbXMuZm9yRWFjaCgobWVudUl0ZW06IEx1eE1lbnVJdGVtQ29tcG9uZW50KSA9PiB7XG4gICAgICAgIG1lbnVJdGVtLmV4dGVuZGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZW51VHJpZ2dlcldpZHRoID0gdGhpcy5tZW51VHJpZ2dlckVsUmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICBsZXQgYXZhaWxhYmxlV2lkdGg6IG51bWJlciA9IHRoaXMubWVudUV4dGVuZGVkQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgbGV0IGNvdW50OiBudW1iZXIgPSAwO1xuXG4gICAgYXZhaWxhYmxlV2lkdGggLT0gbWVudVRyaWdnZXJXaWR0aDtcblxuICAgIC8vIG1pdCBjb25kaXRpb24gc2luZCBoaWVyIGRpZSBadXN0w6RuZGUgbHV4VmlzaWJsZSA9IHRydWUgfHwgZmFsc2UgZ2VtZWludFxuICAgIGZvciAoY29uc3QgY29uZGl0aW9uIG9mIFt0cnVlLCBmYWxzZV0pIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLm1lbnVJdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMubWVudUl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChtZW51SXRlbS5sdXhIaWRkZW4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZW51SXRlbS5sdXhBbHdheXNWaXNpYmxlID09PSBjb25kaXRpb24pIHtcbiAgICAgICAgICAvLyBXZW5uIGVzIGRhcyBsZXR6dGUgTWVuw7xpdGVtIGlzdCwgd2lyZCBnZXByw7xmdCwgb2IgZXMgYW5zdGVsbGUgZGVzXG4gICAgICAgICAgLy8gTWVuw7xpdGVtdHJpZ2dlcnMgZGFyZ2VzdGVsbHQgd2VyZGVuIGthbm4uXG4gICAgICAgICAgaWYgKGkgPT09IDAgJiYgYXZhaWxhYmxlV2lkdGggKyBtZW51VHJpZ2dlcldpZHRoID49IG1lbnVJdGVtLndpZHRoKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCArPSBtZW51VHJpZ2dlcldpZHRoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF2YWlsYWJsZVdpZHRoIC09IG1lbnVJdGVtLndpZHRoO1xuXG4gICAgICAgICAgaWYgKGF2YWlsYWJsZVdpZHRoID49IDAgJiYgY291bnQgPCB0aGlzLmx1eE1heGltdW1FeHRlbmRlZCkge1xuICAgICAgICAgICAgbWVudUl0ZW0uZXh0ZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVudUl0ZW0uZXh0ZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkaWUgQW56YWhsIGRlciBleHRlbmRlZCBkYXJnZXN0ZWxsdGVuIEl0ZW1zIGRlciBHZXNhbXR6YWhsIGVudHNwcmljaHQgYmxlbmRlbiB3aXIgZGVuIFRvZ2dsZSBhdXNcbiAgICBjb25zdCBleHRlbmRlZE1lbnVJdGVtQ291bnQgPSB0aGlzLm1lbnVJdGVtcy5maWx0ZXIoXG4gICAgICAoaXRlbTogTHV4TWVudUl0ZW1Db21wb25lbnQpID0+IGl0ZW0uZXh0ZW5kZWQgJiYgIWl0ZW0ubHV4SGlkZGVuXG4gICAgKS5sZW5ndGg7XG4gICAgY29uc3QgdmlzaWJsZU1lbnVJdGVtQ291bnQgPSB0aGlzLm1lbnVJdGVtcy5maWx0ZXIoKGl0ZW06IEx1eE1lbnVJdGVtQ29tcG9uZW50KSA9PiAhaXRlbS5sdXhIaWRkZW4pLmxlbmd0aDtcbiAgICB0aGlzLmhpZGVUb2dnbGUgPSBleHRlbmRlZE1lbnVJdGVtQ291bnQgPT09IHZpc2libGVNZW51SXRlbUNvdW50O1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZXJlY2huZXQgZGllIEJyZWl0ZSBmw7xyIGplZGVzIE1lbnVpdGVtIHVuZCBzcGVpY2hlcnQgZGllc2UgYWJow6RuZ2lnIGRhdm9uIG9iIGRhcyBJdGVtIGltbWVyIHNpY2h0YmFyIHNlaW4gc29sbCBvZGVyIG5pY2h0XG4gICAqIGluIDIgdmVyc2NoaWVkZW5lbiBNYXBzLlxuICAgKi9cbiAgcHJpdmF0ZSBjYWxjdWxhdGVNZW51SXRlbVdpZHRocygpIHtcbiAgICB0aGlzLm1lbnVJdGVtcy5mb3JFYWNoKChtZW51SXRlbTogTHV4TWVudUl0ZW1Db21wb25lbnQpID0+IHtcbiAgICAgIG1lbnVJdGVtLmV4dGVuZGVkID0gZmFsc2U7XG4gICAgICBtZW51SXRlbS53aWR0aCA9IHRoaXMuZ2V0TWVudUl0ZW1XaWR0aChtZW51SXRlbSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2lidCBkaWUgYmVyZWNobmV0ZSBCcmVpdGUgZGVzIE1lbnVJdGVtcyB6dXLDvGNrLlxuICAgKiBEaWVzZSBzZXR6dCBzaWNoIGF1cyBkZW0gUGFkZGluZyAobGlua3MgdW5kIHJlY2h0cywgamUgMTZweCksIGRlbSBJY29uICh3ZW5uIHZvcmhhbmRlbiwgMTVweCkgdW5kIGRlciBiZXJlY2huZXRlblxuICAgKiBUZXh0YnJlaXRlIHp1c2FtbWVuLlxuICAgKiBAcGFyYW0gbWVudUl0ZW1cbiAgICovXG4gIHByaXZhdGUgZ2V0TWVudUl0ZW1XaWR0aChtZW51SXRlbTogTHV4TWVudUl0ZW1Db21wb25lbnQpOiBudW1iZXIge1xuICAgIGlmICghbWVudUl0ZW0pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBMdXhNZW51Q29tcG9uZW50LlBBRERJTkdfUFggK1xuICAgICAgKG1lbnVJdGVtLmx1eEljb25OYW1lID8gTHV4TWVudUNvbXBvbmVudC5JQ09OX1BYIDogMCkgK1xuICAgICAgKCFtZW51SXRlbS5sdXhIaWRlTGFiZWxJZkV4dGVuZGVkID8gdGhpcy5nZXRUZXh0V2lkdGgobWVudUl0ZW0ubHV4TGFiZWwpIDogMCkgK1xuICAgICAgTHV4TWVudUNvbXBvbmVudC5NQVJHSU5fUFhcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEJlcmVjaG5ldCBtaXRoaWxmZSBlaW5lcyBDYW52YXMtT2JqZWt0cyBkaWUgQnJlaXRlIGVpbmVzIGVpbnplbG5lbiBUZXh0ZXNcbiAgICogQHBhcmFtIHRleHRcbiAgICovXG4gIHByaXZhdGUgZ2V0VGV4dFdpZHRoKHRleHQpOiBudW1iZXIge1xuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZm9udCA9IGAke0x1eE1lbnVDb21wb25lbnQuRk9OVF9QWH1weCBzYW5zLXNlcmlmYDtcbiAgICBjb25zdCBtZXRyaWNzID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcblxuICAgIC8vIHp1c8OkdHpsaWNoIG51dHplbiB3aXIgaGllciBlaW5lbiBTdGFuZGFyZC1PZmZzZXQgdm9uIDIwcHhcbiAgICByZXR1cm4gbWV0cmljcy53aWR0aCArIDIwO1xuICB9XG5cbiAgaGFzVmlzaWJsZU1lbnVJdGVtcygpOiBib29sZWFuIHtcbiAgICBsZXQgaGFzVmlzaWJsZU1lbnVJdGVtcyA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbnVJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubWVudUl0ZW1zW2ldO1xuXG4gICAgICBpZiAoIWVsZW1lbnQubHV4SGlkZGVuICYmICFlbGVtZW50LmV4dGVuZGVkKSB7XG4gICAgICAgIGhhc1Zpc2libGVNZW51SXRlbXMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzVmlzaWJsZU1lbnVJdGVtcztcbiAgfVxufVxuIl19