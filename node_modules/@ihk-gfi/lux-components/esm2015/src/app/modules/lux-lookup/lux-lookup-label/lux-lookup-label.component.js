import * as tslib_1 from "tslib";
import { Component, Input } from '@angular/core';
import { LuxConsoleService } from '../../lux-util/lux-console.service';
import { LuxLookupParameters } from '../lux-lookup-model/lux-lookup-parameters';
import { LuxLookupHandlerService } from '../lux-lookup-service/lux-lookup-handler.service';
import { LuxLookupService } from '../lux-lookup-service/lux-lookup.service';
let LuxLookupLabelComponent = class LuxLookupLabelComponent {
    constructor(lookupService, lookupHandler, luxConsoleLogger) {
        this.luxLookupUrl = '/lookup/';
        this.luxBezeichnung = 'kurz';
        this.lookupService = lookupService;
        this.lookupHandler = lookupHandler;
        this.logger = luxConsoleLogger;
    }
    ngOnInit() {
        if (!this.luxLookupId) {
            console.error('Das Lookup-Label mit der Tabellen-Nr. ${this.luxTableNo} besitzt keine LookupId.' +
                'Bitte tragen Sie diese nach.');
        }
        if (!this.luxTableNo) {
            console.error('Das Lookup-Label mit der LookupId ${this.luxLookupId} besitzt keine Tabellen-Nummer. ' +
                'Bitte tragen Sie diese nach.');
        }
        if (!this.luxTableKey) {
            console.error('Das Lookup-Label mit der Tabellen-Nr. ${this.luxTableNo} besitzt keinen Tabellen-Key.' +
                'Bitte tragen Sie diese nach.');
        }
        this.fetchLookupData();
        this.lookupHandler.addLookupElement(this.luxLookupId);
        this.lookupHandler.getLookupElementObsv(this.luxLookupId).subscribe(() => {
            this.fetchLookupData();
        });
    }
    fetchLookupData() {
        const keys = [this.luxTableKey];
        this.lookupParameters = new LuxLookupParameters({ knr: this.luxLookupKnr, keys });
        this.lookupService
            .getLookupTable(this.luxTableNo, this.lookupParameters, this.luxLookupUrl)
            .subscribe((entries) => {
            if (typeof entries !== 'undefined' && entries.length === 1) {
                this.entry = entries[0];
            }
        });
    }
    /**
     * liefert die Bezeichnung (Kurz- oder Langbezeichnung) des Entries fÃ¼r den Key zur Tabelle.
     *
     * @returns string
     */
    getBezeichnung() {
        let bezeichnung = '';
        if (this.entry) {
            if ('kurz' === this.luxBezeichnung) {
                bezeichnung = this.entry.kurzText;
            }
            else if ('lang' === this.luxBezeichnung) {
                bezeichnung = this.entry.langText1;
                if (!bezeichnung) {
                    bezeichnung = this.entry.kurzText;
                }
            }
        }
        return bezeichnung;
    }
};
LuxLookupLabelComponent.ctorParameters = () => [
    { type: LuxLookupService },
    { type: LuxLookupHandlerService },
    { type: LuxConsoleService }
];
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], LuxLookupLabelComponent.prototype, "luxLookupKnr", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxLookupLabelComponent.prototype, "luxLookupId", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxLookupLabelComponent.prototype, "luxLookupUrl", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxLookupLabelComponent.prototype, "luxTableNo", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxLookupLabelComponent.prototype, "luxTableKey", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", String)
], LuxLookupLabelComponent.prototype, "luxBezeichnung", void 0);
LuxLookupLabelComponent = tslib_1.__decorate([
    Component({
        selector: 'lux-lookup-label',
        template: "<span>{{ getBezeichnung() }}</span>\n"
    }),
    tslib_1.__metadata("design:paramtypes", [LuxLookupService,
        LuxLookupHandlerService,
        LuxConsoleService])
], LuxLookupLabelComponent);
export { LuxLookupLabelComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LWxvb2t1cC1sYWJlbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaWhrLWdmaS9sdXgtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbInNyYy9hcHAvbW9kdWxlcy9sdXgtbG9va3VwL2x1eC1sb29rdXAtbGFiZWwvbHV4LWxvb2t1cC1sYWJlbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBQ3pELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBRWhGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGtEQUFrRCxDQUFDO0FBQzNGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBTTVFLElBQWEsdUJBQXVCLEdBQXBDLE1BQWEsdUJBQXVCO0lBZWxDLFlBQ0UsYUFBK0IsRUFDL0IsYUFBc0MsRUFDdEMsZ0JBQW1DO1FBUjVCLGlCQUFZLEdBQVcsVUFBVSxDQUFDO1FBR2xDLG1CQUFjLEdBQVcsTUFBTSxDQUFDO1FBT3ZDLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO1FBQ25DLElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQWdCLENBQUM7SUFDakMsQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNyQixPQUFPLENBQUMsS0FBSyxDQUNYLGtGQUFrRjtnQkFDaEYsOEJBQThCLENBQ2pDLENBQUM7U0FDSDtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ3BCLE9BQU8sQ0FBQyxLQUFLLENBQ1gsdUZBQXVGO2dCQUNyRiw4QkFBOEIsQ0FDakMsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsT0FBTyxDQUFDLEtBQUssQ0FDWCx1RkFBdUY7Z0JBQ3JGLDhCQUE4QixDQUNqQyxDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUN2RSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDekIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRVMsZUFBZTtRQUN2QixNQUFNLElBQUksR0FBYSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxtQkFBbUIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFFbEYsSUFBSSxDQUFDLGFBQWE7YUFDZixjQUFjLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQzthQUN6RSxTQUFTLENBQUMsQ0FBQyxPQUE4QixFQUFFLEVBQUU7WUFDNUMsSUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQzFELElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3pCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGNBQWM7UUFDWixJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFFckIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2QsSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDbEMsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO2FBQ25DO2lCQUFNLElBQUksTUFBTSxLQUFLLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3pDLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztnQkFFbkMsSUFBSSxDQUFDLFdBQVcsRUFBRTtvQkFDaEIsV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO2lCQUNuQzthQUNGO1NBQ0Y7UUFFRCxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDO0NBQ0YsQ0FBQTs7WUEzRWtCLGdCQUFnQjtZQUNoQix1QkFBdUI7WUFDcEIsaUJBQWlCOztBQVY1QjtJQUFSLEtBQUssRUFBRTs7NkRBQXNCO0FBQ3JCO0lBQVIsS0FBSyxFQUFFOzs0REFBcUI7QUFDcEI7SUFBUixLQUFLLEVBQUU7OzZEQUFtQztBQUNsQztJQUFSLEtBQUssRUFBRTs7MkRBQW9CO0FBQ25CO0lBQVIsS0FBSyxFQUFFOzs0REFBcUI7QUFDcEI7SUFBUixLQUFLLEVBQUU7OytEQUFpQztBQWI5Qix1QkFBdUI7SUFKbkMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLGtCQUFrQjtRQUM1QixpREFBZ0Q7S0FDakQsQ0FBQzs2Q0FpQmlCLGdCQUFnQjtRQUNoQix1QkFBdUI7UUFDcEIsaUJBQWlCO0dBbEIxQix1QkFBdUIsQ0EyRm5DO1NBM0ZZLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTHV4Q29uc29sZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9sdXgtdXRpbC9sdXgtY29uc29sZS5zZXJ2aWNlJztcbmltcG9ydCB7IEx1eExvb2t1cFBhcmFtZXRlcnMgfSBmcm9tICcuLi9sdXgtbG9va3VwLW1vZGVsL2x1eC1sb29rdXAtcGFyYW1ldGVycyc7XG5pbXBvcnQgeyBMdXhMb29rdXBUYWJsZUVudHJ5IH0gZnJvbSAnLi4vbHV4LWxvb2t1cC1tb2RlbC9sdXgtbG9va3VwLXRhYmxlLWVudHJ5JztcbmltcG9ydCB7IEx1eExvb2t1cEhhbmRsZXJTZXJ2aWNlIH0gZnJvbSAnLi4vbHV4LWxvb2t1cC1zZXJ2aWNlL2x1eC1sb29rdXAtaGFuZGxlci5zZXJ2aWNlJztcbmltcG9ydCB7IEx1eExvb2t1cFNlcnZpY2UgfSBmcm9tICcuLi9sdXgtbG9va3VwLXNlcnZpY2UvbHV4LWxvb2t1cC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbHV4LWxvb2t1cC1sYWJlbCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9sdXgtbG9va3VwLWxhYmVsLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBMdXhMb29rdXBMYWJlbENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGxvb2t1cFNlcnZpY2U6IEx1eExvb2t1cFNlcnZpY2U7XG4gIGxvb2t1cEhhbmRsZXI6IEx1eExvb2t1cEhhbmRsZXJTZXJ2aWNlO1xuICBsb2dnZXI6IEx1eENvbnNvbGVTZXJ2aWNlO1xuICBsb29rdXBQYXJhbWV0ZXJzOiBMdXhMb29rdXBQYXJhbWV0ZXJzO1xuXG4gIGVudHJ5OiBMdXhMb29rdXBUYWJsZUVudHJ5O1xuXG4gIEBJbnB1dCgpIGx1eExvb2t1cEtucjogbnVtYmVyO1xuICBASW5wdXQoKSBsdXhMb29rdXBJZDogc3RyaW5nO1xuICBASW5wdXQoKSBsdXhMb29rdXBVcmw6IHN0cmluZyA9ICcvbG9va3VwLyc7XG4gIEBJbnB1dCgpIGx1eFRhYmxlTm86IHN0cmluZztcbiAgQElucHV0KCkgbHV4VGFibGVLZXk6IHN0cmluZztcbiAgQElucHV0KCkgbHV4QmV6ZWljaG51bmc6IHN0cmluZyA9ICdrdXJ6JztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBsb29rdXBTZXJ2aWNlOiBMdXhMb29rdXBTZXJ2aWNlLFxuICAgIGxvb2t1cEhhbmRsZXI6IEx1eExvb2t1cEhhbmRsZXJTZXJ2aWNlLFxuICAgIGx1eENvbnNvbGVMb2dnZXI6IEx1eENvbnNvbGVTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMubG9va3VwU2VydmljZSA9IGxvb2t1cFNlcnZpY2U7XG4gICAgdGhpcy5sb29rdXBIYW5kbGVyID0gbG9va3VwSGFuZGxlcjtcbiAgICB0aGlzLmxvZ2dlciA9IGx1eENvbnNvbGVMb2dnZXI7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMubHV4TG9va3VwSWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdEYXMgTG9va3VwLUxhYmVsIG1pdCBkZXIgVGFiZWxsZW4tTnIuICR7dGhpcy5sdXhUYWJsZU5vfSBiZXNpdHp0IGtlaW5lIExvb2t1cElkLicgK1xuICAgICAgICAgICdCaXR0ZSB0cmFnZW4gU2llIGRpZXNlIG5hY2guJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubHV4VGFibGVObykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0RhcyBMb29rdXAtTGFiZWwgbWl0IGRlciBMb29rdXBJZCAke3RoaXMubHV4TG9va3VwSWR9IGJlc2l0enQga2VpbmUgVGFiZWxsZW4tTnVtbWVyLiAnICtcbiAgICAgICAgICAnQml0dGUgdHJhZ2VuIFNpZSBkaWVzZSBuYWNoLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmx1eFRhYmxlS2V5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnRGFzIExvb2t1cC1MYWJlbCBtaXQgZGVyIFRhYmVsbGVuLU5yLiAke3RoaXMubHV4VGFibGVOb30gYmVzaXR6dCBrZWluZW4gVGFiZWxsZW4tS2V5LicgK1xuICAgICAgICAgICdCaXR0ZSB0cmFnZW4gU2llIGRpZXNlIG5hY2guJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoTG9va3VwRGF0YSgpO1xuXG4gICAgdGhpcy5sb29rdXBIYW5kbGVyLmFkZExvb2t1cEVsZW1lbnQodGhpcy5sdXhMb29rdXBJZCk7XG4gICAgdGhpcy5sb29rdXBIYW5kbGVyLmdldExvb2t1cEVsZW1lbnRPYnN2KHRoaXMubHV4TG9va3VwSWQpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoTG9va3VwRGF0YSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGZldGNoTG9va3VwRGF0YSgpIHtcbiAgICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFt0aGlzLmx1eFRhYmxlS2V5XTtcblxuICAgIHRoaXMubG9va3VwUGFyYW1ldGVycyA9IG5ldyBMdXhMb29rdXBQYXJhbWV0ZXJzKHsga25yOiB0aGlzLmx1eExvb2t1cEtuciwga2V5cyB9KTtcblxuICAgIHRoaXMubG9va3VwU2VydmljZVxuICAgICAgLmdldExvb2t1cFRhYmxlKHRoaXMubHV4VGFibGVObywgdGhpcy5sb29rdXBQYXJhbWV0ZXJzLCB0aGlzLmx1eExvb2t1cFVybClcbiAgICAgIC5zdWJzY3JpYmUoKGVudHJpZXM6IEx1eExvb2t1cFRhYmxlRW50cnlbXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJpZXMgIT09ICd1bmRlZmluZWQnICYmIGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5lbnRyeSA9IGVudHJpZXNbMF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIGxpZWZlcnQgZGllIEJlemVpY2hudW5nIChLdXJ6LSBvZGVyIExhbmdiZXplaWNobnVuZykgZGVzIEVudHJpZXMgZsO8ciBkZW4gS2V5IHp1ciBUYWJlbGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICovXG4gIGdldEJlemVpY2hudW5nKCk6IHN0cmluZyB7XG4gICAgbGV0IGJlemVpY2hudW5nID0gJyc7XG5cbiAgICBpZiAodGhpcy5lbnRyeSkge1xuICAgICAgaWYgKCdrdXJ6JyA9PT0gdGhpcy5sdXhCZXplaWNobnVuZykge1xuICAgICAgICBiZXplaWNobnVuZyA9IHRoaXMuZW50cnkua3VyelRleHQ7XG4gICAgICB9IGVsc2UgaWYgKCdsYW5nJyA9PT0gdGhpcy5sdXhCZXplaWNobnVuZykge1xuICAgICAgICBiZXplaWNobnVuZyA9IHRoaXMuZW50cnkubGFuZ1RleHQxO1xuXG4gICAgICAgIGlmICghYmV6ZWljaG51bmcpIHtcbiAgICAgICAgICBiZXplaWNobnVuZyA9IHRoaXMuZW50cnkua3VyelRleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmV6ZWljaG51bmc7XG4gIH1cbn1cbiJdfQ==