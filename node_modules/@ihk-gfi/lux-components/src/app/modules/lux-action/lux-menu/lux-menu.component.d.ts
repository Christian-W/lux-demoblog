import { AfterViewChecked, ChangeDetectorRef, ElementRef, EventEmitter, OnDestroy, QueryList } from '@angular/core';
import { LuxMenuItemComponent } from './lux-menu-subcomponents/lux-menu-item.component';
import { LuxMenuTriggerComponent } from './lux-menu-subcomponents/lux-menu-trigger.component';
export declare class LuxMenuComponent implements AfterViewChecked, OnDestroy {
    private cdr;
    static readonly PADDING_PX = 16;
    static readonly MARGIN_PX = 8;
    static readonly FONT_PX = 14;
    static readonly ICON_PX = 22;
    private _menuItems;
    private readonly canvas;
    private menuItemSubstcriptions;
    hideToggle: boolean;
    defaultTriggerElRef: ElementRef;
    menuTriggerElRef: ElementRef;
    menuExtendedContainer: ElementRef;
    luxMenuItemComponents: QueryList<LuxMenuItemComponent>;
    luxMenuTriggerComponent: LuxMenuTriggerComponent;
    luxMenuClosed: EventEmitter<void>;
    luxMenuIconName: string;
    luxClassName: string;
    luxTagId: string;
    luxToggleDisabled: boolean;
    _luxDisplayExtended: boolean;
    luxDisplayExtended: boolean;
    luxDisplayMenuLeft: boolean;
    luxMaximumExtended: number;
    windowResize(): void;
    menuItems: LuxMenuItemComponent[];
    constructor(cdr: ChangeDetectorRef);
    ngAfterViewChecked(): void;
    ngOnDestroy(): void;
    /**
     * Wird beim Klick auf ein MenuItem aufgerufen.
     *
     * @param menuItem
     * @param $event
     */
    menuItemClicked(menuItem: LuxMenuItemComponent, $event: any): void;
    /**
     * Wird nach dem Schließen des Menus aufgerufen und emitted die Output-Property.
     * Setzt den Fokus auf den Default-Trigger (Custom-Trigger => eigene Verantwortung).
     */
    onMenuClosed(): void;
    /**
     * Berechnet anhand der verfügbaren Breite des Containers (CSS-Class: lux-menu-extended) und der maximalen Anzahl an
     * extended MenuItems die Anzahl an möglichen MenuItems, die außerhalb des eigentlichen Menus dargestellt werden können.
     */
    updateExtendedMenuItems(): void;
    /**
     * Berechnet die Breite für jedes Menuitem und speichert diese abhängig davon ob das Item immer sichtbar sein soll oder nicht
     * in 2 verschiedenen Maps.
     */
    private calculateMenuItemWidths;
    /**
     * Gibt die berechnete Breite des MenuItems zurück.
     * Diese setzt sich aus dem Padding (links und rechts, je 16px), dem Icon (wenn vorhanden, 15px) und der berechneten
     * Textbreite zusammen.
     * @param menuItem
     */
    private getMenuItemWidth;
    /**
     * Berechnet mithilfe eines Canvas-Objekts die Breite eines einzelnen Textes
     * @param text
     */
    private getTextWidth;
    hasVisibleMenuItems(): boolean;
}
