import { AfterViewInit, DoCheck, ElementRef, EventEmitter, OnDestroy, OnInit, QueryList } from '@angular/core';
import { MatPaginator, MatSort, Sort } from '@angular/material';
import { ICustomCSSConfig } from './lux-table-custom-css-config.interface';
import { LuxTableDataSource } from './lux-table-data-source';
import { ILuxTableHttpDao } from './lux-table-http/lux-table-http-dao.interface';
import { Subject } from 'rxjs';
import { LuxMediaQueryObserverService } from '../../lux-util/lux-media-query-observer.service';
import { LuxTableColumnComponent } from './lux-table-subcomponents/lux-table-column.component';
import { LuxConsoleService } from '../../lux-util/lux-console.service';
import { LiveAnnouncer } from '@angular/cdk/a11y';
export declare class LuxTableComponent implements OnInit, AfterViewInit, DoCheck, OnDestroy {
    private queryObserver;
    private luxConsole;
    private liveAnnouncer;
    static AUTO_PAGINATION_START: number;
    private _luxClasses;
    private _luxShowPagination;
    private _dataColumnDefs;
    private _luxMultiSelect;
    private _luxShowFilter;
    private _dataSource;
    private _luxPickValue;
    private _luxCompareWith;
    private previousWidth;
    private previousHeight;
    private httpRequestConf;
    private mediaQuerySubscription;
    private httpDaoSubscription;
    private filterChangedSubscription;
    private columnSubscriptions;
    private tableColumnsChangedSubscription;
    private sortChangedSubscription;
    private paginatorPageSubscription;
    private selectedSubscription;
    filtered$: Subject<string>;
    currentCustomClasses: {
        entry: any;
        classes: string;
    }[];
    isLoadingResults: boolean;
    isIE: boolean;
    allSelected: boolean;
    mediaQuery: string;
    movedTableColumns: LuxTableColumnComponent[];
    tableMinWidth: string;
    tableHeightCSSCalc: string;
    luxColWidthsPercent: number[];
    luxFilterText: string;
    luxNoDataText: string;
    luxPageSize: number;
    luxPageSizeOptions: number[];
    luxHttpDAO: ILuxTableHttpDao;
    luxMinWidthPx: number;
    luxAutoPaginate: boolean;
    luxHideBorders: boolean;
    luxSelectedChange: EventEmitter<any[]>;
    paginator: MatPaginator;
    sort: MatSort;
    paginatorElement: ElementRef;
    filterElement: ElementRef;
    tableContainerElement: ElementRef;
    tableColumns: QueryList<LuxTableColumnComponent>;
    luxClasses: ICustomCSSConfig | ICustomCSSConfig[];
    luxShowPagination: boolean;
    luxShowFilter: boolean;
    readonly dataColumnDefs: string[];
    readonly dataSource: LuxTableDataSource<any>;
    luxData: any[];
    luxMultiSelect: boolean;
    private _luxSelected;
    /**
    * Die Auswahl der Selektierten Elemente ist eigentlich ein Set,
    * nimmt aber Arrays von Außen entgegen (zur Vereinfachung).
    * @param selected
    */
    luxSelected: Set<any>;
    luxPickValue: (o: any) => any;
    luxCompareWith: (o1: any, o2: any) => boolean;
    /**
     * Eigene Implementierung der Filterung für diese Tabelle.
     * Iteriert über die Values des einzelnen Objektes und prüft dann ob der Filter-Wert irgendwo vorkommt.
     * @param data
     * @param filter
     */
    private customFilterPredicate;
    constructor(queryObserver: LuxMediaQueryObserverService, luxConsole: LuxConsoleService, liveAnnouncer: LiveAnnouncer);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngDoCheck(): void;
    ngOnDestroy(): void;
    /**
     * Zieht sich die aktuellen CSS-Klassen aus den zugewiesenen
     * CSS-Klassen.
     * @param row
     * @returns string
     */
    getCustomClassesForIndex(row: any): string;
    /**
     * TrackBy-Funktion um die Tabelle etwas schneller zu machen.
     * @param index
     * @param item
     */
    trackFn(index: any, item: any): any;
    /**
     * Wird beim Klick auf eine Row aufgerufen und handelt das Sichern und Entfernen von
     * selektierten Einträgen.
     * @param entry
     */
    changeSelectedEntry(entry: any): void;
    /**
     * Selektiert/Deselektiert alle Einträge in dieser Tabelle.
     *
     * Voraussetzung dafür ist, das Multiselect aktiv ist und keine Http-Table vorliegt.
     */
    changeSelectedEntries(): void;
    /**
     * Prüft ob die aktuell angezeigten Einträge alle selektiert sind oder nicht.
     */
    checkFilteredAllSelected(): boolean;
    /**
     * Gibt zurück, ob irgendein Footer-Element für diese Tabelle aktuell sichtbar ist.
     */
    anyFootersAvailable(): boolean;
    /**
     * Aktualisiert die DataSource und evtl. Subscriptions sowie die CustomCSS-Classes
     * nach einer Änderung.
     */
    private updateDataSourceAttributes;
    /**
     * Prueft anhand der mitgegebenen Callbacks die CSS-Klassen
     * fuer die einzelnen Rows.
     */
    private insertCustomCSSClasses;
    /**
     * Gibt das Aria-Label für die Sortierung der Spalten-Überschrift zurück.
     * @param tableColumnDef
     */
    getAriaSortingLabel(tableColumnDef: string): "aufsteigend sortiert" | "absteigend sortiert" | "nicht sortiert";
    /**
     * Gibt über den liveAnnouncer eine Nachricht aus, dass sich die Sortierung einer Spalte geändert hat.
     * @param $event
     */
    announceSortChange($event: Sort): void;
    /**
     * Aktualisiert die momentan angezeigten Spalten anhand der für sie definierten
     * Responsive-Queries und Verhaltensweisen.
     */
    private updateColumnsByMediaQuery;
    /**
     * Prüft ob die aktuelle MediaQuery mit der übergebenen MediaQuery/den übergebenen MediaQueries übereinstimmt.
     * @param responsiveAt
     */
    private doesResponsiveAtApply;
    /**
     * Durchläuft die aktuellen TableColumns und hört auf Changes in den Properties
     * der Columns und merkt sich die Subscriptions.
     */
    private updateColumnSubscriptions;
    /**
     * Triggert über das DAO die Abfrage nach neuen Daten.
     * Sendet dabei das Request-Conf Objekt, welches Informationen bzgl.
     * page, pageSize, filter, sort, order mitgibt.
     * @param filteredBy?
     */
    private loadHttpDAOData;
    /**
     * Wird aufgerufen wenn der Sort neu zur DataSource hinzugefügt werden soll (Data wurde neu gesetzt).
     * Resettet die Pagination und aktualisiert wenn es sich um eine asynchrone Tabelle handelt die
     * requestConf.
     */
    private handleSort;
    /**
     * Wird nach dem set von luxShowFilter aufgerufen und fängt neue Filter-Operationen ab und
     * aktualisiert dementsprechend die Daten.
     */
    private handleFilter;
    /**
     * Wird nach dem set von luxShowPagination aufgerufen und setzt wenn es sich hier um
     * eine asynchrone Tabelle handelt eine Subscription um Pagination-Änderungen zu erhalten.
     */
    private handlePagination;
    /**
     * Erzeugt einen neuen String für die Höhenberechnung der Tabelle und setzt die Minimalbreite für die Tabelle
     * (wenn möglich).
     */
    private calculateProportions;
    /**
     * Aktualisiert die selectedEntries dieser Component anhand der aktuell gesetzten luxSelected-Elemente.
     *
     * Dabei werden die einzelnen Elemente zuerst mithilfe der luxCompareWith- und luxPickValue-Functions miteinander
     * verglichen.
     */
    private updateSelection;
}
