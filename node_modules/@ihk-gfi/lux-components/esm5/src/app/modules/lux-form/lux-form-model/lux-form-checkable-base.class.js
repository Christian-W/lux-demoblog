import * as tslib_1 from "tslib";
import { Validators } from '@angular/forms';
import { EventEmitter, Input, Output } from '@angular/core';
import { LuxFormComponentBase } from './lux-form-component-base.class';
/**
 * Basis-Klasse f체r FormComponents, die einen 채hnlichen Grundaufbau f체r das Aktivieren eines Boolean-Wertes besitzen
 * (LuxToggle und LuxCheckbox z.B.).
 */
var LuxFormCheckableBaseClass = /** @class */ (function (_super) {
    tslib_1.__extends(LuxFormCheckableBaseClass, _super);
    function LuxFormCheckableBaseClass(controlContainer, cdr, logger, config) {
        var _this = _super.call(this, controlContainer, cdr, logger, config) || this;
        _this.luxCheckedChange = new EventEmitter();
        return _this;
    }
    Object.defineProperty(LuxFormCheckableBaseClass.prototype, "luxChecked", {
        get: function () {
            return this.getValue();
        },
        set: function (checked) {
            this.setValue(checked);
        },
        enumerable: true,
        configurable: true
    });
    // region Overridden methods
    LuxFormCheckableBaseClass.prototype.notifyFormValueChanged = function (formValue) {
        // Aktualisierungen an dem FormControl-Value sollen auch via EventEmitter bekannt gemacht werden
        this.luxCheckedChange.emit(formValue);
        // Bei luxRequired = true && einem false-Wert entsprechend einen Fehler setzen
        if (formValue === false && this.luxRequired && this.formControl.errors === null) {
            this.formControl.setErrors({ required: true });
        }
    };
    LuxFormCheckableBaseClass.prototype.errorMessageModifier = function (value, errors) {
        if (errors.required) {
            return 'Das ist ein Pflichtfeld';
        }
        return undefined;
    };
    LuxFormCheckableBaseClass.prototype.checkValidatorsContainRequired = function (validators) {
        // Fall: required = true, aber neue Validatoren werden gesetzt
        if (this.luxRequired === true) {
            // Sind es mehrere Validatoren, aber kein .requiredTrue? Dann wird er erg채nzt
            if (Array.isArray(validators) && validators.indexOf(Validators.requiredTrue) === -1) {
                validators.push(Validators.requiredTrue);
            }
            else if (!Array.isArray(validators) && validators !== Validators.requiredTrue) {
                // Ist es nur ein einzelner Validator und nicht .requiredTrue? Dann Array erstellen und beide kombinieren
                validators = [validators, Validators.requiredTrue];
            }
        }
        else if (this.luxRequired === false) {
            if (Array.isArray(validators)) {
                validators = validators.filter(function (validator) { return validator !== Validators.requiredTrue; });
            }
            else if (validators === Validators.requiredTrue) {
                validators = undefined;
            }
        }
        return validators;
    };
    LuxFormCheckableBaseClass.prototype.triggerOutputPatternCheck = function () {
        this.checkOutputPatternViolation(this.luxCheckedChange.observers);
    };
    LuxFormCheckableBaseClass.prototype.triggerInputPatternCheck = function (simpleChanges) {
        this.checkInputPatternViolation(simpleChanges.luxChecked);
    };
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], LuxFormCheckableBaseClass.prototype, "luxCheckedChange", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormCheckableBaseClass.prototype, "luxTagId", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxFormCheckableBaseClass.prototype, "luxReadonly", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], LuxFormCheckableBaseClass.prototype, "luxChecked", null);
    return LuxFormCheckableBaseClass;
}(LuxFormComponentBase));
export { LuxFormCheckableBaseClass };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LWZvcm0tY2hlY2thYmxlLWJhc2UuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaWhrLWdmaS9sdXgtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbInNyYy9hcHAvbW9kdWxlcy9sdXgtZm9ybS9sdXgtZm9ybS1tb2RlbC9sdXgtZm9ybS1jaGVja2FibGUtYmFzZS5jbGFzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFpQyxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRSxPQUFPLEVBQXFCLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUU5RixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUd2RTs7O0dBR0c7QUFDSDtJQUF3RCxxREFBb0I7SUFjMUUsbUNBQ0UsZ0JBQWtDLEVBQ2xDLEdBQXNCLEVBQ3RCLE1BQXlCLEVBQ3pCLE1BQWtDO1FBSnBDLFlBTUUsa0JBQU0sZ0JBQWdCLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsU0FDN0M7UUFwQlMsc0JBQWdCLEdBQTBCLElBQUksWUFBWSxFQUFFLENBQUM7O0lBb0J2RSxDQUFDO0lBZkQsc0JBQUksaURBQVU7YUFBZDtZQUNFLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3pCLENBQUM7YUFFUSxVQUFlLE9BQWdCO1lBQ3RDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekIsQ0FBQzs7O09BSkE7SUFlRCw0QkFBNEI7SUFDNUIsMERBQXNCLEdBQXRCLFVBQXVCLFNBQWtCO1FBQ3ZDLGdHQUFnRztRQUNoRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXRDLDhFQUE4RTtRQUM5RSxJQUFJLFNBQVMsS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUU7WUFDL0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFRCx3REFBb0IsR0FBcEIsVUFBcUIsS0FBSyxFQUFFLE1BQU07UUFDaEMsSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ25CLE9BQU8seUJBQXlCLENBQUM7U0FDbEM7UUFDRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRVMsa0VBQThCLEdBQXhDLFVBQXlDLFVBQXVDO1FBQzlFLDhEQUE4RDtRQUM5RCxJQUFJLElBQUksQ0FBQyxXQUFXLEtBQUssSUFBSSxFQUFFO1lBQzdCLDZFQUE2RTtZQUM3RSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQ25GLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQzFDO2lCQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLFVBQVUsS0FBSyxVQUFVLENBQUMsWUFBWSxFQUFFO2dCQUMvRSx5R0FBeUc7Z0JBQ3pHLFVBQVUsR0FBRyxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDcEQ7U0FDRjthQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxLQUFLLEVBQUU7WUFDckMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUM3QixVQUFVLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFDLFNBQXNCLElBQUssT0FBQSxTQUFTLEtBQUssVUFBVSxDQUFDLFlBQVksRUFBckMsQ0FBcUMsQ0FBQyxDQUFDO2FBQ25HO2lCQUFNLElBQUksVUFBVSxLQUFLLFVBQVUsQ0FBQyxZQUFZLEVBQUU7Z0JBQ2pELFVBQVUsR0FBRyxTQUFTLENBQUM7YUFDeEI7U0FDRjtRQUVELE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFUyw2REFBeUIsR0FBbkM7UUFDRSxJQUFJLENBQUMsMkJBQTJCLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFUyw0REFBd0IsR0FBbEMsVUFBbUMsYUFBNEI7UUFDN0QsSUFBSSxDQUFDLDBCQUEwQixDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBbkVTO1FBQVQsTUFBTSxFQUFFOzBDQUFtQixZQUFZO3VFQUErQjtJQUU5RDtRQUFSLEtBQUssRUFBRTs7K0RBQWtCO0lBQ2pCO1FBQVIsS0FBSyxFQUFFOztrRUFBc0I7SUFNckI7UUFBUixLQUFLLEVBQUU7OzsrREFFUDtJQTJESCxnQ0FBQztDQUFBLEFBdkVELENBQXdELG9CQUFvQixHQXVFM0U7U0F2RXFCLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRyb2xDb250YWluZXIsIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTHV4Q29uc29sZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9sdXgtdXRpbC9sdXgtY29uc29sZS5zZXJ2aWNlJztcbmltcG9ydCB7IEx1eEZvcm1Db21wb25lbnRCYXNlIH0gZnJvbSAnLi9sdXgtZm9ybS1jb21wb25lbnQtYmFzZS5jbGFzcyc7XG5pbXBvcnQgeyBMdXhDb21wb25lbnRzQ29uZmlnU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC1jb21wb25lbnRzLWNvbmZpZy9sdXgtY29tcG9uZW50cy1jb25maWcuc2VydmljZSc7XG5cbi8qKlxuICogQmFzaXMtS2xhc3NlIGbDvHIgRm9ybUNvbXBvbmVudHMsIGRpZSBlaW5lbiDDpGhubGljaGVuIEdydW5kYXVmYmF1IGbDvHIgZGFzIEFrdGl2aWVyZW4gZWluZXMgQm9vbGVhbi1XZXJ0ZXMgYmVzaXR6ZW5cbiAqIChMdXhUb2dnbGUgdW5kIEx1eENoZWNrYm94IHouQi4pLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTHV4Rm9ybUNoZWNrYWJsZUJhc2VDbGFzcyBleHRlbmRzIEx1eEZvcm1Db21wb25lbnRCYXNlIHtcbiAgQE91dHB1dCgpIGx1eENoZWNrZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBASW5wdXQoKSBsdXhUYWdJZDogc3RyaW5nO1xuICBASW5wdXQoKSBsdXhSZWFkb25seTogYm9vbGVhbjtcblxuICBnZXQgbHV4Q2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGx1eENoZWNrZWQoY2hlY2tlZDogYm9vbGVhbikge1xuICAgIHRoaXMuc2V0VmFsdWUoY2hlY2tlZCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoXG4gICAgY29udHJvbENvbnRhaW5lcjogQ29udHJvbENvbnRhaW5lcixcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIGxvZ2dlcjogTHV4Q29uc29sZVNlcnZpY2UsXG4gICAgY29uZmlnOiBMdXhDb21wb25lbnRzQ29uZmlnU2VydmljZVxuICApIHtcbiAgICBzdXBlcihjb250cm9sQ29udGFpbmVyLCBjZHIsIGxvZ2dlciwgY29uZmlnKTtcbiAgfVxuXG4gIC8vIHJlZ2lvbiBPdmVycmlkZGVuIG1ldGhvZHNcbiAgbm90aWZ5Rm9ybVZhbHVlQ2hhbmdlZChmb3JtVmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvLyBBa3R1YWxpc2llcnVuZ2VuIGFuIGRlbSBGb3JtQ29udHJvbC1WYWx1ZSBzb2xsZW4gYXVjaCB2aWEgRXZlbnRFbWl0dGVyIGJla2FubnQgZ2VtYWNodCB3ZXJkZW5cbiAgICB0aGlzLmx1eENoZWNrZWRDaGFuZ2UuZW1pdChmb3JtVmFsdWUpO1xuXG4gICAgLy8gQmVpIGx1eFJlcXVpcmVkID0gdHJ1ZSAmJiBlaW5lbSBmYWxzZS1XZXJ0IGVudHNwcmVjaGVuZCBlaW5lbiBGZWhsZXIgc2V0emVuXG4gICAgaWYgKGZvcm1WYWx1ZSA9PT0gZmFsc2UgJiYgdGhpcy5sdXhSZXF1aXJlZCAmJiB0aGlzLmZvcm1Db250cm9sLmVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRFcnJvcnMoeyByZXF1aXJlZDogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICBlcnJvck1lc3NhZ2VNb2RpZmllcih2YWx1ZSwgZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycy5yZXF1aXJlZCkge1xuICAgICAgcmV0dXJuICdEYXMgaXN0IGVpbiBQZmxpY2h0ZmVsZCc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgY2hlY2tWYWxpZGF0b3JzQ29udGFpblJlcXVpcmVkKHZhbGlkYXRvcnM6IFZhbGlkYXRvckZuIHwgVmFsaWRhdG9yRm5bXSkge1xuICAgIC8vIEZhbGw6IHJlcXVpcmVkID0gdHJ1ZSwgYWJlciBuZXVlIFZhbGlkYXRvcmVuIHdlcmRlbiBnZXNldHp0XG4gICAgaWYgKHRoaXMubHV4UmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgIC8vIFNpbmQgZXMgbWVocmVyZSBWYWxpZGF0b3JlbiwgYWJlciBrZWluIC5yZXF1aXJlZFRydWU/IERhbm4gd2lyZCBlciBlcmfDpG56dFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgJiYgdmFsaWRhdG9ycy5pbmRleE9mKFZhbGlkYXRvcnMucmVxdWlyZWRUcnVlKSA9PT0gLTEpIHtcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMucmVxdWlyZWRUcnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgJiYgdmFsaWRhdG9ycyAhPT0gVmFsaWRhdG9ycy5yZXF1aXJlZFRydWUpIHtcbiAgICAgICAgLy8gSXN0IGVzIG51ciBlaW4gZWluemVsbmVyIFZhbGlkYXRvciB1bmQgbmljaHQgLnJlcXVpcmVkVHJ1ZT8gRGFubiBBcnJheSBlcnN0ZWxsZW4gdW5kIGJlaWRlIGtvbWJpbmllcmVuXG4gICAgICAgIHZhbGlkYXRvcnMgPSBbdmFsaWRhdG9ycywgVmFsaWRhdG9ycy5yZXF1aXJlZFRydWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5sdXhSZXF1aXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpKSB7XG4gICAgICAgIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcigodmFsaWRhdG9yOiBWYWxpZGF0b3JGbikgPT4gdmFsaWRhdG9yICE9PSBWYWxpZGF0b3JzLnJlcXVpcmVkVHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvcnMgPT09IFZhbGlkYXRvcnMucmVxdWlyZWRUcnVlKSB7XG4gICAgICAgIHZhbGlkYXRvcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvcnM7XG4gIH1cblxuICBwcm90ZWN0ZWQgdHJpZ2dlck91dHB1dFBhdHRlcm5DaGVjaygpIHtcbiAgICB0aGlzLmNoZWNrT3V0cHV0UGF0dGVyblZpb2xhdGlvbih0aGlzLmx1eENoZWNrZWRDaGFuZ2Uub2JzZXJ2ZXJzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0cmlnZ2VySW5wdXRQYXR0ZXJuQ2hlY2soc2ltcGxlQ2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIHRoaXMuY2hlY2tJbnB1dFBhdHRlcm5WaW9sYXRpb24oc2ltcGxlQ2hhbmdlcy5sdXhDaGVja2VkKTtcbiAgfVxuXG4gIC8vIGVuZHJlZ2lvblxufVxuIl19