import * as tslib_1 from "tslib";
import { LuxFormComponentBase } from './lux-form-component-base.class';
import { EventEmitter, Input, Output } from '@angular/core';
/**
 * Basis-Klasse für FormComponents, die einen ähnlichen Grundaufbau für die Auswahl von
 * Optionen aus einem Array anbieten (Radio-Buttons und Selects z.B.).
 */
var LuxFormSelectableBase = /** @class */ (function (_super) {
    tslib_1.__extends(LuxFormSelectableBase, _super);
    function LuxFormSelectableBase(controlContainer, cdr, logger, config) {
        var _this = _super.call(this, controlContainer, cdr, logger, config) || this;
        _this._luxOptions = [];
        _this.luxSelectedChange = new EventEmitter();
        _this.luxOptionLabelProp = '';
        _this.luxCompareWith = function (o1, o2) { return o1 === o2; };
        /**
         * Kapselung von der übergebenen luxCompareWith-Funktion.
         * Fängt undefinierte Objekte ab und returned stattdessen false.
         * @param o1
         * @param o2
         */
        _this.compareObjects = function (o1, o2) {
            if ((!o1 && o2) || (o1 && !o2)) {
                return false;
            }
            else if (_this.luxCompareWith && !!o1 && !!o2) {
                return _this.luxCompareWith(o1, o2);
            }
            else {
                return o1 === o2;
            }
        };
        return _this;
    }
    Object.defineProperty(LuxFormSelectableBase.prototype, "luxSelected", {
        get: function () {
            return this.getValue();
        },
        set: function (selected) {
            this.setValue(selected);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LuxFormSelectableBase.prototype, "luxOptions", {
        get: function () {
            return this._luxOptions;
        },
        set: function (options) {
            this._luxOptions = options;
            this.checkSelectedAndUpdate(this.luxSelected);
        },
        enumerable: true,
        configurable: true
    });
    // region Overridden methods
    LuxFormSelectableBase.prototype.notifyFormValueChanged = function (formValue) {
        this.checkSelectedAndUpdate(formValue);
    };
    // endregion
    /**
     * Versucht, wenn Options und FormControl vorhanden sind, den selected-Wert mit den Options
     * zu vergleichen und dann auch wenn möglich als luxSelected-Wert zu sichern.
     * @param selected
     */
    LuxFormSelectableBase.prototype.checkSelectedAndUpdate = function (selected) {
        var _this = this;
        if (this.luxOptions && this.luxOptions.length > 0 && this.formControl) {
            if (this.luxPickValue && selected instanceof Object && !Array.isArray(selected)) {
                // Wenn der Wert zufälligerweise noch ein Objekt sein sollte, versuchen den Key auszulesen
                selected = this.luxPickValue(selected);
                // Da der Wert neu gesetzt wurde, diesen im nächsten Zyklus erst in die Werte schreiben
                setTimeout(function () {
                    _this.checkSelectedAndUpdate(selected);
                });
            }
            else {
                // Für den Fall, das der eingesetzte Wert sich doch noch vom FormControl-Value unterscheidet,
                // diesen ergänzen
                if (this.luxSelected !== selected) {
                    this.luxSelected = selected;
                }
                this.checkSelectedInOptions(selected);
                setTimeout(function () {
                    _this.luxSelectedChange.emit(selected);
                });
            }
        }
    };
    /**
     * Prüft ob der übergebene Wert in den luxOptions ist.
     * Kann auch ein Array als "selected" enthalten.
     * Wenn der Wert nicht gefunden werden konnte wird eine Fehlermeldung in der console ausgegeben.
     * @param selected
     */
    LuxFormSelectableBase.prototype.checkSelectedInOptions = function (selected) {
        var selectedAsArray = Array.isArray(selected) ? selected : [selected];
        if (selected && this.luxOptions && !this.allSelectedInOptions(selectedAsArray)) {
            // Selected nicht in Options = einen Fehler in die Console loggen
            this.logSelectedNotFound(selected);
        }
    };
    /**
     * Prüft ob die übergebenen Select-Objekte in den luxOptions enthalten sind.
     * @param selectedAsArray
     */
    LuxFormSelectableBase.prototype.allSelectedInOptions = function (selectedAsArray) {
        var _this = this;
        // Prüfen ob ein Unterarray von Elementen existiert.
        var optionsHasSubarray = this.luxOptions.length === 0
            ? false
            : // Dieses kann direkt in den Options stehen oder als value-Property
                Array.isArray(this.luxOptions[0]) ||
                    (!!this.luxPickValue && Array.isArray(this.luxPickValue(this.luxOptions[0])));
        var targetLength = optionsHasSubarray ? 1 : selectedAsArray.length;
        var length = this.luxOptions.filter(function (optionEntry) {
            if (optionsHasSubarray) {
                return _this.luxPickValue
                    ? _this.luxPickValue(optionEntry) === selectedAsArray
                    : _this.compareObjects(optionEntry, selectedAsArray);
            }
            else {
                return selectedAsArray.find(function (selectedEntry) {
                    return _this.luxPickValue
                        ? _this.luxPickValue(optionEntry) === selectedEntry
                        : _this.compareObjects(optionEntry, selectedEntry);
                });
            }
        }).length;
        return length === targetLength;
    };
    /**
     * Loggt die Fehlermeldung in die Console, wenn das neue Value-Objekt nicht in den Options gefunden
     * werden konnte.
     * @param selected
     */
    LuxFormSelectableBase.prototype.logSelectedNotFound = function (selected) {
        this.logger.error("\n### Das Objekt " + JSON.stringify(selected) + " ist nicht Teil der m\u00F6glichen Optionen.\n" +
            ("\n### Komponente: \"" + this + "\"\n") +
            "Pr\u00FCfen Sie evtl. die luxCompareWith-Funktion, um Properties anstelle ganzer Objekte zu vergleichen.");
    };
    LuxFormSelectableBase.prototype.triggerOutputPatternCheck = function () {
        this.checkOutputPatternViolation(this.luxSelectedChange.observers);
    };
    LuxFormSelectableBase.prototype.triggerInputPatternCheck = function (simpleChanges) {
        this.checkInputPatternViolation(simpleChanges.luxSelected);
    };
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], LuxFormSelectableBase.prototype, "luxSelectedChange", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormSelectableBase.prototype, "luxOptionLabelProp", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormSelectableBase.prototype, "luxTagId", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Function)
    ], LuxFormSelectableBase.prototype, "luxPickValue", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxFormSelectableBase.prototype, "luxReadonly", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], LuxFormSelectableBase.prototype, "luxCompareWith", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], LuxFormSelectableBase.prototype, "luxSelected", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array),
        tslib_1.__metadata("design:paramtypes", [Array])
    ], LuxFormSelectableBase.prototype, "luxOptions", null);
    return LuxFormSelectableBase;
}(LuxFormComponentBase));
export { LuxFormSelectableBase };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LWZvcm0tc2VsZWN0YWJsZS1iYXNlLmNsYXNzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGloay1nZmkvbHV4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJzcmMvYXBwL21vZHVsZXMvbHV4LWZvcm0vbHV4LWZvcm0tbW9kZWwvbHV4LWZvcm0tc2VsZWN0YWJsZS1iYXNlLmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN2RSxPQUFPLEVBQXFCLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUs5Rjs7O0dBR0c7QUFDSDtJQUFvRCxpREFBb0I7SUE0QnRFLCtCQUNFLGdCQUFrQyxFQUNsQyxHQUFzQixFQUN0QixNQUF5QixFQUN6QixNQUFrQztRQUpwQyxZQU1FLGtCQUFNLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLFNBQzdDO1FBbENPLGlCQUFXLEdBQVUsRUFBRSxDQUFDO1FBRXRCLHVCQUFpQixHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBRTNELHdCQUFrQixHQUFXLEVBQUUsQ0FBQztRQUloQyxvQkFBYyxHQUFHLFVBQUMsRUFBRSxFQUFFLEVBQUUsSUFBSyxPQUFBLEVBQUUsS0FBSyxFQUFFLEVBQVQsQ0FBUyxDQUFDO1FBMkhoRDs7Ozs7V0FLRztRQUNILG9CQUFjLEdBQUcsVUFBQyxFQUFFLEVBQUUsRUFBRTtZQUN0QixJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDOUIsT0FBTyxLQUFLLENBQUM7YUFDZDtpQkFBTSxJQUFJLEtBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFO2dCQUM5QyxPQUFPLEtBQUksQ0FBQyxjQUFj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QW5DO1FBQ0UsSUFBSSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRVMsd0RBQXdCLEdBQWxDLFVBQW1DLGFBQTRCO1FBQzdELElBQUksQ0FBQywwQkFBMEIsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQXZKUztRQUFULE1BQU0sRUFBRTswQ0FBb0IsWUFBWTtvRUFBMkI7SUFFM0Q7UUFBUixLQUFLLEVBQUU7O3FFQUFpQztJQUNoQztRQUFSLEtBQUssRUFBRTs7MkRBQWtCO0lBQ2pCO1FBQVIsS0FBSyxFQUFFOzsrREFBZ0M7SUFDL0I7UUFBUixLQUFLLEVBQUU7OzhEQUFzQjtJQUNyQjtRQUFSLEtBQUssRUFBRTs7aUVBQXdDO0lBTXZDO1FBQVIsS0FBSyxFQUFFOzs7NERBRVA7SUFNUTtRQUFSLEtBQUssRUFBRTs7OzJEQUdQO0lBaUlILDRCQUFDO0NBQUEsQUEzSkQsQ0FBb0Qsb0JBQW9CLEdBMkp2RTtTQTNKcUIscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTHV4Rm9ybUNvbXBvbmVudEJhc2UgfSBmcm9tICcuL2x1eC1mb3JtLWNvbXBvbmVudC1iYXNlLmNsYXNzJztcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xDb250YWluZXIgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBMdXhDb25zb2xlU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC11dGlsL2x1eC1jb25zb2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgTHV4Q29tcG9uZW50c0NvbmZpZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi9sdXgtY29tcG9uZW50cy1jb25maWcvbHV4LWNvbXBvbmVudHMtY29uZmlnLnNlcnZpY2UnO1xuXG4vKipcbiAqIEJhc2lzLUtsYXNzZSBmw7xyIEZvcm1Db21wb25lbnRzLCBkaWUgZWluZW4gw6RobmxpY2hlbiBHcnVuZGF1ZmJhdSBmw7xyIGRpZSBBdXN3YWhsIHZvblxuICogT3B0aW9uZW4gYXVzIGVpbmVtIEFycmF5IGFuYmlldGVuIChSYWRpby1CdXR0b25zIHVuZCBTZWxlY3RzIHouQi4pLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTHV4Rm9ybVNlbGVjdGFibGVCYXNlIGV4dGVuZHMgTHV4Rm9ybUNvbXBvbmVudEJhc2Uge1xuICBwcml2YXRlIF9sdXhPcHRpb25zOiBhbnlbXSA9IFtdO1xuXG4gIEBPdXRwdXQoKSBsdXhTZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgQElucHV0KCkgbHV4T3B0aW9uTGFiZWxQcm9wOiBzdHJpbmcgPSAnJztcbiAgQElucHV0KCkgbHV4VGFnSWQ6IHN0cmluZztcbiAgQElucHV0KCkgbHV4UGlja1ZhbHVlOiAoc2VsZWN0ZWQpID0+IHt9O1xuICBASW5wdXQoKSBsdXhSZWFkb25seTogYm9vbGVhbjtcbiAgQElucHV0KCkgbHV4Q29tcGFyZVdpdGggPSAobzEsIG8yKSA9PiBvMSA9PT0gbzI7XG5cbiAgZ2V0IGx1eFNlbGVjdGVkKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBsdXhTZWxlY3RlZChzZWxlY3RlZDogYW55KSB7XG4gICAgdGhpcy5zZXRWYWx1ZShzZWxlY3RlZCk7XG4gIH1cblxuICBnZXQgbHV4T3B0aW9ucygpOiBhbnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2x1eE9wdGlvbnM7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbHV4T3B0aW9ucyhvcHRpb25zOiBhbnlbXSkge1xuICAgIHRoaXMuX2x1eE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2hlY2tTZWxlY3RlZEFuZFVwZGF0ZSh0aGlzLmx1eFNlbGVjdGVkKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBjb250cm9sQ29udGFpbmVyOiBDb250cm9sQ29udGFpbmVyLFxuICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgbG9nZ2VyOiBMdXhDb25zb2xlU2VydmljZSxcbiAgICBjb25maWc6IEx1eENvbXBvbmVudHNDb25maWdTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKGNvbnRyb2xDb250YWluZXIsIGNkciwgbG9nZ2VyLCBjb25maWcpO1xuICB9XG5cbiAgLy8gcmVnaW9uIE92ZXJyaWRkZW4gbWV0aG9kc1xuXG4gIG5vdGlmeUZvcm1WYWx1ZUNoYW5nZWQoZm9ybVZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLmNoZWNrU2VsZWN0ZWRBbmRVcGRhdGUoZm9ybVZhbHVlKTtcbiAgfVxuXG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8qKlxuICAgKiBWZXJzdWNodCwgd2VubiBPcHRpb25zIHVuZCBGb3JtQ29udHJvbCB2b3JoYW5kZW4gc2luZCwgZGVuIHNlbGVjdGVkLVdlcnQgbWl0IGRlbiBPcHRpb25zXG4gICAqIHp1IHZlcmdsZWljaGVuIHVuZCBkYW5uIGF1Y2ggd2VubiBtw7ZnbGljaCBhbHMgbHV4U2VsZWN0ZWQtV2VydCB6dSBzaWNoZXJuLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICovXG4gIHByaXZhdGUgY2hlY2tTZWxlY3RlZEFuZFVwZGF0ZShzZWxlY3RlZDogYW55KSB7XG4gICAgaWYgKHRoaXMubHV4T3B0aW9ucyAmJiB0aGlzLmx1eE9wdGlvbnMubGVuZ3RoID4gMCAmJiB0aGlzLmZvcm1Db250cm9sKSB7XG4gICAgICBpZiAodGhpcy5sdXhQaWNrVmFsdWUgJiYgc2VsZWN0ZWQgaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkoc2VsZWN0ZWQpKSB7XG4gICAgICAgIC8vIFdlbm4gZGVyIFdlcnQgenVmw6RsbGlnZXJ3ZWlzZSBub2NoIGVpbiBPYmpla3Qgc2VpbiBzb2xsdGUsIHZlcnN1Y2hlbiBkZW4gS2V5IGF1c3p1bGVzZW5cbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLmx1eFBpY2tWYWx1ZShzZWxlY3RlZCk7XG5cbiAgICAgICAgLy8gRGEgZGVyIFdlcnQgbmV1IGdlc2V0enQgd3VyZGUsIGRpZXNlbiBpbSBuw6RjaHN0ZW4gWnlrbHVzIGVyc3QgaW4gZGllIFdlcnRlIHNjaHJlaWJlblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNoZWNrU2VsZWN0ZWRBbmRVcGRhdGUoc2VsZWN0ZWQpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEbDvHIgZGVuIEZhbGwsIGRhcyBkZXIgZWluZ2VzZXR6dGUgV2VydCBzaWNoIGRvY2ggbm9jaCB2b20gRm9ybUNvbnRyb2wtVmFsdWUgdW50ZXJzY2hlaWRldCxcbiAgICAgICAgLy8gZGllc2VuIGVyZ8OkbnplblxuICAgICAgICBpZiAodGhpcy5sdXhTZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLmx1eFNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1NlbGVjdGVkSW5PcHRpb25zKHNlbGVjdGVkKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5sdXhTZWxlY3RlZENoYW5nZS5lbWl0KHNlbGVjdGVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByw7xmdCBvYiBkZXIgw7xiZXJnZWJlbmUgV2VydCBpbiBkZW4gbHV4T3B0aW9ucyBpc3QuXG4gICAqIEthbm4gYXVjaCBlaW4gQXJyYXkgYWxzIFwic2VsZWN0ZWRcIiBlbnRoYWx0ZW4uXG4gICAqIFdlbm4gZGVyIFdlcnQgbmljaHQgZ2VmdW5kZW4gd2VyZGVuIGtvbm50ZSB3aXJkIGVpbmUgRmVobGVybWVsZHVuZyBpbiBkZXIgY29uc29sZSBhdXNnZWdlYmVuLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRcbiAgICovXG4gIHByaXZhdGUgY2hlY2tTZWxlY3RlZEluT3B0aW9ucyhzZWxlY3RlZDogYW55KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRBc0FycmF5ID0gQXJyYXkuaXNBcnJheShzZWxlY3RlZCkgPyBzZWxlY3RlZCA6IFtzZWxlY3RlZF07XG4gICAgaWYgKHNlbGVjdGVkICYmIHRoaXMubHV4T3B0aW9ucyAmJiAhdGhpcy5hbGxTZWxlY3RlZEluT3B0aW9ucyhzZWxlY3RlZEFzQXJyYXkpKSB7XG4gICAgICAvLyBTZWxlY3RlZCBuaWNodCBpbiBPcHRpb25zID0gZWluZW4gRmVobGVyIGluIGRpZSBDb25zb2xlIGxvZ2dlblxuICAgICAgdGhpcy5sb2dTZWxlY3RlZE5vdEZvdW5kKHNlbGVjdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHLDvGZ0IG9iIGRpZSDDvGJlcmdlYmVuZW4gU2VsZWN0LU9iamVrdGUgaW4gZGVuIGx1eE9wdGlvbnMgZW50aGFsdGVuIHNpbmQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZEFzQXJyYXlcbiAgICovXG4gIHByaXZhdGUgYWxsU2VsZWN0ZWRJbk9wdGlvbnMoc2VsZWN0ZWRBc0FycmF5OiBhbnlbXSk6IGJvb2xlYW4ge1xuICAgIC8vIFByw7xmZW4gb2IgZWluIFVudGVyYXJyYXkgdm9uIEVsZW1lbnRlbiBleGlzdGllcnQuXG4gICAgY29uc3Qgb3B0aW9uc0hhc1N1YmFycmF5ID1cbiAgICAgIHRoaXMubHV4T3B0aW9ucy5sZW5ndGggPT09IDBcbiAgICAgICAgPyBmYWxzZVxuICAgICAgICA6IC8vIERpZXNlcyBrYW5uIGRpcmVrdCBpbiBkZW4gT3B0aW9ucyBzdGVoZW4gb2RlciBhbHMgdmFsdWUtUHJvcGVydHlcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMubHV4T3B0aW9uc1swXSkgfHxcbiAgICAgICAgICAoISF0aGlzLmx1eFBpY2tWYWx1ZSAmJiBBcnJheS5pc0FycmF5KHRoaXMubHV4UGlja1ZhbHVlKHRoaXMubHV4T3B0aW9uc1swXSkpKTtcblxuICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IG9wdGlvbnNIYXNTdWJhcnJheSA/IDEgOiBzZWxlY3RlZEFzQXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubHV4T3B0aW9ucy5maWx0ZXIoKG9wdGlvbkVudHJ5OiBhbnkpID0+IHtcbiAgICAgIGlmIChvcHRpb25zSGFzU3ViYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubHV4UGlja1ZhbHVlXG4gICAgICAgICAgPyB0aGlzLmx1eFBpY2tWYWx1ZShvcHRpb25FbnRyeSkgPT09IHNlbGVjdGVkQXNBcnJheVxuICAgICAgICAgIDogdGhpcy5jb21wYXJlT2JqZWN0cyhvcHRpb25FbnRyeSwgc2VsZWN0ZWRBc0FycmF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZEFzQXJyYXkuZmluZCgoc2VsZWN0ZWRFbnRyeTogYW55IHwgYW55W10pID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sdXhQaWNrVmFsdWVcbiAgICAgICAgICAgID8gdGhpcy5sdXhQaWNrVmFsdWUob3B0aW9uRW50cnkpID09PSBzZWxlY3RlZEVudHJ5XG4gICAgICAgICAgICA6IHRoaXMuY29tcGFyZU9iamVjdHMob3B0aW9uRW50cnksIHNlbGVjdGVkRW50cnkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5sZW5ndGg7XG5cbiAgICByZXR1cm4gbGVuZ3RoID09PSB0YXJnZXRMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogTG9nZ3QgZGllIEZlaGxlcm1lbGR1bmcgaW4gZGllIENvbnNvbGUsIHdlbm4gZGFzIG5ldWUgVmFsdWUtT2JqZWt0IG5pY2h0IGluIGRlbiBPcHRpb25zIGdlZnVuZGVuXG4gICAqIHdlcmRlbiBrb25udGUuXG4gICAqIEBwYXJhbSBzZWxlY3RlZFxuICAgKi9cbiAgcHJpdmF0ZSBsb2dTZWxlY3RlZE5vdEZvdW5kKHNlbGVjdGVkOiBhbnkpIHtcbiAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgIGBcXG4jIyMgRGFzIE9iamVrdCAke0pTT04uc3RyaW5naWZ5KHNlbGVjdGVkKX0gaXN0IG5pY2h0IFRlaWwgZGVyIG3DtmdsaWNoZW4gT3B0aW9uZW4uXFxuYCArXG4gICAgICAgIGBcXG4jIyMgS29tcG9uZW50ZTogXCIke3RoaXN9XCJcXG5gICtcbiAgICAgICAgYFByw7xmZW4gU2llIGV2dGwuIGRpZSBsdXhDb21wYXJlV2l0aC1GdW5rdGlvbiwgdW0gUHJvcGVydGllcyBhbnN0ZWxsZSBnYW56ZXIgT2JqZWt0ZSB6dSB2ZXJnbGVpY2hlbi5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLYXBzZWx1bmcgdm9uIGRlciDDvGJlcmdlYmVuZW4gbHV4Q29tcGFyZVdpdGgtRnVua3Rpb24uXG4gICAqIEbDpG5ndCB1bmRlZmluaWVydGUgT2JqZWt0ZSBhYiB1bmQgcmV0dXJuZWQgc3RhdHRkZXNzZW4gZmFsc2UuXG4gICAqIEBwYXJhbSBvMVxuICAgKiBAcGFyYW0gbzJcbiAgICovXG4gIGNvbXBhcmVPYmplY3RzID0gKG8xLCBvMikgPT4ge1xuICAgIGlmICgoIW8xICYmIG8yKSB8fCAobzEgJiYgIW8yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sdXhDb21wYXJlV2l0aCAmJiAhIW8xICYmICEhbzIpIHtcbiAgICAgIHJldHVybiB0aGlzLmx1eENvbXBhcmVXaXRoKG8xLCBvMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvMSA9PT0gbzI7XG4gICAgfVxuICB9O1xuXG4gIHByb3RlY3RlZCB0cmlnZ2VyT3V0cHV0UGF0dGVybkNoZWNrKCkge1xuICAgIHRoaXMuY2hlY2tPdXRwdXRQYXR0ZXJuVmlvbGF0aW9uKHRoaXMubHV4U2VsZWN0ZWRDaGFuZ2Uub2JzZXJ2ZXJzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB0cmlnZ2VySW5wdXRQYXR0ZXJuQ2hlY2soc2ltcGxlQ2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIHRoaXMuY2hlY2tJbnB1dFBhdHRlcm5WaW9sYXRpb24oc2ltcGxlQ2hhbmdlcy5sdXhTZWxlY3RlZCk7XG4gIH1cbn1cbiJdfQ==