import * as tslib_1 from "tslib";
import { ContentChild, EventEmitter, HostBinding, Input, Output } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { LuxUtil } from '../../lux-util/lux-util';
import { distinctUntilChanged } from 'rxjs/operators';
import { LuxFormLabelComponent } from '../lux-form-control/lux-form-control-subcomponents/lux-form-label.component';
import { LuxFormHintComponent } from '../lux-form-control/lux-form-control-subcomponents/lux-form-hint.component';
var luxFormControlUID = 0;
var LuxFormComponentBase = /** @class */ (function () {
    function LuxFormComponentBase(controlContainer, cdr, logger, configService) {
        this.cdr = cdr;
        this.logger = logger;
        this.configService = configService;
        this.hasHadRequiredValidator = false;
        this.latestErrors = null;
        this.preventUnwantedValueChange = false;
        this.displayBindingDebugHint = false;
        this.errorMessage = undefined;
        this.uid = 'lux-form-control-' + luxFormControlUID++;
        this.cssReadonly = this._luxReadonly;
        this.luxFocusIn = new EventEmitter();
        this.luxFocusOut = new EventEmitter();
        this.luxDisabledChange = new EventEmitter();
        this.luxErrorCallback = function (value, errors) { return undefined; };
        this.controlContainer = controlContainer;
        // Wir fragen hier direkt ab, ob die Binding-Warnung ausgegeben werden sollen
        this.displayBindingDebugHint = this.configService.currentConfig.displayBindingDebugHint;
    }
    Object.defineProperty(LuxFormComponentBase.prototype, "luxDisabled", {
        get: function () {
            return this._luxDisabled;
        },
        set: function (disabled) {
            this._luxDisabled = disabled;
            this.cdr.detectChanges();
            if (this.formControl) {
                this.handleFormDisabledState();
            }
            this.luxDisabledChange.emit(this._luxDisabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LuxFormComponentBase.prototype, "luxReadonly", {
        get: function () {
            return this._luxReadonly;
        },
        set: function (readonly) {
            this._luxReadonly = readonly;
            this.cssReadonly = readonly;
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LuxFormComponentBase.prototype, "luxRequired", {
        get: function () {
            return this._luxRequired;
        },
        set: function (required) {
            if (this.isInForm()) {
                this.logger.error("Achtung: Bei Komponenten innerhalb von ReactiveForms den Required-Validator anstelle der " +
                    "Property \"luxRequired\" nutzen.\n" +
                    ("Betroffene Komponente: " + (this.luxControlBinding ? this.luxControlBinding : 'Kein Binding gefunden')));
            }
            else {
                this._luxRequired = required;
                this.updateValidators(this.luxControlValidators);
                // flag um ungewollte Wertänderungen von undefined zu null zu unterbinden
                this.preventUnwantedValueChange = true;
                this.cdr.detectChanges();
            }
        },
        enumerable: true,
        configurable: true
    });
    LuxFormComponentBase.prototype.ngOnInit = function () {
        this.initFormControl();
        this.initDisabledState();
        this.initFormValueSubscription();
        this.initFormStateSubscription();
        this.updateValidators(this.luxControlValidators);
        this.triggerOutputPatternCheck();
    };
    LuxFormComponentBase.prototype.ngOnChanges = function (simpleChanges) {
        if (simpleChanges.luxControlValidators && this.formControl) {
            this.updateValidators(this.luxControlValidators);
        }
        this.triggerInputPatternCheck(simpleChanges);
    };
    LuxFormComponentBase.prototype.ngDoCheck = function () {
        // Prüfen, ob es neue Fehlermeldungen gibt, wenn ja diese laden und speichern.
        if (this.latestErrors !== this.formControl.errors && this.formControl.touched) {
            this.latestErrors = this.formControl.errors;
            this.errorMessage = this.fetchErrorMessage();
        }
        // Prüfen, ob für das Reactive-Form-Control ein required-Validator ergänzt worden ist
        if (this.isInForm()) {
            var hasRequiredValidator = this.hasRequiredValidator(this.formControl);
            if (this.hasHadRequiredValidator !== hasRequiredValidator) {
                this._luxRequired = hasRequiredValidator;
                this.formControl.updateValueAndValidity();
                this.cdr.detectChanges();
            }
            this.hasHadRequiredValidator = hasRequiredValidator;
        }
    };
    LuxFormComponentBase.prototype.ngOnDestroy = function () {
        if (this._formValueChangeSubscr) {
            this._formValueChangeSubscr.unsubscribe();
        }
        if (this._formStatusChangeSubscr) {
            this._formStatusChangeSubscr.unsubscribe();
        }
        if (this._configSubscription) {
            this._configSubscription.unsubscribe();
        }
    };
    LuxFormComponentBase.prototype.isInForm = function () {
        return this.controlContainer != null && !LuxUtil.isEmpty(this.luxControlBinding);
    };
    /**
     * Versucht eine Fehlermeldung für diese Komponente auszulesen und gibt diese zurück.
     * Wenn das Element nicht den "touched"-Zustand besitzt, wird keine Fehlermeldung zurückgegeben.
     */
    LuxFormComponentBase.prototype.fetchErrorMessage = function () {
        // Control undefined/null oder unberührt? => Keinen Fehler ausgeben
        if (!this.formControl || !this.formControl.touched) {
            return undefined;
        }
        var _a = this.formControl, value = _a.value, errors = _a.errors;
        // Gibt der Callback bereits einen User-definierten Fehler wieder? => diesen zurückgeben
        var errorMsg = this.luxErrorMessage
            ? this.luxErrorMessage
            : this.luxErrorCallback
                ? this.luxErrorCallback(value, errors || {})
                : undefined;
        if (errors && errorMsg) {
            return errorMsg;
        }
        // Evtl. falls vorhanden Fehlerbehandlung der ableitenden Komponente aufrufen
        errorMsg = this.errorMessageModifier(value, errors || {});
        if (errorMsg) {
            return errorMsg;
        }
        // Last-but-not-least => versuchen einen Standardfehler auszulesen
        errorMsg = LuxUtil.getErrorMessage(this.formControl);
        return errorMsg;
    };
    /**
     * Mappt den Input-Wert aus disabled auf das FormControl.
     */
    LuxFormComponentBase.prototype.handleFormDisabledState = function () {
        if (this.luxDisabled && !this.formControl.disabled) {
            this.formControl.disable();
        }
        if (!this.luxDisabled && this.formControl.disabled) {
            this.formControl.enable();
        }
    };
    /**
     * Method-Stub der von ableitenden Klassen genutzt werden kann, um
     * weitergreifende Fehlermeldungen anzugeben.
     */
    LuxFormComponentBase.prototype.errorMessageModifier = function (value, errors) { };
    /**
     * Standard-Getter Funktion für den aktuellen Wert in dieser FormComponent.
     */
    LuxFormComponentBase.prototype.getValue = function () {
        return this.formControl ? this.formControl.value : this._initialValue;
    };
    /**
     * Standard-Setter Funktion für den aktuellen Wert in dieser FormComponent.
     */
    LuxFormComponentBase.prototype.setValue = function (value) {
        // Wenn noch kein FormControl vorhanden, den init-Wert merken und Fn beenden
        if (!this.formControl) {
            this._initialValue = value;
            return;
        }
        // Wenn der Wert bereits in dem FormControl bekannt ist, die Fn beenden
        if (value === this.formControl.value) {
            return;
        }
        // Den Wert im FormControl merken
        this.formControl.setValue(value);
    };
    /**
     * Wird nach der Aktualisierung des Wertes aufgerufen.
     * Hier kann z.B. valueChange.emit() ausgeführt werden.
     * @param formValue
     */
    LuxFormComponentBase.prototype.notifyFormValueChanged = function (formValue) { };
    /**
     * Wird nach der Aktualisierung des Status aufgerufen.
     * @param formStatus
     */
    LuxFormComponentBase.prototype.notifyFormStatusChanged = function (formStatus) { };
    /**
     * Prueft ob das uebergebene Control einen required-Validator besitzt.
     * @param abstractControl
     */
    LuxFormComponentBase.prototype.hasRequiredValidator = function (abstractControl) {
        if (abstractControl.validator) {
            var validator = abstractControl.validator({});
            if (validator && (validator.required || validator.requiredTrue)) {
                return true;
            }
        }
        return false;
    };
    /**
     * Initialisiert die FormGroup und das FormControl abhängig davon, ob es sich um eine ReactiveForm-Component
     * handelt.
     */
    LuxFormComponentBase.prototype.initFormControl = function () {
        if (this.isInForm()) {
            this.formGroup = this.controlContainer.control;
            this.formControl = this.formGroup.controls[this.luxControlBinding];
        }
        else {
            this.formGroup = new FormGroup({
                control: new FormControl()
            });
            this.formControl = this.formGroup.get(LuxFormComponentBase.DEFAULT_CTRL_NAME);
        }
    };
    /**
     * Initialisiert den Disabled-Zustand nach Erstellung dieser Component.
     */
    LuxFormComponentBase.prototype.initDisabledState = function () {
        if (this._luxDisabled) {
            this.handleFormDisabledState();
        }
        else if (this.luxDisabled === undefined) {
            this.luxDisabled = this.formControl.disabled;
        }
    };
    /**
     * Initialisiert das Handling von Wertaktualisierungen.
     * Setzt den (optional vorhanden) Initial-Wert und folgende Änderungen über das FormControl.
     */
    LuxFormComponentBase.prototype.initFormValueSubscription = function () {
        var _this = this;
        if (this._initialValue !== null && this._initialValue !== undefined) {
            this.setValue(this._initialValue);
        }
        // Aktualisierungen an dem FormControl-Value sollen auch via EventEmitter bekannt gemacht werden
        this._formValueChangeSubscr = this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(function (value) {
            if (_this.preventUnwantedValueChange && value === null) {
                _this.preventUnwantedValueChange = false;
                return;
            }
            _this.notifyFormValueChanged(value);
        });
    };
    /**
     * Initialisiert das Handling von Statusaktualisierungen.
     */
    LuxFormComponentBase.prototype.initFormStateSubscription = function () {
        var _this = this;
        this._formStatusChangeSubscr = this.formControl.statusChanges.subscribe(function (status) {
            if (status === 'DISABLED' && !_this.luxDisabled) {
                // Das FormControl hat den Zustand "DISABLED", aber die Property "luxDisabled"
                // hat noch den Wert "false". D.h. der FormControl-Status und die Property
                // sind nicht mehr synchron.
                _this.luxDisabled = true;
            }
            else if ((status === 'VALID' || status === 'INVALID') && _this.luxDisabled) {
                // Das FormControl hat den Zustand "VALID" oder "INVALID" und ist aktiv,
                // aber die Property "luxDisabled" hat noch den Wert "true".
                // D.h. der FormControl-Status und die Property sind nicht mehr synchron.
                _this.luxDisabled = false;
            }
            _this.notifyFormStatusChanged(status);
        });
    };
    /**
     * Diese Funktion prüft ob luxRequired auf true gesetzt wurde und die übergebenen validators bereits den
     * required-Validator besitzen.
     * Für den Fall das luxRequired auf false gesetzt worden ist, wird der Validator entfernt.
     *
     * Hinweis: LuxFormCheckableBase überschreibt diese Funktion, um statt required requiredTrue zu setzen.
     * @param validators
     */
    LuxFormComponentBase.prototype.checkValidatorsContainRequired = function (validators) {
        // Fall: required = true, aber neue Validatoren werden gesetzt
        if (this.luxRequired === true) {
            // Sind es mehrere Validatoren, aber kein .required? Dann wird er ergänzt
            if (Array.isArray(validators) && validators.indexOf(Validators.required) === -1) {
                validators.push(Validators.required);
            }
            else if (!Array.isArray(validators) && validators !== Validators.required) {
                // Ist es nur ein einzelner Validator und nicht .required? Dann Array erstellen und beide kombinieren
                validators = [validators, Validators.required];
            }
        }
        else if (this.luxRequired === false) {
            if (Array.isArray(validators)) {
                validators = validators.filter(function (validator) { return validator !== Validators.required; });
            }
            else if (validators === Validators.required) {
                validators = undefined;
            }
        }
        return validators;
    };
    /**
     * Versucht die Validatoren für diese Komponente zu setzen.
     * Ist nur erfolgreich, wenn es sich hierbei nicht um eine ReactiveForm-Komponente handelt.
     * @param validators
     */
    LuxFormComponentBase.prototype.updateValidators = function (validators) {
        var _this = this;
        if ((!Array.isArray(validators) && validators) || (Array.isArray(validators) && validators.length > 0)) {
            if (!this.isInForm()) {
                setTimeout(function () {
                    _this.luxControlValidators = _this.checkValidatorsContainRequired(validators);
                    _this.formControl.setValidators(_this.luxControlValidators);
                    _this.formControl.updateValueAndValidity();
                });
            }
            else {
                this.logger.error("Die Validatoren einer ReactiveForm-Komponente d\u00FCrfen nicht \u00FCber " + "das Template gesetzt werden.");
            }
        }
    };
    /**
     * Gibt an, ob diese Component Output-Property-Binding nutzt obwohl diese Component eigentlich ein Reactive FormControl ist.
     * @param observers
     */
    LuxFormComponentBase.prototype.checkOutputPatternViolation = function (observers) {
        if (this.displayBindingDebugHint && this.isInForm() && observers && observers.length > 0) {
            this.logPatternViolationWarning();
        }
    };
    /**
     * Gibt an, ob diese Component Input-Property-Binding nutzt obwohl diese Component eigentlich ein Reactive FormControl ist.
     * Wird von den ngOnChanges Methoden der Child-Klassen aufgerufen.
     * @param simpleChange
     */
    LuxFormComponentBase.prototype.checkInputPatternViolation = function (simpleChange) {
        if (this.displayBindingDebugHint && this.isInForm() && simpleChange && simpleChange.firstChange) {
            this.logPatternViolationWarning();
        }
    };
    /**
     * Gibt über den LuxConsoleService eine Warnung aus, dass hier gegen das ReactiveForm-Pattern mit Property-Binding
     * verstoßen worden ist.
     */
    LuxFormComponentBase.prototype.logPatternViolationWarning = function () {
        this.logger.warn("Achtung: Die Component \"" + this.luxControlBinding + "\" ist Teil einer ReactiveForm, nutzt aber trotzdem Property-Binding.\n\n" +
            "[Mit ReactiveForms]\n" +
            "F\u00FCr Components innerhalb von ReactiveForms k\u00F6nnen Wertaktualisierungen wie folgt abgefragt werden:\n\n" +
            "// Nicht vergessen unsubscribe in ngOnDestroy f\u00FCr die Subscription aufzurufen\n" +
            "this.subscription = this.myForm.get('myFormControl').valueChanges.subscribe((value: any) => console.log(value));\n\n" +
            "Das Setzen von Werten erfolgt zum Beispiel so:\n\n" +
            "this.myForm.get('myFormControl').setValue('myValue');\n\n" +
            "[Ohne ReactiveForms]\n" +
            "F\u00FCr Components au\u00DFerhalb von ReactiveForms k\u00F6nnen Wertaktualisierungen wie folgt abgefragt werden:\n\n" +
            "<lux-xyz-form-component (luxValueChange)=\"onValueChange($event)\"><lux-xyz-form-component>\n\n" +
            "Das Setzen von Werten erfolgt zum Beispiel so:\n\n" +
            "<lux-xyz-form-component [luxValue]=\"value\"><lux-xyz-form-component>\n\n" +
            "Alternativ kann \u00FCber Two-Way-Binding immer der aktuelle Wert in einer Property gehalten werden:\n\n" +
            "<lux-xyz-form-component [(luxValue)]=\"value\"><lux-xyz-form-component>");
        // Wir deaktivieren weitere Log-Ausgaben für diese Component, um doppelte Meldung zu vermeiden.
        // z.B. wenn Two-Way-Binding genutzt wird.
        this.displayBindingDebugHint = false;
    };
    LuxFormComponentBase.DEFAULT_CTRL_NAME = 'control';
    tslib_1.__decorate([
        ContentChild(LuxFormLabelComponent, { static: false }),
        tslib_1.__metadata("design:type", LuxFormLabelComponent)
    ], LuxFormComponentBase.prototype, "formLabelComponent", void 0);
    tslib_1.__decorate([
        ContentChild(LuxFormHintComponent, { static: false }),
        tslib_1.__metadata("design:type", LuxFormHintComponent)
    ], LuxFormComponentBase.prototype, "formHintComponent", void 0);
    tslib_1.__decorate([
        HostBinding('class.lux-form-control-readonly'),
        tslib_1.__metadata("design:type", Object)
    ], LuxFormComponentBase.prototype, "cssReadonly", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], LuxFormComponentBase.prototype, "luxFocusIn", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], LuxFormComponentBase.prototype, "luxFocusOut", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], LuxFormComponentBase.prototype, "luxDisabledChange", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormComponentBase.prototype, "luxHint", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormComponentBase.prototype, "luxLabel", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormComponentBase.prototype, "luxControlBinding", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], LuxFormComponentBase.prototype, "luxControlValidators", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxFormComponentBase.prototype, "luxErrorMessage", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Function)
    ], LuxFormComponentBase.prototype, "luxErrorCallback", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], LuxFormComponentBase.prototype, "luxDisabled", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], LuxFormComponentBase.prototype, "luxReadonly", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], LuxFormComponentBase.prototype, "luxRequired", null);
    return LuxFormComponentBase;
}());
export { LuxFormComponentBase };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LWZvcm0tY29tcG9uZW50LWJhc2UuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaWhrLWdmaS9sdXgtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbInNyYy9hcHAvbW9kdWxlcy9sdXgtZm9ybS9sdXgtZm9ybS1tb2RlbC9sdXgtZm9ybS1jb21wb25lbnQtYmFzZS5jbGFzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUVMLFlBQVksRUFFWixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFJTCxNQUFNLEVBR1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFxQyxXQUFXLEVBQUUsU0FBUyxFQUFlLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BILE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUdsRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0RCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSw2RUFBNkUsQ0FBQztBQUNwSCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw0RUFBNEUsQ0FBQztBQUdsSCxJQUFJLGlCQUFpQixHQUFXLENBQUMsQ0FBQztBQUVsQztJQXVGRSw4QkFDRSxnQkFBa0MsRUFDeEIsR0FBc0IsRUFDdEIsTUFBeUIsRUFDekIsYUFBeUM7UUFGekMsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDdEIsV0FBTSxHQUFOLE1BQU0sQ0FBbUI7UUFDekIsa0JBQWEsR0FBYixhQUFhLENBQTRCO1FBcEY3Qyw0QkFBdUIsR0FBWSxLQUFLLENBQUM7UUFFdkMsaUJBQVksR0FBUSxJQUFJLENBQUM7UUFDekIsK0JBQTBCLEdBQVksS0FBSyxDQUFDO1FBQzVDLDRCQUF1QixHQUFZLEtBQUssQ0FBQztRQU1uRCxpQkFBWSxHQUFXLFNBQVMsQ0FBQztRQU1qQyxRQUFHLEdBQVcsbUJBQW1CLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQztRQUtSLGdC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ckcseUVBQXVFLENBQzFFLENBQUM7UUFFRiwrRkFBK0Y7UUFDL0YsMENBQTBDO1FBQzFDLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxLQUFLLENBQUM7SUFDdkMsQ0FBQztJQTdheUIsc0NBQWlCLEdBQVcsU0FBUyxDQUFDO0lBd0JSO1FBQXZELFlBQVksQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQzswQ0FBcUIscUJBQXFCO29FQUFDO0lBQzNDO1FBQXRELFlBQVksQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQzswQ0FBb0Isb0JBQW9CO21FQUFDO0lBRS9DO1FBQS9DLFdBQVcsQ0FBQyxpQ0FBaUMsQ0FBQzs7NkRBQWlDO0lBRXRFO1FBQVQsTUFBTSxFQUFFOzBDQUFhLFlBQVk7NERBQWdDO0lBQ3hEO1FBQVQsTUFBTSxFQUFFOzBDQUFjLFlBQVk7NkRBQWdDO0lBQ3pEO1FBQVQsTUFBTSxFQUFFOzBDQUFvQixZQUFZO21FQUFnQztJQUVoRTtRQUFSLEtBQUssRUFBRTs7eURBQWlCO0lBQ2hCO1FBQVIsS0FBSyxFQUFFOzswREFBa0I7SUFFakI7UUFBUixLQUFLLEVBQUU7O21FQUEyQjtJQUMxQjtRQUFSLEtBQUssRUFBRTs7c0VBQW1EO0lBQ2xEO1FBQVIsS0FBSyxFQUFFOztpRUFBeUI7SUFDeEI7UUFBUixLQUFLLEVBQUU7MENBQW1CLFFBQVE7a0VBQWdDO0lBTTFEO1FBQVIsS0FBSyxFQUFFOzs7MkRBU1A7SUFNUTtRQUFSLEtBQUssRUFBRTs7OzJEQUlQO0lBTVE7UUFBUixLQUFLLEVBQUU7OzsyREFjUDtJQTBWSCwyQkFBQztDQUFBLEFBL2FELElBK2FDO1NBL2FxQixvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29udGVudENoaWxkLFxuICBEb0NoZWNrLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2UsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIENvbnRyb2xDb250YWluZXIsIEZvcm1Db250cm9sLCBGb3JtR3JvdXAsIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTHV4VXRpbCB9IGZyb20gJy4uLy4uL2x1eC11dGlsL2x1eC11dGlsJztcbmltcG9ydCB7IEx1eENvbnNvbGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vbHV4LXV0aWwvbHV4LWNvbnNvbGUuc2VydmljZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTHV4Rm9ybUxhYmVsQ29tcG9uZW50IH0gZnJvbSAnLi4vbHV4LWZvcm0tY29udHJvbC9sdXgtZm9ybS1jb250cm9sLXN1YmNvbXBvbmVudHMvbHV4LWZvcm0tbGFiZWwuY29tcG9uZW50JztcbmltcG9ydCB7IEx1eEZvcm1IaW50Q29tcG9uZW50IH0gZnJvbSAnLi4vbHV4LWZvcm0tY29udHJvbC9sdXgtZm9ybS1jb250cm9sLXN1YmNvbXBvbmVudHMvbHV4LWZvcm0taGludC5jb21wb25lbnQnO1xuaW1wb3J0IHsgTHV4Q29tcG9uZW50c0NvbmZpZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi9sdXgtY29tcG9uZW50cy1jb25maWcvbHV4LWNvbXBvbmVudHMtY29uZmlnLnNlcnZpY2UnO1xuXG5sZXQgbHV4Rm9ybUNvbnRyb2xVSUQ6IG51bWJlciA9IDA7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMdXhGb3JtQ29tcG9uZW50QmFzZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrLCBPbkRlc3Ryb3kge1xuICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfQ1RSTF9OQU1FOiBzdHJpbmcgPSAnY29udHJvbCc7XG5cbiAgcHJvdGVjdGVkIF9mb3JtVmFsdWVDaGFuZ2VTdWJzY3I6IFN1YnNjcmlwdGlvbjtcbiAgcHJvdGVjdGVkIF9mb3JtU3RhdHVzQ2hhbmdlU3Vic2NyOiBTdWJzY3JpcHRpb247XG4gIHByb3RlY3RlZCBfY29uZmlnU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSBoYXNIYWRSZXF1aXJlZFZhbGlkYXRvcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBsYXRlc3RFcnJvcnM6IGFueSA9IG51bGw7XG4gIHByb3RlY3RlZCBwcmV2ZW50VW53YW50ZWRWYWx1ZUNoYW5nZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgZGlzcGxheUJpbmRpbmdEZWJ1Z0hpbnQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvdGVjdGVkIF9pbml0aWFsVmFsdWU6IGFueTtcbiAgcHJvdGVjdGVkIF9sdXhEaXNhYmxlZDogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIF9sdXhSZWFkb25seTogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIF9sdXhSZXF1aXJlZDogYm9vbGVhbjtcblxuICBlcnJvck1lc3NhZ2U6IHN0cmluZyA9IHVuZGVmaW5lZDtcblxuICBjb250cm9sQ29udGFpbmVyOiBDb250cm9sQ29udGFpbmVyO1xuICBmb3JtR3JvdXA6IEZvcm1Hcm91cDtcbiAgZm9ybUNvbnRyb2w6IEFic3RyYWN0Q29udHJvbDtcblxuICB1aWQ6IHN0cmluZyA9ICdsdXgtZm9ybS1jb250cm9sLScgKyBsdXhGb3JtQ29udHJvbFVJRCsrO1xuXG4gIEBDb250ZW50Q2hpbGQoTHV4Rm9ybUxhYmVsQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSkgZm9ybUxhYmVsQ29tcG9uZW50OiBMdXhGb3JtTGFiZWxDb21wb25lbnQ7XG4gIEBDb250ZW50Q2hpbGQoTHV4Rm9ybUhpbnRDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSBmb3JtSGludENvbXBvbmVudDogTHV4Rm9ybUhpbnRDb21wb25lbnQ7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5sdXgtZm9ybS1jb250cm9sLXJlYWRvbmx5JykgY3NzUmVhZG9ubHkgPSB0aGlzLl9sdXhSZWFkb25seTtcblxuICBAT3V0cHV0KCkgbHV4Rm9jdXNJbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpIGx1eEZvY3VzT3V0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICBAT3V0cHV0KCkgbHV4RGlzYWJsZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgQElucHV0KCkgbHV4SGludDogc3RyaW5nO1xuICBASW5wdXQoKSBsdXhMYWJlbDogc3RyaW5nO1xuXG4gIEBJbnB1dCgpIGx1eENvbnRyb2xCaW5kaW5nOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGx1eENvbnRyb2xWYWxpZGF0b3JzOiBWYWxpZGF0b3JGbiB8IFZhbGlkYXRvckZuW107XG4gIEBJbnB1dCgpIGx1eEVycm9yTWVzc2FnZTogc3RyaW5nO1xuICBASW5wdXQoKSBsdXhFcnJvckNhbGxiYWNrOiBGdW5jdGlvbiA9ICh2YWx1ZSwgZXJyb3JzKSA9PiB1bmRlZmluZWQ7XG5cbiAgZ2V0IGx1eERpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9sdXhEaXNhYmxlZDtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBsdXhEaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuX2x1eERpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgaWYgKHRoaXMuZm9ybUNvbnRyb2wpIHtcbiAgICAgIHRoaXMuaGFuZGxlRm9ybURpc2FibGVkU3RhdGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmx1eERpc2FibGVkQ2hhbmdlLmVtaXQodGhpcy5fbHV4RGlzYWJsZWQpO1xuICB9XG5cbiAgZ2V0IGx1eFJlYWRvbmx5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9sdXhSZWFkb25seTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBsdXhSZWFkb25seShyZWFkb25seTogYm9vbGVhbikge1xuICAgIHRoaXMuX2x1eFJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gICAgdGhpcy5jc3NSZWFkb25seSA9IHJlYWRvbmx5O1xuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIGdldCBsdXhSZXF1aXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbHV4UmVxdWlyZWQ7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbHV4UmVxdWlyZWQocmVxdWlyZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5pc0luRm9ybSgpKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgICAgYEFjaHR1bmc6IEJlaSBLb21wb25lbnRlbiBpbm5lcmhhbGIgdm9uIFJlYWN0aXZlRm9ybXMgZGVuIFJlcXVpcmVkLVZhbGlkYXRvciBhbnN0ZWxsZSBkZXIgYCArXG4gICAgICAgICAgYFByb3BlcnR5IFwibHV4UmVxdWlyZWRcIiBudXR6ZW4uXFxuYCArXG4gICAgICAgICAgYEJldHJvZmZlbmUgS29tcG9uZW50ZTogJHt0aGlzLmx1eENvbnRyb2xCaW5kaW5nID8gdGhpcy5sdXhDb250cm9sQmluZGluZyA6ICdLZWluIEJpbmRpbmcgZ2VmdW5kZW4nfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2x1eFJlcXVpcmVkID0gcmVxdWlyZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVZhbGlkYXRvcnModGhpcy5sdXhDb250cm9sVmFsaWRhdG9ycyk7XG4gICAgICAvLyBmbGFnIHVtIHVuZ2V3b2xsdGUgV2VydMOkbmRlcnVuZ2VuIHZvbiB1bmRlZmluZWQgenUgbnVsbCB6dSB1bnRlcmJpbmRlblxuICAgICAgdGhpcy5wcmV2ZW50VW53YW50ZWRWYWx1ZUNoYW5nZSA9IHRydWU7XG4gICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKFxuICAgIGNvbnRyb2xDb250YWluZXI6IENvbnRyb2xDb250YWluZXIsXG4gICAgcHJvdGVjdGVkIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJvdGVjdGVkIGxvZ2dlcjogTHV4Q29uc29sZVNlcnZpY2UsXG4gICAgcHJvdGVjdGVkIGNvbmZpZ1NlcnZpY2U6IEx1eENvbXBvbmVudHNDb25maWdTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuY29udHJvbENvbnRhaW5lciA9IGNvbnRyb2xDb250YWluZXI7XG4gICAgLy8gV2lyIGZyYWdlbiBoaWVyIGRpcmVrdCBhYiwgb2IgZGllIEJpbmRpbmctV2FybnVuZyBhdXNnZWdlYmVuIHdlcmRlbiBzb2xsZW5cbiAgICB0aGlzLmRpc3BsYXlCaW5kaW5nRGVidWdIaW50ID0gdGhpcy5jb25maWdTZXJ2aWNlLmN1cnJlbnRDb25maWcuZGlzcGxheUJpbmRpbmdEZWJ1Z0hpbnQ7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmluaXRGb3JtQ29udHJvbCgpO1xuICAgIHRoaXMuaW5pdERpc2FibGVkU3RhdGUoKTtcbiAgICB0aGlzLmluaXRGb3JtVmFsdWVTdWJzY3JpcHRpb24oKTtcbiAgICB0aGlzLmluaXRGb3JtU3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVZhbGlkYXRvcnModGhpcy5sdXhDb250cm9sVmFsaWRhdG9ycyk7XG5cbiAgICB0aGlzLnRyaWdnZXJPdXRwdXRQYXR0ZXJuQ2hlY2soKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKHNpbXBsZUNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoc2ltcGxlQ2hhbmdlcy5sdXhDb250cm9sVmFsaWRhdG9ycyAmJiB0aGlzLmZvcm1Db250cm9sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZhbGlkYXRvcnModGhpcy5sdXhDb250cm9sVmFsaWRhdG9ycyk7XG4gICAgfVxuXG4gICAgdGhpcy50cmlnZ2VySW5wdXRQYXR0ZXJuQ2hlY2soc2ltcGxlQ2hhbmdlcyk7XG4gIH1cblxuICBuZ0RvQ2hlY2soKSB7XG4gICAgLy8gUHLDvGZlbiwgb2IgZXMgbmV1ZSBGZWhsZXJtZWxkdW5nZW4gZ2lidCwgd2VubiBqYSBkaWVzZSBsYWRlbiB1bmQgc3BlaWNoZXJuLlxuICAgIGlmICh0aGlzLmxhdGVzdEVycm9ycyAhPT0gdGhpcy5mb3JtQ29udHJvbC5lcnJvcnMgJiYgdGhpcy5mb3JtQ29udHJvbC50b3VjaGVkKSB7XG4gICAgICB0aGlzLmxhdGVzdEVycm9ycyA9IHRoaXMuZm9ybUNvbnRyb2wuZXJyb3JzO1xuICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSB0aGlzLmZldGNoRXJyb3JNZXNzYWdlKCk7XG4gICAgfVxuXG4gICAgLy8gUHLDvGZlbiwgb2IgZsO8ciBkYXMgUmVhY3RpdmUtRm9ybS1Db250cm9sIGVpbiByZXF1aXJlZC1WYWxpZGF0b3IgZXJnw6RuenQgd29yZGVuIGlzdFxuICAgIGlmICh0aGlzLmlzSW5Gb3JtKCkpIHtcbiAgICAgIGNvbnN0IGhhc1JlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5oYXNSZXF1aXJlZFZhbGlkYXRvcih0aGlzLmZvcm1Db250cm9sKTtcbiAgICAgIGlmICh0aGlzLmhhc0hhZFJlcXVpcmVkVmFsaWRhdG9yICE9PSBoYXNSZXF1aXJlZFZhbGlkYXRvcikge1xuICAgICAgICB0aGlzLl9sdXhSZXF1aXJlZCA9IGhhc1JlcXVpcmVkVmFsaWRhdG9yO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhhc0hhZFJlcXVpcmVkVmFsaWRhdG9yID0gaGFzUmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2Zvcm1WYWx1ZUNoYW5nZVN1YnNjcikge1xuICAgICAgdGhpcy5fZm9ybVZhbHVlQ2hhbmdlU3Vic2NyLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2Zvcm1TdGF0dXNDaGFuZ2VTdWJzY3IpIHtcbiAgICAgIHRoaXMuX2Zvcm1TdGF0dXNDaGFuZ2VTdWJzY3IudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9jb25maWdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBpc0luRm9ybSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ29udGFpbmVyICE9IG51bGwgJiYgIUx1eFV0aWwuaXNFbXB0eSh0aGlzLmx1eENvbnRyb2xCaW5kaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJzdWNodCBlaW5lIEZlaGxlcm1lbGR1bmcgZsO8ciBkaWVzZSBLb21wb25lbnRlIGF1c3p1bGVzZW4gdW5kIGdpYnQgZGllc2UgenVyw7xjay5cbiAgICogV2VubiBkYXMgRWxlbWVudCBuaWNodCBkZW4gXCJ0b3VjaGVkXCItWnVzdGFuZCBiZXNpdHp0LCB3aXJkIGtlaW5lIEZlaGxlcm1lbGR1bmcgenVyw7xja2dlZ2ViZW4uXG4gICAqL1xuICBwcm90ZWN0ZWQgZmV0Y2hFcnJvck1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAvLyBDb250cm9sIHVuZGVmaW5lZC9udWxsIG9kZXIgdW5iZXLDvGhydD8gPT4gS2VpbmVuIEZlaGxlciBhdXNnZWJlblxuICAgIGlmICghdGhpcy5mb3JtQ29udHJvbCB8fCAhdGhpcy5mb3JtQ29udHJvbC50b3VjaGVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7IHZhbHVlLCBlcnJvcnMgfSA9IHRoaXMuZm9ybUNvbnRyb2w7XG5cbiAgICAvLyBHaWJ0IGRlciBDYWxsYmFjayBiZXJlaXRzIGVpbmVuIFVzZXItZGVmaW5pZXJ0ZW4gRmVobGVyIHdpZWRlcj8gPT4gZGllc2VuIHp1csO8Y2tnZWJlblxuICAgIGxldCBlcnJvck1zZyA9IHRoaXMubHV4RXJyb3JNZXNzYWdlXG4gICAgICA/IHRoaXMubHV4RXJyb3JNZXNzYWdlXG4gICAgICA6IHRoaXMubHV4RXJyb3JDYWxsYmFja1xuICAgICAgPyB0aGlzLmx1eEVycm9yQ2FsbGJhY2sodmFsdWUsIGVycm9ycyB8fCB7fSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JNc2cpIHtcbiAgICAgIHJldHVybiBlcnJvck1zZztcbiAgICB9XG5cbiAgICAvLyBFdnRsLiBmYWxscyB2b3JoYW5kZW4gRmVobGVyYmVoYW5kbHVuZyBkZXIgYWJsZWl0ZW5kZW4gS29tcG9uZW50ZSBhdWZydWZlblxuICAgIGVycm9yTXNnID0gdGhpcy5lcnJvck1lc3NhZ2VNb2RpZmllcih2YWx1ZSwgZXJyb3JzIHx8IHt9KTtcbiAgICBpZiAoZXJyb3JNc2cpIHtcbiAgICAgIHJldHVybiBlcnJvck1zZztcbiAgICB9XG4gICAgLy8gTGFzdC1idXQtbm90LWxlYXN0ID0+IHZlcnN1Y2hlbiBlaW5lbiBTdGFuZGFyZGZlaGxlciBhdXN6dWxlc2VuXG4gICAgZXJyb3JNc2cgPSBMdXhVdGlsLmdldEVycm9yTWVzc2FnZSh0aGlzLmZvcm1Db250cm9sIGFzIEZvcm1Db250cm9sKTtcblxuICAgIHJldHVybiBlcnJvck1zZztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBwdCBkZW4gSW5wdXQtV2VydCBhdXMgZGlzYWJsZWQgYXVmIGRhcyBGb3JtQ29udHJvbC5cbiAgICovXG4gIHByb3RlY3RlZCBoYW5kbGVGb3JtRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5sdXhEaXNhYmxlZCAmJiAhdGhpcy5mb3JtQ29udHJvbC5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5mb3JtQ29udHJvbC5kaXNhYmxlKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmx1eERpc2FibGVkICYmIHRoaXMuZm9ybUNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZm9ybUNvbnRyb2wuZW5hYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZC1TdHViIGRlciB2b24gYWJsZWl0ZW5kZW4gS2xhc3NlbiBnZW51dHp0IHdlcmRlbiBrYW5uLCB1bVxuICAgKiB3ZWl0ZXJncmVpZmVuZGUgRmVobGVybWVsZHVuZ2VuIGFuenVnZWJlbi5cbiAgICovXG4gIHByb3RlY3RlZCBlcnJvck1lc3NhZ2VNb2RpZmllcih2YWx1ZSwgZXJyb3JzKSB7fVxuXG4gIC8qKlxuICAgKiBTdGFuZGFyZC1HZXR0ZXIgRnVua3Rpb24gZsO8ciBkZW4gYWt0dWVsbGVuIFdlcnQgaW4gZGllc2VyIEZvcm1Db21wb25lbnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VmFsdWUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5mb3JtQ29udHJvbCA/IHRoaXMuZm9ybUNvbnRyb2wudmFsdWUgOiB0aGlzLl9pbml0aWFsVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3RhbmRhcmQtU2V0dGVyIEZ1bmt0aW9uIGbDvHIgZGVuIGFrdHVlbGxlbiBXZXJ0IGluIGRpZXNlciBGb3JtQ29tcG9uZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIHNldFZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAvLyBXZW5uIG5vY2gga2VpbiBGb3JtQ29udHJvbCB2b3JoYW5kZW4sIGRlbiBpbml0LVdlcnQgbWVya2VuIHVuZCBGbiBiZWVuZGVuXG4gICAgaWYgKCF0aGlzLmZvcm1Db250cm9sKSB7XG4gICAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZW5uIGRlciBXZXJ0IGJlcmVpdHMgaW4gZGVtIEZvcm1Db250cm9sIGJla2FubnQgaXN0LCBkaWUgRm4gYmVlbmRlblxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZW4gV2VydCBpbSBGb3JtQ29udHJvbCBtZXJrZW5cbiAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaXJkIG5hY2ggZGVyIEFrdHVhbGlzaWVydW5nIGRlcyBXZXJ0ZXMgYXVmZ2VydWZlbi5cbiAgICogSGllciBrYW5uIHouQi4gdmFsdWVDaGFuZ2UuZW1pdCgpIGF1c2dlZsO8aHJ0IHdlcmRlbi5cbiAgICogQHBhcmFtIGZvcm1WYWx1ZVxuICAgKi9cbiAgcHJvdGVjdGVkIG5vdGlmeUZvcm1WYWx1ZUNoYW5nZWQoZm9ybVZhbHVlOiBhbnkpIHt9XG5cbiAgLyoqXG4gICAqIFdpcmQgbmFjaCBkZXIgQWt0dWFsaXNpZXJ1bmcgZGVzIFN0YXR1cyBhdWZnZXJ1ZmVuLlxuICAgKiBAcGFyYW0gZm9ybVN0YXR1c1xuICAgKi9cbiAgcHJvdGVjdGVkIG5vdGlmeUZvcm1TdGF0dXNDaGFuZ2VkKGZvcm1TdGF0dXM6IGFueSkge31cblxuICAvKipcbiAgICogUHJ1ZWZ0IG9iIGRhcyB1ZWJlcmdlYmVuZSBDb250cm9sIGVpbmVuIHJlcXVpcmVkLVZhbGlkYXRvciBiZXNpdHp0LlxuICAgKiBAcGFyYW0gYWJzdHJhY3RDb250cm9sXG4gICAqL1xuICBwcm90ZWN0ZWQgaGFzUmVxdWlyZWRWYWxpZGF0b3IoYWJzdHJhY3RDb250cm9sOiBBYnN0cmFjdENvbnRyb2wpIHtcbiAgICBpZiAoYWJzdHJhY3RDb250cm9sLnZhbGlkYXRvcikge1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gYWJzdHJhY3RDb250cm9sLnZhbGlkYXRvcih7fSBhcyBBYnN0cmFjdENvbnRyb2wpO1xuICAgICAgaWYgKHZhbGlkYXRvciAmJiAodmFsaWRhdG9yLnJlcXVpcmVkIHx8IHZhbGlkYXRvci5yZXF1aXJlZFRydWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGlzaWVydCBkaWUgRm9ybUdyb3VwIHVuZCBkYXMgRm9ybUNvbnRyb2wgYWJow6RuZ2lnIGRhdm9uLCBvYiBlcyBzaWNoIHVtIGVpbmUgUmVhY3RpdmVGb3JtLUNvbXBvbmVudFxuICAgKiBoYW5kZWx0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGluaXRGb3JtQ29udHJvbCgpIHtcbiAgICBpZiAodGhpcy5pc0luRm9ybSgpKSB7XG4gICAgICB0aGlzLmZvcm1Hcm91cCA9IDxGb3JtR3JvdXA+dGhpcy5jb250cm9sQ29udGFpbmVyLmNvbnRyb2w7XG4gICAgICB0aGlzLmZvcm1Db250cm9sID0gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5sdXhDb250cm9sQmluZGluZ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICAgIGNvbnRyb2w6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSB0aGlzLmZvcm1Hcm91cC5nZXQoTHV4Rm9ybUNvbXBvbmVudEJhc2UuREVGQVVMVF9DVFJMX05BTUUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNpZXJ0IGRlbiBEaXNhYmxlZC1adXN0YW5kIG5hY2ggRXJzdGVsbHVuZyBkaWVzZXIgQ29tcG9uZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIGluaXREaXNhYmxlZFN0YXRlKCkge1xuICAgIGlmICh0aGlzLl9sdXhEaXNhYmxlZCkge1xuICAgICAgdGhpcy5oYW5kbGVGb3JtRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sdXhEaXNhYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmx1eERpc2FibGVkID0gdGhpcy5mb3JtQ29udHJvbC5kaXNhYmxlZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGlzaWVydCBkYXMgSGFuZGxpbmcgdm9uIFdlcnRha3R1YWxpc2llcnVuZ2VuLlxuICAgKiBTZXR6dCBkZW4gKG9wdGlvbmFsIHZvcmhhbmRlbikgSW5pdGlhbC1XZXJ0IHVuZCBmb2xnZW5kZSDDhG5kZXJ1bmdlbiDDvGJlciBkYXMgRm9ybUNvbnRyb2wuXG4gICAqL1xuICBwcm90ZWN0ZWQgaW5pdEZvcm1WYWx1ZVN1YnNjcmlwdGlvbigpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlICE9PSBudWxsICYmIHRoaXMuX2luaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX2luaXRpYWxWYWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWt0dWFsaXNpZXJ1bmdlbiBhbiBkZW0gRm9ybUNvbnRyb2wtVmFsdWUgc29sbGVuIGF1Y2ggdmlhIEV2ZW50RW1pdHRlciBiZWthbm50IGdlbWFjaHQgd2VyZGVuXG4gICAgdGhpcy5fZm9ybVZhbHVlQ2hhbmdlU3Vic2NyID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUoKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgIGlmICh0aGlzLnByZXZlbnRVbndhbnRlZFZhbHVlQ2hhbmdlICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMucHJldmVudFVud2FudGVkVmFsdWVDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5ub3RpZnlGb3JtVmFsdWVDaGFuZ2VkKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNpZXJ0IGRhcyBIYW5kbGluZyB2b24gU3RhdHVzYWt0dWFsaXNpZXJ1bmdlbi5cbiAgICovXG4gIHByb3RlY3RlZCBpbml0Rm9ybVN0YXRlU3Vic2NyaXB0aW9uKCkge1xuICAgIHRoaXMuX2Zvcm1TdGF0dXNDaGFuZ2VTdWJzY3IgPSB0aGlzLmZvcm1Db250cm9sLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKChzdGF0dXM6IGFueSkgPT4ge1xuICAgICAgaWYgKHN0YXR1cyA9PT0gJ0RJU0FCTEVEJyAmJiAhdGhpcy5sdXhEaXNhYmxlZCkge1xuICAgICAgICAvLyBEYXMgRm9ybUNvbnRyb2wgaGF0IGRlbiBadXN0YW5kIFwiRElTQUJMRURcIiwgYWJlciBkaWUgUHJvcGVydHkgXCJsdXhEaXNhYmxlZFwiXG4gICAgICAgIC8vIGhhdCBub2NoIGRlbiBXZXJ0IFwiZmFsc2VcIi4gRC5oLiBkZXIgRm9ybUNvbnRyb2wtU3RhdHVzIHVuZCBkaWUgUHJvcGVydHlcbiAgICAgICAgLy8gc2luZCBuaWNodCBtZWhyIHN5bmNocm9uLlxuICAgICAgICB0aGlzLmx1eERpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoKHN0YXR1cyA9PT0gJ1ZBTElEJyB8fCBzdGF0dXMgPT09ICdJTlZBTElEJykgJiYgdGhpcy5sdXhEaXNhYmxlZCkge1xuICAgICAgICAvLyBEYXMgRm9ybUNvbnRyb2wgaGF0IGRlbiBadXN0YW5kIFwiVkFMSURcIiBvZGVyIFwiSU5WQUxJRFwiIHVuZCBpc3QgYWt0aXYsXG4gICAgICAgIC8vIGFiZXIgZGllIFByb3BlcnR5IFwibHV4RGlzYWJsZWRcIiBoYXQgbm9jaCBkZW4gV2VydCBcInRydWVcIi5cbiAgICAgICAgLy8gRC5oLiBkZXIgRm9ybUNvbnRyb2wtU3RhdHVzIHVuZCBkaWUgUHJvcGVydHkgc2luZCBuaWNodCBtZWhyIHN5bmNocm9uLlxuICAgICAgICB0aGlzLmx1eERpc2FibGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm90aWZ5Rm9ybVN0YXR1c0NoYW5nZWQoc3RhdHVzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaWVzZSBGdW5rdGlvbiBwcsO8ZnQgb2IgbHV4UmVxdWlyZWQgYXVmIHRydWUgZ2VzZXR6dCB3dXJkZSB1bmQgZGllIMO8YmVyZ2ViZW5lbiB2YWxpZGF0b3JzIGJlcmVpdHMgZGVuXG4gICAqIHJlcXVpcmVkLVZhbGlkYXRvciBiZXNpdHplbi5cbiAgICogRsO8ciBkZW4gRmFsbCBkYXMgbHV4UmVxdWlyZWQgYXVmIGZhbHNlIGdlc2V0enQgd29yZGVuIGlzdCwgd2lyZCBkZXIgVmFsaWRhdG9yIGVudGZlcm50LlxuICAgKlxuICAgKiBIaW53ZWlzOiBMdXhGb3JtQ2hlY2thYmxlQmFzZSDDvGJlcnNjaHJlaWJ0IGRpZXNlIEZ1bmt0aW9uLCB1bSBzdGF0dCByZXF1aXJlZCByZXF1aXJlZFRydWUgenUgc2V0emVuLlxuICAgKiBAcGFyYW0gdmFsaWRhdG9yc1xuICAgKi9cbiAgcHJvdGVjdGVkIGNoZWNrVmFsaWRhdG9yc0NvbnRhaW5SZXF1aXJlZCh2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbiB8IFZhbGlkYXRvckZuW10pIHtcbiAgICAvLyBGYWxsOiByZXF1aXJlZCA9IHRydWUsIGFiZXIgbmV1ZSBWYWxpZGF0b3JlbiB3ZXJkZW4gZ2VzZXR6dFxuICAgIGlmICh0aGlzLmx1eFJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICAvLyBTaW5kIGVzIG1laHJlcmUgVmFsaWRhdG9yZW4sIGFiZXIga2VpbiAucmVxdWlyZWQ/IERhbm4gd2lyZCBlciBlcmfDpG56dFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgJiYgdmFsaWRhdG9ycy5pbmRleE9mKFZhbGlkYXRvcnMucmVxdWlyZWQpID09PSAtMSkge1xuICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpICYmIHZhbGlkYXRvcnMgIT09IFZhbGlkYXRvcnMucmVxdWlyZWQpIHtcbiAgICAgICAgLy8gSXN0IGVzIG51ciBlaW4gZWluemVsbmVyIFZhbGlkYXRvciB1bmQgbmljaHQgLnJlcXVpcmVkPyBEYW5uIEFycmF5IGVyc3RlbGxlbiB1bmQgYmVpZGUga29tYmluaWVyZW5cbiAgICAgICAgdmFsaWRhdG9ycyA9IFt2YWxpZGF0b3JzLCBWYWxpZGF0b3JzLnJlcXVpcmVkXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMubHV4UmVxdWlyZWQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzKSkge1xuICAgICAgICB2YWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoKHZhbGlkYXRvcjogVmFsaWRhdG9yRm4pID0+IHZhbGlkYXRvciAhPT0gVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvcnMgPT09IFZhbGlkYXRvcnMucmVxdWlyZWQpIHtcbiAgICAgICAgdmFsaWRhdG9ycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJzdWNodCBkaWUgVmFsaWRhdG9yZW4gZsO8ciBkaWVzZSBLb21wb25lbnRlIHp1IHNldHplbi5cbiAgICogSXN0IG51ciBlcmZvbGdyZWljaCwgd2VubiBlcyBzaWNoIGhpZXJiZWkgbmljaHQgdW0gZWluZSBSZWFjdGl2ZUZvcm0tS29tcG9uZW50ZSBoYW5kZWx0LlxuICAgKiBAcGFyYW0gdmFsaWRhdG9yc1xuICAgKi9cbiAgcHJvdGVjdGVkIHVwZGF0ZVZhbGlkYXRvcnModmFsaWRhdG9yczogVmFsaWRhdG9yRm4gfCBWYWxpZGF0b3JGbltdKSB7XG4gICAgaWYgKCghQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzKSAmJiB2YWxpZGF0b3JzKSB8fCAoQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JzKSAmJiB2YWxpZGF0b3JzLmxlbmd0aCA+IDApKSB7XG4gICAgICBpZiAoIXRoaXMuaXNJbkZvcm0oKSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmx1eENvbnRyb2xWYWxpZGF0b3JzID0gdGhpcy5jaGVja1ZhbGlkYXRvcnNDb250YWluUmVxdWlyZWQodmFsaWRhdG9ycyk7XG4gICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKHRoaXMubHV4Q29udHJvbFZhbGlkYXRvcnMpO1xuICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFxuICAgICAgICAgIGBEaWUgVmFsaWRhdG9yZW4gZWluZXIgUmVhY3RpdmVGb3JtLUtvbXBvbmVudGUgZMO8cmZlbiBuaWNodCDDvGJlciBgICsgYGRhcyBUZW1wbGF0ZSBnZXNldHp0IHdlcmRlbi5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpYnQgYW4sIG9iIGRpZXNlIENvbXBvbmVudCBPdXRwdXQtUHJvcGVydHktQmluZGluZyBudXR6dCBvYndvaGwgZGllc2UgQ29tcG9uZW50IGVpZ2VudGxpY2ggZWluIFJlYWN0aXZlIEZvcm1Db250cm9sIGlzdC5cbiAgICogQHBhcmFtIG9ic2VydmVyc1xuICAgKi9cbiAgcHJvdGVjdGVkIGNoZWNrT3V0cHV0UGF0dGVyblZpb2xhdGlvbihvYnNlcnZlcnM6IGFueVtdIHwgbnVsbCkge1xuICAgIGlmICh0aGlzLmRpc3BsYXlCaW5kaW5nRGVidWdIaW50ICYmIHRoaXMuaXNJbkZvcm0oKSAmJiBvYnNlcnZlcnMgJiYgb2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMubG9nUGF0dGVyblZpb2xhdGlvbldhcm5pbmcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2lidCBhbiwgb2IgZGllc2UgQ29tcG9uZW50IElucHV0LVByb3BlcnR5LUJpbmRpbmcgbnV0enQgb2J3b2hsIGRpZXNlIENvbXBvbmVudCBlaWdlbnRsaWNoIGVpbiBSZWFjdGl2ZSBGb3JtQ29udHJvbCBpc3QuXG4gICAqIFdpcmQgdm9uIGRlbiBuZ09uQ2hhbmdlcyBNZXRob2RlbiBkZXIgQ2hpbGQtS2xhc3NlbiBhdWZnZXJ1ZmVuLlxuICAgKiBAcGFyYW0gc2ltcGxlQ2hhbmdlXG4gICAqL1xuICBwcm90ZWN0ZWQgY2hlY2tJbnB1dFBhdHRlcm5WaW9sYXRpb24oc2ltcGxlQ2hhbmdlOiBTaW1wbGVDaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5kaXNwbGF5QmluZGluZ0RlYnVnSGludCAmJiB0aGlzLmlzSW5Gb3JtKCkgJiYgc2ltcGxlQ2hhbmdlICYmIHNpbXBsZUNoYW5nZS5maXJzdENoYW5nZSkge1xuICAgICAgdGhpcy5sb2dQYXR0ZXJuVmlvbGF0aW9uV2FybmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaWUgQ2hpbGQtS2xhc3NlbiBpbXBsZW1lbnRpZXJlbiBkaWVzZSBGdW5rdGlvbiB1bSB6dSBwcsO8ZmVuLCBvYiBnZWdlbiBkYXMgT3V0cHV0LUJpbmRpbmcgZsO8ciBSZWFjdGl2ZUZvcm1zIHZlcnN0b8OfZW4gd2lyZC5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCB0cmlnZ2VyT3V0cHV0UGF0dGVybkNoZWNrKCk7XG5cbiAgLyoqXG4gICAqIERpZSBDaGlsZC1LbGFzc2VuIGltcGxlbWVudGllcmVuIGRpZXNlIEZ1bmt0aW9uIHVtIHp1IHByw7xmZW4sIG9iIGdlZ2VuIGRhcyBJbnB1dC1CaW5kaW5nIGbDvHIgUmVhY3RpdmVGb3JtcyB2ZXJzdG/Dn2VuIHdpcmQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdHJpZ2dlcklucHV0UGF0dGVybkNoZWNrKHNpbXBsZUNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpO1xuXG4gIC8qKlxuICAgKiBHaWJ0IMO8YmVyIGRlbiBMdXhDb25zb2xlU2VydmljZSBlaW5lIFdhcm51bmcgYXVzLCBkYXNzIGhpZXIgZ2VnZW4gZGFzIFJlYWN0aXZlRm9ybS1QYXR0ZXJuIG1pdCBQcm9wZXJ0eS1CaW5kaW5nXG4gICAqIHZlcnN0b8OfZW4gd29yZGVuIGlzdC5cbiAgICovXG4gIHByaXZhdGUgbG9nUGF0dGVyblZpb2xhdGlvbldhcm5pbmcoKSB7XG4gICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgIGBBY2h0dW5nOiBEaWUgQ29tcG9uZW50IFwiJHt0aGlzLmx1eENvbnRyb2xCaW5kaW5nfVwiIGlzdCBUZWlsIGVpbmVyIFJlYWN0aXZlRm9ybSwgbnV0enQgYWJlciB0cm90emRlbSBQcm9wZXJ0eS1CaW5kaW5nLlxcblxcbmAgK1xuICAgICAgICBgW01pdCBSZWFjdGl2ZUZvcm1zXVxcbmAgK1xuICAgICAgICBgRsO8ciBDb21wb25lbnRzIGlubmVyaGFsYiB2b24gUmVhY3RpdmVGb3JtcyBrw7ZubmVuIFdlcnRha3R1YWxpc2llcnVuZ2VuIHdpZSBmb2xndCBhYmdlZnJhZ3Qgd2VyZGVuOlxcblxcbmAgK1xuICAgICAgICBgLy8gTmljaHQgdmVyZ2Vzc2VuIHVuc3Vic2NyaWJlIGluIG5nT25EZXN0cm95IGbDvHIgZGllIFN1YnNjcmlwdGlvbiBhdWZ6dXJ1ZmVuXFxuYCArXG4gICAgICAgIGB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMubXlGb3JtLmdldCgnbXlGb3JtQ29udHJvbCcpLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoKHZhbHVlOiBhbnkpID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XFxuXFxuYCArXG4gICAgICAgIGBEYXMgU2V0emVuIHZvbiBXZXJ0ZW4gZXJmb2xndCB6dW0gQmVpc3BpZWwgc286XFxuXFxuYCArXG4gICAgICAgIGB0aGlzLm15Rm9ybS5nZXQoJ215Rm9ybUNvbnRyb2wnKS5zZXRWYWx1ZSgnbXlWYWx1ZScpO1xcblxcbmAgK1xuICAgICAgICBgW09obmUgUmVhY3RpdmVGb3Jtc11cXG5gICtcbiAgICAgICAgYEbDvHIgQ29tcG9uZW50cyBhdcOfZXJoYWxiIHZvbiBSZWFjdGl2ZUZvcm1zIGvDtm5uZW4gV2VydGFrdHVhbGlzaWVydW5nZW4gd2llIGZvbGd0IGFiZ2VmcmFndCB3ZXJkZW46XFxuXFxuYCArXG4gICAgICAgIGA8bHV4LXh5ei1mb3JtLWNvbXBvbmVudCAobHV4VmFsdWVDaGFuZ2UpPVwib25WYWx1ZUNoYW5nZSgkZXZlbnQpXCI+PGx1eC14eXotZm9ybS1jb21wb25lbnQ+XFxuXFxuYCArXG4gICAgICAgIGBEYXMgU2V0emVuIHZvbiBXZXJ0ZW4gZXJmb2xndCB6dW0gQmVpc3BpZWwgc286XFxuXFxuYCArXG4gICAgICAgIGA8bHV4LXh5ei1mb3JtLWNvbXBvbmVudCBbbHV4VmFsdWVdPVwidmFsdWVcIj48bHV4LXh5ei1mb3JtLWNvbXBvbmVudD5cXG5cXG5gICtcbiAgICAgICAgYEFsdGVybmF0aXYga2FubiDDvGJlciBUd28tV2F5LUJpbmRpbmcgaW1tZXIgZGVyIGFrdHVlbGxlIFdlcnQgaW4gZWluZXIgUHJvcGVydHkgZ2VoYWx0ZW4gd2VyZGVuOlxcblxcbmAgK1xuICAgICAgICBgPGx1eC14eXotZm9ybS1jb21wb25lbnQgWyhsdXhWYWx1ZSldPVwidmFsdWVcIj48bHV4LXh5ei1mb3JtLWNvbXBvbmVudD5gXG4gICAgKTtcblxuICAgIC8vIFdpciBkZWFrdGl2aWVyZW4gd2VpdGVyZSBMb2ctQXVzZ2FiZW4gZsO8ciBkaWVzZSBDb21wb25lbnQsIHVtIGRvcHBlbHRlIE1lbGR1bmcgenUgdmVybWVpZGVuLlxuICAgIC8vIHouQi4gd2VubiBUd28tV2F5LUJpbmRpbmcgZ2VudXR6dCB3aXJkLlxuICAgIHRoaXMuZGlzcGxheUJpbmRpbmdEZWJ1Z0hpbnQgPSBmYWxzZTtcbiAgfVxufVxuIl19