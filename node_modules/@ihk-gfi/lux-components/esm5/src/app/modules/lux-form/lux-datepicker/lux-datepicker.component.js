import * as tslib_1 from "tslib";
import { Platform } from '@angular/cdk/platform';
import { ChangeDetectorRef, Component, DoCheck, ElementRef, Input, OnChanges, OnDestroy, OnInit, Optional, SimpleChanges, ViewChild } from '@angular/core';
import { ControlContainer } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS, MatDatepicker } from '@angular/material';
import { MAT_DATE_LOCALE } from '@angular/material/core';
import { LuxComponentsConfigService } from '../../lux-components-config/lux-components-config.service';
import { LuxConsoleService } from '../../lux-util/lux-console.service';
import { LuxMediaQueryObserverService } from '../../lux-util/lux-media-query-observer.service';
import { LuxUtil } from '../../lux-util/lux-util';
import { LuxFormInputBaseClass } from '../lux-form-model/lux-form-input-base.class';
import { LuxDatepickerAdapter } from './lux-datepicker-adapter';
export var APP_DATE_FORMATS = {
    parse: {
        dateInput: { month: '2-digit', year: 'numeric', day: '2-digit' }
    },
    display: {
        dateInput: { month: '2-digit', year: 'numeric', day: '2-digit' },
        monthYearLabel: { year: 'numeric', month: 'long' },
        dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },
        monthYearA11yLabel: { year: 'numeric', month: 'long' }
    }
};
var LuxDatepickerComponent = /** @class */ (function (_super) {
    tslib_1.__extends(LuxDatepickerComponent, _super);
    function LuxDatepickerComponent(controlContainer, dateAdapter, mediaObserver, elementRef, cdr, logger, config) {
        var _this = _super.call(this, controlContainer, cdr, logger, config) || this;
        _this.dateAdapter = dateAdapter;
        _this.mediaObserver = mediaObserver;
        _this.elementRef = elementRef;
        _this.luxStartView = 'month';
        _this.luxTouchUi = false;
        _this.luxOpened = false;
        _this.luxStartDate = null;
        _this.luxShowToggle = true;
        _this.luxLocale = 'de-DE';
        _this.luxCustomFilter = undefined;
        _this.luxMaxDate = undefined;
        _this.luxMinDate = undefined;
        // den Standard-Wert für Autocomplete für Datepicker ausschalten
        _this.luxAutocomplete = 'off';
        _this.dateAdapter.setLocale(_this.luxLocale);
        return _this;
    }
    Object.defineProperty(LuxDatepickerComponent.prototype, "luxValue", {
        get: function () {
            return this.getValue();
        },
        set: function (value) {
            this.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    LuxDatepickerComponent.prototype.ngOnChanges = function (simpleChanges) {
        var _this = this;
        _super.prototype.ngOnChanges.call(this, simpleChanges);
        if (simpleChanges.luxOpened) {
            // Evtl. gibt es ohne das Timeout sonst Fehler, weil der matDatepicker noch nicht gesetzt ist
            setTimeout(function () {
                _this.triggerOpenClose();
            });
        }
        if (simpleChanges.luxLocale && simpleChanges.luxLocale.currentValue) {
            this.dateAdapter.setLocale(simpleChanges.luxLocale.currentValue);
        }
        if (simpleChanges.luxMaxDate && typeof simpleChanges.luxMaxDate.currentValue === 'string') {
            this.max = this.dateAdapter.parse(simpleChanges.luxMaxDate.currentValue, {});
        }
        if (simpleChanges.luxMinDate && typeof simpleChanges.luxMinDate.currentValue === 'string') {
            this.min = this.dateAdapter.parse(simpleChanges.luxMinDate.currentValue, {});
        }
        if (simpleChanges.luxStartDate && typeof simpleChanges.luxStartDate.currentValue === 'string') {
            this.start = this.dateAdapter.parse(simpleChanges.luxStartDate.currentValue, {});
        }
    };
    LuxDatepickerComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.originalTouchUi = this.luxTouchUi;
        this.mediaSubscription = this.mediaObserver.getMediaQueryChangedAsObservable().subscribe(function () {
            _this.checkMediaObserver();
        });
    };
    LuxDatepickerComponent.prototype.ngOnDestroy = function () {
        this.mediaSubscription.unsubscribe();
    };
    /**
     * Erzeugt für die Unter- bzw. Überschreitung
     * @param value
     * @param errors
     */
    LuxDatepickerComponent.prototype.errorMessageModifier = function (value, errors) {
        if (errors.matDatepickerMin) {
            return 'Das Datum unterschreitet den Minimalwert';
        }
        else if (errors.matDatepickerMax) {
            return 'Das Datum überschreitet den Maximalwert';
        }
        else if (errors.required) {
            if (this.datepickerInput && this.datepickerInput.nativeElement.value) {
                return 'Das Datum ist ungültig';
            }
            else {
                return 'Das Datum darf nicht leer sein';
            }
        }
        return undefined;
    };
    /**
     * Checkt ob eine mobile Media-Query vorliegt.
     * Wenn ja, wird automagisch die TouchUI aktiviert.
     * Wenn nein, wird der vom Aufrufer/originale luxTouchUI-Wert genutzt.
     */
    LuxDatepickerComponent.prototype.checkMediaObserver = function () {
        if (this.mediaObserver.isXS() || this.mediaObserver.isSM()) {
            this.luxTouchUi = true;
        }
        else {
            this.luxTouchUi = this.originalTouchUi;
        }
    };
    /**
     * Führt .open() bzw. .close() vom MatDatepicker aus, abhängig vom Wert für luxOpened.
     */
    LuxDatepickerComponent.prototype.triggerOpenClose = function () {
        if (this.luxOpened) {
            this.matDatepicker.open();
        }
        else {
            this.matDatepicker.close();
        }
    };
    /**
     * Aktualisiert den FormControl-Value und den Wert im Parent über valueChange mithilfe des übergebenen ISO-Strings.
     * @param isoValue
     */
    LuxDatepickerComponent.prototype.setISOValue = function (isoValue) {
        var _this = this;
        setTimeout(function () {
            _this.previousISO = isoValue;
            // valueChange-Emitter anstoßen
            _this.notifyFormValueChanged(isoValue);
            // "silently" den FormControl auf den (potentiell) geänderten Wert aktualisieren
            _this.formControl.setValue(isoValue, {
                emitEvent: false,
                emitModelToViewChange: false,
                emitViewToModelChange: false
            });
            // Per Hand dem Input-Element einen formatierten String übergeben
            if (!_this.datepickerInput.nativeElement.value && isoValue) {
                _this.datepickerInput.nativeElement.value = _this.dateAdapter.format(isoValue, APP_DATE_FORMATS.display.dateInput);
            }
        });
    };
    // region overridden methods
    LuxDatepickerComponent.prototype.setValue = function (value) {
        if (value !== this.luxValue) {
            if (!this.formControl) {
                this._initialValue = value;
                return;
            }
            this.formControl.setValue(value);
        }
    };
    LuxDatepickerComponent.prototype.initFormValueSubscription = function () {
        var _this = this;
        // Aktualisierungen an dem FormControl-Value sollen auch via EventEmitter bekannt gemacht werden
        this._formValueChangeSubscr = this.formControl.valueChanges.subscribe(function (value) {
            _this.updateDateValue(value);
        });
        if (this.formControl.value) {
            // Es kann vorkommen, dass der initiale Wert nicht im ISO-Format angegeben ist.
            // Dann muss der Wert noch umgewandelt werden.
            this.updateDateValue(this.formControl.value);
        }
        else if (this._initialValue !== null && this._initialValue !== undefined) {
            // Vorhandenen Initialwert setzen
            this.formControl.setValue(this._initialValue);
        }
    };
    LuxDatepickerComponent.prototype.updateDateValue = function (value) {
        if (!value) {
            this.setISOValue(value);
            return;
        }
        // Nachfolgend erstellen
        if (typeof value === 'string') {
            value = this.dateAdapter.parse(value, {});
        }
        var eventDate = value;
        var tempDate = new Date(0);
        tempDate.setUTCFullYear(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());
        tempDate.setUTCHours(0, 0, 0, 0);
        // Sicherheitshalber noch einmal prüfen, kann vorkommen das ein unsinniger Wert eingetragen wird
        // z.B. 'asdf', das führt zu InvalidDate's
        if (LuxUtil.isDate(tempDate) && this.previousISO !== tempDate.toISOString()) {
            this.setISOValue(tempDate.toISOString());
        }
    };
    LuxDatepickerComponent.ctorParameters = function () { return [
        { type: ControlContainer, decorators: [{ type: Optional }] },
        { type: DateAdapter },
        { type: LuxMediaQueryObserverService },
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: LuxConsoleService },
        { type: LuxComponentsConfigService }
    ]; };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxDatepickerComponent.prototype, "luxStartView", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxDatepickerComponent.prototype, "luxTouchUi", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxDatepickerComponent.prototype, "luxOpened", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxDatepickerComponent.prototype, "luxStartDate", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxDatepickerComponent.prototype, "luxShowToggle", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxDatepickerComponent.prototype, "luxLocale", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], LuxDatepickerComponent.prototype, "luxCustomFilter", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxDatepickerComponent.prototype, "luxMaxDate", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxDatepickerComponent.prototype, "luxMinDate", void 0);
    tslib_1.__decorate([
        ViewChild(MatDatepicker, { static: false }),
        tslib_1.__metadata("design:type", MatDatepicker)
    ], LuxDatepickerComponent.prototype, "matDatepicker", void 0);
    tslib_1.__decorate([
        ViewChild('datepickerInput', { read: ElementRef, static: false }),
        tslib_1.__metadata("design:type", ElementRef)
    ], LuxDatepickerComponent.prototype, "datepickerInput", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], LuxDatepickerComponent.prototype, "luxValue", null);
    LuxDatepickerComponent = tslib_1.__decorate([
        Component({
            selector: 'lux-datepicker',
            template: "<lux-form-control [luxFormComponent]=\"this\" [formGroup]=\"formGroup\" #datepickerFormControl *ngIf=\"formGroup\">\n  <div class=\"lux-input-row\" fxLayout=\"row\">\n    <input\n      fxFlex=\"auto\"\n      matInput\n      luxTagIdHandler\n      [luxTagId]=\"luxTagId\"\n      [matDatepicker]=\"datepicker\"\n      [min]=\"min\"\n      [max]=\"max\"\n      [matDatepickerFilter]=\"luxCustomFilter\"\n      [placeholder]=\"luxPlaceholder\"\n      [required]=\"luxRequired\"\n      [readonly]=\"luxReadonly\"\n      [formControl]=\"formControl\"\n      [autocomplete]=\"luxAutocomplete\"\n      (blur)=\"luxBlur.emit($event)\"\n      (focus)=\"luxFocus.emit($event)\"\n      (focusin)=\"luxFocusIn.emit($event)\"\n      (focusout)=\"luxFocusOut.emit($event)\"\n      [id]=\"uid\"\n      [luxAriaDescribedby]=\"uid + '-error ' + uid + '-hint'\"\n      #datepickerInput\n    />\n    <mat-datepicker-toggle\n      [disabled]=\"luxDisabled || luxReadonly\"\n      [for]=\"datepicker\"\n      *ngIf=\"luxShowToggle\"\n      fxFlex=\"auto\"\n      matSuffix\n    ></mat-datepicker-toggle>\n    <mat-datepicker\n      [startView]=\"luxStartView\"\n      [startAt]=\"start\"\n      [touchUi]=\"luxTouchUi\"\n      [disabled]=\"luxDisabled || luxReadonly\"\n      [panelClass]=\"'lux-datepicker-panel'\"\n      #datepicker\n    >\n    </mat-datepicker>\n  </div>\n</lux-form-control>\n",
            providers: [
                { provide: DateAdapter, useClass: LuxDatepickerAdapter, deps: [MAT_DATE_LOCALE, Platform] },
                { provide: MAT_DATE_FORMATS, useValue: APP_DATE_FORMATS }
            ]
        }),
        tslib_1.__param(0, Optional()),
        tslib_1.__metadata("design:paramtypes", [ControlContainer,
            DateAdapter,
            LuxMediaQueryObserverService,
            ElementRef,
            ChangeDetectorRef,
            LuxConsoleService,
            LuxComponentsConfigService])
    ], LuxDatepickerComponent);
    return LuxDatepickerComponent;
}(LuxFormInputBaseClass));
export { LuxDatepickerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LWRhdGVwaWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGloay1nZmkvbHV4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJzcmMvYXBwL21vZHVsZXMvbHV4LWZvcm0vbHV4LWRhdGVwaWNrZXIvbHV4LWRhdGVwaWNrZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDakQsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsT0FBTyxFQUNQLFVBQVUsRUFDVixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxNQUFNLEVBQ04sUUFBUSxFQUNSLGFBQWEsRUFDYixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFekQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sMkRBQTJELENBQUM7QUFDdkcsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDdkUsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0saURBQWlELENBQUM7QUFDL0YsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2xELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQ3BGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRWhFLE1BQU0sQ0FBQyxJQUFNLGdCQUFnQixHQUFHO0lBQzlCLEtBQUssRUFBRTtRQUNMLFNBQVMsRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFB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NUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBQzswQ0FBZ0IsYUFBYTtpRUFBTTtJQUNaO1FBQWxFLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDOzBDQUFrQixVQUFVO21FQUFDO0lBTXRGO1FBQVIsS0FBSyxFQUFFOzs7MERBRVA7SUE1QlUsc0JBQXNCO1FBUmxDLFNBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxnQkFBZ0I7WUFDMUIsMjJDQUE4QztZQUM5QyxTQUFTLEVBQUU7Z0JBQ1QsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxvQkFBb0IsRUFBRSxJQUFJLEVBQUUsQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDLEVBQUU7Z0JBQzNGLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRTthQUMxRDtTQUNGLENBQUM7UUFnQ0csbUJBQUEsUUFBUSxFQUFFLENBQUE7aURBQW1CLGdCQUFnQjtZQUN6QixXQUFXO1lBQ1QsNEJBQTRCO1lBQy9CLFVBQVU7WUFDekIsaUJBQWlCO1lBQ2QsaUJBQWlCO1lBQ2pCLDBCQUEwQjtPQXJDekIsc0JBQXNCLENBNE1sQztJQUFELDZCQUFDO0NBQUEsQUE1TUQsQ0FBNEMscUJBQXFCLEdBNE1oRTtTQTVNWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBEb0NoZWNrLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xDb250YWluZXIgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEYXRlQWRhcHRlciwgTUFUX0RBVEVfRk9STUFUUywgTWF0RGF0ZXBpY2tlciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7IE1BVF9EQVRFX0xPQ0FMRSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMdXhDb21wb25lbnRzQ29uZmlnU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC1jb21wb25lbnRzLWNvbmZpZy9sdXgtY29tcG9uZW50cy1jb25maWcuc2VydmljZSc7XG5pbXBvcnQgeyBMdXhDb25zb2xlU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC11dGlsL2x1eC1jb25zb2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgTHV4TWVkaWFRdWVyeU9ic2VydmVyU2VydmljZSB9IGZyb20gJy4uLy4uL2x1eC11dGlsL2x1eC1tZWRpYS1xdWVyeS1vYnNlcnZlci5zZXJ2aWNlJztcbmltcG9ydCB7IEx1eFV0aWwgfSBmcm9tICcuLi8uLi9sdXgtdXRpbC9sdXgtdXRpbCc7XG5pbXBvcnQgeyBMdXhGb3JtSW5wdXRCYXNlQ2xhc3MgfSBmcm9tICcuLi9sdXgtZm9ybS1tb2RlbC9sdXgtZm9ybS1pbnB1dC1iYXNlLmNsYXNzJztcbmltcG9ydCB7IEx1eERhdGVwaWNrZXJBZGFwdGVyIH0gZnJvbSAnLi9sdXgtZGF0ZXBpY2tlci1hZGFwdGVyJztcblxuZXhwb3J0IGNvbnN0IEFQUF9EQVRFX0ZPUk1BVFMgPSB7XG4gIHBhcnNlOiB7XG4gICAgZGF0ZUlucHV0OiB7IG1vbnRoOiAnMi1kaWdpdCcsIHllYXI6ICdudW1lcmljJywgZGF5OiAnMi1kaWdpdCcgfVxuICB9LFxuICBkaXNwbGF5OiB7XG4gICAgZGF0ZUlucHV0OiB7IG1vbnRoOiAnMi1kaWdpdCcsIHllYXI6ICdudW1lcmljJywgZGF5OiAnMi1kaWdpdCcgfSxcbiAgICBtb250aFllYXJMYWJlbDogeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfSxcbiAgICBkYXRlQTExeUxhYmVsOiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSxcbiAgICBtb250aFllYXJBMTF5TGFiZWw6IHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH1cbiAgfVxufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbHV4LWRhdGVwaWNrZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vbHV4LWRhdGVwaWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTHV4RGF0ZXBpY2tlckFkYXB0ZXIsIGRlcHM6IFtNQVRfREFURV9MT0NBTEUsIFBsYXRmb3JtXSB9LFxuICAgIHsgcHJvdmlkZTogTUFUX0RBVEVfRk9STUFUUywgdXNlVmFsdWU6IEFQUF9EQVRFX0ZPUk1BVFMgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIEx1eERhdGVwaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBMdXhGb3JtSW5wdXRCYXNlQ2xhc3MgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBEb0NoZWNrIHtcbiAgcHJpdmF0ZSBvcmlnaW5hbFRvdWNoVWk7XG4gIHByaXZhdGUgbWVkaWFTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBwcmV2aW91c0lTTzogc3RyaW5nO1xuXG4gIG1pbjogRGF0ZTtcbiAgbWF4OiBEYXRlO1xuICBzdGFydDogRGF0ZTtcblxuICBASW5wdXQoKSBsdXhTdGFydFZpZXc6ICdtb250aCcgfCAneWVhcicgPSAnbW9udGgnO1xuICBASW5wdXQoKSBsdXhUb3VjaFVpOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGx1eE9wZW5lZDogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoKSBsdXhTdGFydERhdGU6IHN0cmluZyA9IG51bGw7XG4gIEBJbnB1dCgpIGx1eFNob3dUb2dnbGU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoKSBsdXhMb2NhbGU6IHN0cmluZyA9ICdkZS1ERSc7XG4gIEBJbnB1dCgpIGx1eEN1c3RvbUZpbHRlcjogYW55ID0gdW5kZWZpbmVkO1xuICBASW5wdXQoKSBsdXhNYXhEYXRlOiBzdHJpbmcgPSB1bmRlZmluZWQ7XG4gIEBJbnB1dCgpIGx1eE1pbkRhdGU6IHN0cmluZyA9IHVuZGVmaW5lZDtcblxuICBAVmlld0NoaWxkKE1hdERhdGVwaWNrZXIsIHsgc3RhdGljOiBmYWxzZSB9KSBtYXREYXRlcGlja2VyOiBNYXREYXRlcGlja2VyPGFueT47XG4gIEBWaWV3Q2hpbGQoJ2RhdGVwaWNrZXJJbnB1dCcsIHsgcmVhZDogRWxlbWVudFJlZiwgc3RhdGljOiBmYWxzZSB9KSBkYXRlcGlja2VySW5wdXQ6IEVsZW1lbnRSZWY7XG5cbiAgZ2V0IGx1eFZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBsdXhWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBjb250cm9sQ29udGFpbmVyOiBDb250cm9sQ29udGFpbmVyLFxuICAgIHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPERhdGU+LFxuICAgIHByaXZhdGUgbWVkaWFPYnNlcnZlcjogTHV4TWVkaWFRdWVyeU9ic2VydmVyU2VydmljZSxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBsb2dnZXI6IEx1eENvbnNvbGVTZXJ2aWNlLFxuICAgIGNvbmZpZzogTHV4Q29tcG9uZW50c0NvbmZpZ1NlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoY29udHJvbENvbnRhaW5lciwgY2RyLCBsb2dnZXIsIGNvbmZpZyk7XG4gICAgLy8gZGVuIFN0YW5kYXJkLVdlcnQgZsO8ciBBdXRvY29tcGxldGUgZsO8ciBEYXRlcGlja2VyIGF1c3NjaGFsdGVuXG4gICAgdGhpcy5sdXhBdXRvY29tcGxldGUgPSAnb2ZmJztcbiAgICB0aGlzLmRhdGVBZGFwdGVyLnNldExvY2FsZSh0aGlzLmx1eExvY2FsZSk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhzaW1wbGVDaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgc3VwZXIubmdPbkNoYW5nZXMoc2ltcGxlQ2hhbmdlcyk7XG4gICAgaWYgKHNpbXBsZUNoYW5nZXMubHV4T3BlbmVkKSB7XG4gICAgICAvLyBFdnRsLiBnaWJ0IGVzIG9obmUgZGFzIFRpbWVvdXQgc29uc3QgRmVobGVyLCB3ZWlsIGRlciBtYXREYXRlcGlja2VyIG5vY2ggbmljaHQgZ2VzZXR6dCBpc3RcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXJPcGVuQ2xvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2ltcGxlQ2hhbmdlcy5sdXhMb2NhbGUgJiYgc2ltcGxlQ2hhbmdlcy5sdXhMb2NhbGUuY3VycmVudFZhbHVlKSB7XG4gICAgICB0aGlzLmRhdGVBZGFwdGVyLnNldExvY2FsZShzaW1wbGVDaGFuZ2VzLmx1eExvY2FsZS5jdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc2ltcGxlQ2hhbmdlcy5sdXhNYXhEYXRlICYmIHR5cGVvZiBzaW1wbGVDaGFuZ2VzLmx1eE1heERhdGUuY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5tYXggPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKHNpbXBsZUNoYW5nZXMubHV4TWF4RGF0ZS5jdXJyZW50VmFsdWUsIHt9KTtcbiAgICB9XG4gICAgaWYgKHNpbXBsZUNoYW5nZXMubHV4TWluRGF0ZSAmJiB0eXBlb2Ygc2ltcGxlQ2hhbmdlcy5sdXhNaW5EYXRlLmN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMubWluID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShzaW1wbGVDaGFuZ2VzLmx1eE1pbkRhdGUuY3VycmVudFZhbHVlLCB7fSk7XG4gICAgfVxuICAgIGlmIChzaW1wbGVDaGFuZ2VzLmx1eFN0YXJ0RGF0ZSAmJiB0eXBlb2Ygc2ltcGxlQ2hhbmdlcy5sdXhTdGFydERhdGUuY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2Uoc2ltcGxlQ2hhbmdlcy5sdXhTdGFydERhdGUuY3VycmVudFZhbHVlLCB7fSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB0aGlzLm9yaWdpbmFsVG91Y2hVaSA9IHRoaXMubHV4VG91Y2hVaTtcbiAgICB0aGlzLm1lZGlhU3Vic2NyaXB0aW9uID0gdGhpcy5tZWRpYU9ic2VydmVyLmdldE1lZGlhUXVlcnlDaGFuZ2VkQXNPYnNlcnZhYmxlKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tNZWRpYU9ic2VydmVyKCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLm1lZGlhU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogRXJ6ZXVndCBmw7xyIGRpZSBVbnRlci0gYnp3LiDDnGJlcnNjaHJlaXR1bmdcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEBwYXJhbSBlcnJvcnNcbiAgICovXG4gIGVycm9yTWVzc2FnZU1vZGlmaWVyKHZhbHVlLCBlcnJvcnMpIHtcbiAgICBpZiAoZXJyb3JzLm1hdERhdGVwaWNrZXJNaW4pIHtcbiAgICAgIHJldHVybiAnRGFzIERhdHVtIHVudGVyc2NocmVpdGV0IGRlbiBNaW5pbWFsd2VydCc7XG4gICAgfSBlbHNlIGlmIChlcnJvcnMubWF0RGF0ZXBpY2tlck1heCkge1xuICAgICAgcmV0dXJuICdEYXMgRGF0dW0gw7xiZXJzY2hyZWl0ZXQgZGVuIE1heGltYWx3ZXJ0JztcbiAgICB9IGVsc2UgaWYgKGVycm9ycy5yZXF1aXJlZCkge1xuICAgICAgaWYgKHRoaXMuZGF0ZXBpY2tlcklucHV0ICYmIHRoaXMuZGF0ZXBpY2tlcklucHV0Lm5hdGl2ZUVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdEYXMgRGF0dW0gaXN0IHVuZ8O8bHRpZyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0RhcyBEYXR1bSBkYXJmIG5pY2h0IGxlZXIgc2Vpbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Qgb2IgZWluZSBtb2JpbGUgTWVkaWEtUXVlcnkgdm9ybGllZ3QuXG4gICAqIFdlbm4gamEsIHdpcmQgYXV0b21hZ2lzY2ggZGllIFRvdWNoVUkgYWt0aXZpZXJ0LlxuICAgKiBXZW5uIG5laW4sIHdpcmQgZGVyIHZvbSBBdWZydWZlci9vcmlnaW5hbGUgbHV4VG91Y2hVSS1XZXJ0IGdlbnV0enQuXG4gICAqL1xuICBwcml2YXRlIGNoZWNrTWVkaWFPYnNlcnZlcigpIHtcbiAgICBpZiAodGhpcy5tZWRpYU9ic2VydmVyLmlzWFMoKSB8fCB0aGlzLm1lZGlhT2JzZXJ2ZXIuaXNTTSgpKSB7XG4gICAgICB0aGlzLmx1eFRvdWNoVWkgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmx1eFRvdWNoVWkgPSB0aGlzLm9yaWdpbmFsVG91Y2hVaTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRsO8aHJ0IC5vcGVuKCkgYnp3LiAuY2xvc2UoKSB2b20gTWF0RGF0ZXBpY2tlciBhdXMsIGFiaMOkbmdpZyB2b20gV2VydCBmw7xyIGx1eE9wZW5lZC5cbiAgICovXG4gIHByaXZhdGUgdHJpZ2dlck9wZW5DbG9zZSgpIHtcbiAgICBpZiAodGhpcy5sdXhPcGVuZWQpIHtcbiAgICAgIHRoaXMubWF0RGF0ZXBpY2tlci5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWF0RGF0ZXBpY2tlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBa3R1YWxpc2llcnQgZGVuIEZvcm1Db250cm9sLVZhbHVlIHVuZCBkZW4gV2VydCBpbSBQYXJlbnQgw7xiZXIgdmFsdWVDaGFuZ2UgbWl0aGlsZmUgZGVzIMO8YmVyZ2ViZW5lbiBJU08tU3RyaW5ncy5cbiAgICogQHBhcmFtIGlzb1ZhbHVlXG4gICAqL1xuICBwcml2YXRlIHNldElTT1ZhbHVlKGlzb1ZhbHVlOiBzdHJpbmcpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucHJldmlvdXNJU08gPSBpc29WYWx1ZTtcblxuICAgICAgLy8gdmFsdWVDaGFuZ2UtRW1pdHRlciBhbnN0b8OfZW5cbiAgICAgIHRoaXMubm90aWZ5Rm9ybVZhbHVlQ2hhbmdlZChpc29WYWx1ZSk7XG5cbiAgICAgIC8vIFwic2lsZW50bHlcIiBkZW4gRm9ybUNvbnRyb2wgYXVmIGRlbiAocG90ZW50aWVsbCkgZ2XDpG5kZXJ0ZW4gV2VydCBha3R1YWxpc2llcmVuXG4gICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKGlzb1ZhbHVlLCB7XG4gICAgICAgIGVtaXRFdmVudDogZmFsc2UsXG4gICAgICAgIGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UsXG4gICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQZXIgSGFuZCBkZW0gSW5wdXQtRWxlbWVudCBlaW5lbiBmb3JtYXRpZXJ0ZW4gU3RyaW5nIMO8YmVyZ2ViZW5cbiAgICAgIGlmICghdGhpcy5kYXRlcGlja2VySW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSAmJiBpc29WYWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXJJbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5kYXRlQWRhcHRlci5mb3JtYXQoXG4gICAgICAgICAgPGFueT5pc29WYWx1ZSxcbiAgICAgICAgICBBUFBfREFURV9GT1JNQVRTLmRpc3BsYXkuZGF0ZUlucHV0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyByZWdpb24gb3ZlcnJpZGRlbiBtZXRob2RzXG5cbiAgcHJvdGVjdGVkIHNldFZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMubHV4VmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5mb3JtQ29udHJvbCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGluaXRGb3JtVmFsdWVTdWJzY3JpcHRpb24oKSB7XG4gICAgLy8gQWt0dWFsaXNpZXJ1bmdlbiBhbiBkZW0gRm9ybUNvbnRyb2wtVmFsdWUgc29sbGVuIGF1Y2ggdmlhIEV2ZW50RW1pdHRlciBiZWthbm50IGdlbWFjaHQgd2VyZGVuXG4gICAgdGhpcy5fZm9ybVZhbHVlQ2hhbmdlU3Vic2NyID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZURhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5mb3JtQ29udHJvbC52YWx1ZSkge1xuICAgICAgLy8gRXMga2FubiB2b3Jrb21tZW4sIGRhc3MgZGVyIGluaXRpYWxlIFdlcnQgbmljaHQgaW0gSVNPLUZvcm1hdCBhbmdlZ2ViZW4gaXN0LlxuICAgICAgLy8gRGFubiBtdXNzIGRlciBXZXJ0IG5vY2ggdW1nZXdhbmRlbHQgd2VyZGVuLlxuICAgICAgdGhpcy51cGRhdGVEYXRlVmFsdWUodGhpcy5mb3JtQ29udHJvbC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgIT09IG51bGwgJiYgdGhpcy5faW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFZvcmhhbmRlbmVuIEluaXRpYWx3ZXJ0IHNldHplblxuICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLl9pbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlRGF0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB0aGlzLnNldElTT1ZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOYWNoZm9sZ2VuZCBlcnN0ZWxsZW5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKHZhbHVlLCB7fSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnREYXRlOiBEYXRlID0gdmFsdWU7XG4gICAgY29uc3QgdGVtcERhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgICB0ZW1wRGF0ZS5zZXRVVENGdWxsWWVhcihldmVudERhdGUuZ2V0RnVsbFllYXIoKSwgZXZlbnREYXRlLmdldE1vbnRoKCksIGV2ZW50RGF0ZS5nZXREYXRlKCkpO1xuICAgIHRlbXBEYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgLy8gU2ljaGVyaGVpdHNoYWxiZXIgbm9jaCBlaW5tYWwgcHLDvGZlbiwga2FubiB2b3Jrb21tZW4gZGFzIGVpbiB1bnNpbm5pZ2VyIFdlcnQgZWluZ2V0cmFnZW4gd2lyZFxuICAgIC8vIHouQi4gJ2FzZGYnLCBkYXMgZsO8aHJ0IHp1IEludmFsaWREYXRlJ3NcbiAgICBpZiAoTHV4VXRpbC5pc0RhdGUodGVtcERhdGUpICYmIHRoaXMucHJldmlvdXNJU08gIT09IHRlbXBEYXRlLnRvSVNPU3RyaW5nKCkpIHtcbiAgICAgIHRoaXMuc2V0SVNPVmFsdWUodGVtcERhdGUudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG59XG4iXX0=