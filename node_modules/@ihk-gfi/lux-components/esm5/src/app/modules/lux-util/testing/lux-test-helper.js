import * as tslib_1 from "tslib";
import { SPACE } from '@angular/cdk/keycodes';
import { CommonModule } from '@angular/common';
import { getTestBed, TestBed, tick } from '@angular/core/testing';
import { FlexLayoutModule } from '@angular/flex-layout';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatAutocompleteModule, MatBadgeModule, MatButtonModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatCommonModule, MatDatepickerModule, MatDividerModule, MatExpansionModule, MatFormFieldModule, MatIconModule, MatInputModule, MatNativeDateModule, MatOptionModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatSelectModule, MatSliderModule, MatSortModule, MatStepperModule, MatTableModule, MatTabsModule, MatTooltipModule } from '@angular/material';
import { BrowserModule, By } from '@angular/platform-browser';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { RouterModule } from '@angular/router';
import { LuxActionModule } from '../../lux-action/lux-action.module';
import { LuxDirectivesModule } from '../../lux-directives/lux-directives.module';
import { LuxFormModule } from '../../lux-form/lux-form.module';
import { LuxIconModule } from '../../lux-icon/lux-icon.module';
import { LuxLayoutModule } from '../../lux-layout/lux-layout.module';
import { LuxPipesModule } from '../../lux-pipes/lux-pipes.module';
import { LuxLookupModule } from '../../lux-lookup/lux-lookup.module';
import { RouterTestingModule } from '@angular/router/testing';
import { LuxComponentsConfigModule } from '../../lux-components-config/lux-components-config.module';
import { LuxErrorModule } from '../../lux-error/lux-error.module';
import { LuxCommonModule } from '../../lux-common/lux-common.module';
import { LuxPopupsModule } from '../../lux-popups/lux-popups.module';
var LuxTestHelper = /** @class */ (function () {
    function LuxTestHelper() {
    }
    /**
     * Wichtig: aus fakeAsync-Block heraus aufrufen, da hier tick() genutzt wird.
     */
    LuxTestHelper.setInputValue = function (input, value, fixture) {
        if (input) {
            input.value = value;
            input.dispatchEvent(LuxTestHelper.createFakeEvent('input'));
            LuxTestHelper.wait(fixture);
        }
        else {
            console.error('UNIT-TEST FEHLER: input ist nicht definiert.');
        }
    };
    /**
     * Wichtig: aus fakeAsync-Block heraus aufrufen, da hier tick() genutzt wird.
     * Wartet asynchrone Aufrufe ab und ruft die ChangeDetection auf
     * @param fixture
     * @param tickDuration
     */
    LuxTestHelper.wait = function (fixture, tickDuration) {
        fixture.detectChanges();
        tick(tickDuration);
        fixture.detectChanges();
    };
    /**
     * Wichtig: aus fakeAsync-Block heraus aufrufen, da hier tick() genutzt wird.
     * Sendet ein Klick-Event ab und wartet dann.
     * @param fixture
     * @param DebugElement
     */
    LuxTestHelper.click = function (fixture, debugElement) {
        debugElement.triggerEventHandler('click', null);
        LuxTestHelper.wait(fixture);
    };
    /**
     * Wichtig: aus fakeAsync-Block heraus aufrufen, da hier tick() genutzt wird.
     * Sendet ein Change-Event ab und wartet dann.
     * @param fixture
     * @param DebugElement
     */
    LuxTestHelper.radioButtonChange = function (fixture, radioButton) {
        radioButton.nativeElement.dispatchEvent(LuxTestHelper.createFakeEvent('change'));
        LuxTestHelper.wait(fixture);
    };
    /**
     * Erstellt eine ComponentFixture fuer die mitgegebene Komponente, optional ist es moeglich
     * weitere Provider und Declarations einzutragen. Diese werden dann im Testmodul eingetragen.
     * @param component
     * @param providers
     * @param declarations
     * @deprecated Stattdessen configureTestModule in Kombination mit configureTestSuite verwenden --> erheblich performanter
     */
    LuxTestHelper.createComponent = function (component, providers, declarations) {
        if (providers === void 0) { providers = []; }
        if (declarations === void 0) { declarations = []; }
        TestBed.configureTestingModule({
            imports: tslib_1.__spread(LuxTestHelper.COMMON_ANGULAR_MODULES, LuxTestHelper.MATERIAL_MODULES, LuxTestHelper.LUX_MODULES),
            declarations: tslib_1.__spread(declarations, [component]),
            providers: tslib_1.__spread(providers)
        });
        TestBed.compileComponents();
        return TestBed.createComponent(component);
    };
    /** Utility to dispatch any event on a Node. */
    LuxTestHelper.dispatchEvent = function (node, event) {
        node.dispatchEvent(event);
        return event;
    };
    /** Shorthand to dispatch a fake event on a specified node. */
    LuxTestHelper.dispatchFakeEvent = function (node, type, canBubble) {
        return LuxTestHelper.dispatchEvent(node, LuxTestHelper.createFakeEvent(type, canBubble));
    };
    /** Shorthand to dispatch a keyboard event with a specified key code. */
    LuxTestHelper.dispatchKeyboardEvent = function (node, type, keyCode, target) {
        return LuxTestHelper.dispatchEvent(node, LuxTestHelper.createKeyboardEvent(type, keyCode, target));
    };
    /** Focuses an input and sets its value. Dispatches an fake input event afterwards. */
    LuxTestHelper.typeInElement = function (element, value, noInputEvent) {
        element.focus();
        element.value = value;
        if (!noInputEvent) {
            LuxTestHelper.dispatchFakeEvent(element, 'input');
        }
    };
    /** Steuerung und triggern von Overlays implementieren **/
    /**
     * Inserts data into an input field, that has to update asynchrounos before calling a callback-function
     * Allows to use RxJs Interval-Timers within the Target-Components.
     */
    LuxTestHelper.typeInElementAsynch = function (text, fixture, element, callback) {
        fixture.whenStable().then(function () {
            LuxTestHelper.typeInElement(element, text);
            fixture.detectChanges();
            fixture.whenStable().then(function () {
                LuxTestHelper.dispatchKeyboardEvent(element, 'keydown', SPACE);
                fixture.detectChanges();
                fixture.whenStable().then(function () {
                    callback();
                });
            });
        });
    };
    /** Dispatches a keydown event from an element. */
    LuxTestHelper.createKeyboardEvent = function (type, keyCode, target, key) {
        var event = document.createEvent('KeyboardEvent');
        // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.
        var initEventFn = (event.initKeyEvent || event.initKeyboardEvent).bind(event);
        var originalPreventDefault = event.preventDefault;
        initEventFn(type, true, true, window, 0, 0, 0, 0, 0, keyCode);
        // Webkit Browsers don't set the keyCode when calling the init function.
        // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735
        Object.defineProperties(event, {
            keyCode: { get: function () { return keyCode; } },
            key: { get: function () { return key; } },
            target: { get: function () { return target; } }
        });
        // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.
        event.preventDefault = function () {
            Object.defineProperty(event, 'defaultPrevented', { get: function () { return true; } });
            return originalPreventDefault.apply(this, arguments);
        };
        return event;
    };
    /** Creates a fake event object with any desired event type. */
    LuxTestHelper.createFakeEvent = function (type, canBubble, cancelable) {
        if (canBubble === void 0) { canBubble = false; }
        if (cancelable === void 0) { cancelable = true; }
        var event;
        if (typeof Event === 'function') {
            event = new Event(type);
        }
        else {
            event = document.createEvent('Event');
            event.initEvent(type, canBubble, cancelable);
        }
        return event;
    };
    /**
     * Selektiert ein Element anhand der Query von dem Fixture
     */
    LuxTestHelper.selectOneFromFixture = function (fixture, query) {
        return fixture.debugElement.query(By.css(query));
    };
    /**
     * Selektiert ein Array von Elementen anhand der Query von dem Fixture
     */
    LuxTestHelper.selectAllFromFixture = function (fixture, query) {
        return fixture.debugElement.queryAll(By.css(query));
    };
    /**
     * Entfernt nicht-ASCII-Chars aus dem String (Beim IE wichtig, dieser fügt gerne versteckte Steuerzeichen
     * in Input-Feldern an die Strings).
     * @param dateString
     */
    LuxTestHelper.stringWithoutASCIIChars = function (dateString) {
        var exp = new RegExp('[^A-Za-z 0-9 \\.,\\?""!@#\\$%\\^&\\*\\(\\)-_=\\+;:<>\\/\\\\\\|\\}\\{\\[\\]`~]*', 'g');
        return dateString.replace(exp, '');
    };
    /**
     *  Deaktiviert den Reset des Testmoduls am Ende eines Testdurchlaufs.
     *  Verbessert die Performance der Karma-Tests erheblich.
     *  Am Ende der Testsuite wird diese Funktion wieder aktiviert.
     *
     *  Funktion dafür einfach am Anfang einer Testsuite (erstes describe) aufrufen und in einem beforeAll das Testmodul
     *  erzeugen. Dieses wird nun nicht mehr nach jedem Test neu erzeugt.
     */
    LuxTestHelper.configureTestSuite = function () {
        var testBedApi = getTestBed();
        var originReset = TestBed.resetTestingModule;
        beforeAll(function () {
            TestBed.resetTestingModule();
            TestBed.resetTestingModule = function () { return TestBed; };
        });
        afterEach(function () {
            testBedApi._activeFixtures.forEach(function (fixture) { return fixture.destroy(); });
            testBedApi._instantiated = false;
        });
        afterAll(function () {
            TestBed.resetTestingModule = originReset;
            TestBed.resetTestingModule();
        });
    };
    /**
     * Konfiguriert das TestModul für eine Testsuite, kann dabei Provider und Komponenten (Deklarationen) entgegennehmen.
     * @param providers
     * @param declarations
     * @param imports
     */
    LuxTestHelper.configureTestModule = function (providers, declarations, imports) {
        if (providers === void 0) { providers = []; }
        if (declarations === void 0) { declarations = []; }
        if (imports === void 0) { imports = []; }
        TestBed.configureTestingModule({
            imports: tslib_1.__spread(LuxTestHelper.COMMON_ANGULAR_MODULES, LuxTestHelper.MATERIAL_MODULES, LuxTestHelper.LUX_MODULES, imports),
            declarations: tslib_1.__spread(declarations),
            providers: tslib_1.__spread(providers)
        });
        TestBed.compileComponents();
    };
    /**
     * Erstellt ein leeres File-Objekt mit Namen und Typ via Blob-Constructor (um Edge/IE-Fehler zu vermeiden).
     * @param name
     * @param type
     */
    LuxTestHelper.createFileBrowserSafe = function (name, type) {
        var file = new Blob([''], { type: type });
        file['name'] = name;
        return file;
    };
    LuxTestHelper.COMMON_ANGULAR_MODULES = [
        NoopAnimationsModule,
        CommonModule,
        RouterModule,
        FormsModule,
        ReactiveFormsModule,
        FlexLayoutModule,
        BrowserModule,
        RouterTestingModule
    ];
    LuxTestHelper.MATERIAL_MODULES = [
        MatButtonModule,
        MatCardModule,
        MatIconModule,
        MatFormFieldModule,
        MatTabsModule,
        MatTooltipModule,
        MatChipsModule,
        MatProgressSpinnerModule,
        MatProgressBarModule,
        MatExpansionModule,
        MatStepperModule,
        MatTableModule,
        MatPaginatorModule,
        MatSortModule,
        MatDividerModule,
        MatSelectModule,
        MatInputModule,
        MatCheckboxModule,
        MatRadioModule,
        MatDatepickerModule,
        MatNativeDateModule,
        MatAutocompleteModule,
        MatSliderModule,
        MatOptionModule,
        MatCommonModule,
        MatBadgeModule
    ];
    LuxTestHelper.LUX_MODULES = [
        LuxFormModule,
        LuxLayoutModule,
        LuxActionModule,
        LuxDirectivesModule,
        LuxPipesModule,
        LuxIconModule,
        LuxLookupModule,
        LuxErrorModule,
        LuxCommonModule,
        LuxPopupsModule,
        LuxComponentsConfigModule.forRoot({
            generateLuxTagIds: false,
            displayLuxConsoleLogs: true,
            labelConfiguration: {
                allUppercase: true,
                notAppliedTo: []
            },
            cardExpansionAnimationActive: true
        })
    ];
    return LuxTestHelper;
}());
export { LuxTestHelper };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LXRlc3QtaGVscGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGloay1nZmkvbHV4LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJzcmMvYXBwL21vZHVsZXMvbHV4LXV0aWwvdGVzdGluZy9sdXgtdGVzdC1oZWxwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFL0MsT0FBTyxFQUFvQixVQUFVLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxXQUFXLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRSxPQUFPLEVBQ0wscUJBQXFCLEVBQ3JCLGNBQWMsRUFDZCxlQUFlLEVBQ2YsYUFBYSxFQUNiLGlCQUFpQixFQUNqQixjQUFjLEVBQ2QsZUFBZSxFQUNmLG1CQUFtQixFQUNuQixnQkFBZ0IsRUFDaEIsa0JBQWtCLEVBQ2xCLGtCQUFrQixFQUNsQixhQUFhLEVBQ2IsY0FBYyxFQUNkLG1CQUFtQixFQUNuQixlQUFlLEVBQ2Ysa0JBQWtCLEVBQ2xCLG9CQUFvQixFQUNwQix3QkFBd0IsRUFDeEIsY0FBYyxFQUNkLGVBQWUsRUFDZixlQUFlLEVBQ2YsYUFBYSxFQUNiLGdCQUFnQixFQUNoQixjQUFjLEVBQ2QsYUFBYSxFQUNiLGdCQUFnQixFQUNqQixNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDOUQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9D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UUFDZCxlQUFlO1FBQ2YsZUFBZTtRQUNmLHlCQUF5QixDQUFDLE9BQU8sQ0FBQztZQUNoQyxpQkFBaUIsRUFBRSxLQUFLO1lBQ3hCLHFCQUFxQixFQUFFLElBQUk7WUFDM0Isa0JBQWtCLEVBQUU7Z0JBQ2xCLFlBQVksRUFBRSxJQUFJO2dCQUNsQixZQUFZLEVBQUUsRUFBRTthQUNqQjtZQUNELDRCQUE0QixFQUFFLElBQUk7U0FDbkMsQ0FBQztLQUNILENBQUM7SUF1UEosb0JBQUM7Q0FBQSxBQXBURCxJQW9UQztTQXBUWSxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU1BBQ0UgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IERlYnVnRWxlbWVudCwgUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbXBvbmVudEZpeHR1cmUsIGdldFRlc3RCZWQsIFRlc3RCZWQsIHRpY2sgfSBmcm9tICdAYW5ndWxhci9jb3JlL3Rlc3RpbmcnO1xuaW1wb3J0IHsgRmxleExheW91dE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2ZsZXgtbGF5b3V0JztcbmltcG9ydCB7IEZvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgTWF0QXV0b2NvbXBsZXRlTW9kdWxlLFxuICBNYXRCYWRnZU1vZHVsZSxcbiAgTWF0QnV0dG9uTW9kdWxlLFxuICBNYXRDYXJkTW9kdWxlLFxuICBNYXRDaGVja2JveE1vZHVsZSxcbiAgTWF0Q2hpcHNNb2R1bGUsXG4gIE1hdENvbW1vbk1vZHVsZSxcbiAgTWF0RGF0ZXBpY2tlck1vZHVsZSxcbiAgTWF0RGl2aWRlck1vZHVsZSxcbiAgTWF0RXhwYW5zaW9uTW9kdWxlLFxuICBNYXRGb3JtRmllbGRNb2R1bGUsXG4gIE1hdEljb25Nb2R1bGUsXG4gIE1hdElucHV0TW9kdWxlLFxuICBNYXROYXRpdmVEYXRlTW9kdWxlLFxuICBNYXRPcHRpb25Nb2R1bGUsXG4gIE1hdFBhZ2luYXRvck1vZHVsZSxcbiAgTWF0UHJvZ3Jlc3NCYXJNb2R1bGUsXG4gIE1hdFByb2dyZXNzU3Bpbm5lck1vZHVsZSxcbiAgTWF0UmFkaW9Nb2R1bGUsXG4gIE1hdFNlbGVjdE1vZHVsZSxcbiAgTWF0U2xpZGVyTW9kdWxlLFxuICBNYXRTb3J0TW9kdWxlLFxuICBNYXRTdGVwcGVyTW9kdWxlLFxuICBNYXRUYWJsZU1vZHVsZSxcbiAgTWF0VGFic01vZHVsZSxcbiAgTWF0VG9vbHRpcE1vZHVsZVxufSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbCc7XG5pbXBvcnQgeyBCcm93c2VyTW9kdWxlLCBCeSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgTm9vcEFuaW1hdGlvbnNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEx1eEFjdGlvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2x1eC1hY3Rpb24vbHV4LWFjdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHsgTHV4RGlyZWN0aXZlc01vZHVsZSB9IGZyb20gJy4uLy4uL2x1eC1kaXJlY3RpdmVzL2x1eC1kaXJlY3RpdmVzLm1vZHVsZSc7XG5pbXBvcnQgeyBMdXhGb3JtTW9kdWxlIH0gZnJvbSAnLi4vLi4vbHV4LWZvcm0vbHV4LWZvcm0ubW9kdWxlJztcbmltcG9ydCB7IEx1eEljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9sdXgtaWNvbi9sdXgtaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgTHV4TGF5b3V0TW9kdWxlIH0gZnJvbSAnLi4vLi4vbHV4LWxheW91dC9sdXgtbGF5b3V0Lm1vZHVsZSc7XG5pbXBvcnQgeyBMdXhQaXBlc01vZHVsZSB9IGZyb20gJy4uLy4uL2x1eC1waXBlcy9sdXgtcGlwZXMubW9kdWxlJztcbmltcG9ydCB7IEx1eExvb2t1cE1vZHVsZSB9IGZyb20gJy4uLy4uL2x1eC1sb29rdXAvbHV4LWxvb2t1cC5tb2R1bGUnO1xuaW1wb3J0IHsgUm91dGVyVGVzdGluZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlci90ZXN0aW5nJztcbmltcG9ydCB7IEx1eENvbXBvbmVudHNDb25maWdNb2R1bGUgfSBmcm9tICcuLi8uLi9sdXgtY29tcG9uZW50cy1jb25maWcvbHV4LWNvbXBvbmVudHMtY29uZmlnLm1vZHVsZSc7XG4vLyBXaWNodGlnLCBkYW1pdCBkaWUgVGVzdGhlbHBlci1GdW5rdGlvbiBcImNvbmZpZ3VyZVRlc3RTdWl0ZVwiIGZ1bmt0aW9uaWVydCAoZGFyZiBuaWNodCB3ZWdmb3JtYXRpZXJ0IHdlcmRlbikuXG4vLyBpbXBvcnQgJ2phc21pbmUnIGhhdCBsZWlkZXIgbmljaHQgZGVuIGdld8O8bnNjaHRlbiBFZmZla3QuXG4vLyBpbXBvcnQge30gZnJvbSAnamFzbWluZSc7XG4vLyBub2luc3BlY3Rpb24gRVM2VW51c2VkSW1wb3J0c1xuaW1wb3J0IHt9IGZyb20gJ2phc21pbmUnO1xuaW1wb3J0IHsgTHV4RXJyb3JNb2R1bGUgfSBmcm9tICcuLi8uLi9sdXgtZXJyb3IvbHV4LWVycm9yLm1vZHVsZSc7XG5pbXBvcnQgeyBMdXhDb21tb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9sdXgtY29tbW9uL2x1eC1jb21tb24ubW9kdWxlJztcbmltcG9ydCB7IEx1eFBvcHVwc01vZHVsZSB9IGZyb20gJy4uLy4uL2x1eC1wb3B1cHMvbHV4LXBvcHVwcy5tb2R1bGUnO1xuXG5leHBvcnQgY2xhc3MgTHV4VGVzdEhlbHBlciB7XG4gIHB1YmxpYyBzdGF0aWMgQ09NTU9OX0FOR1VMQVJfTU9EVUxFUzogYW55W10gPSBbXG4gICAgTm9vcEFuaW1hdGlvbnNNb2R1bGUsXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIFJvdXRlck1vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgIEZsZXhMYXlvdXRNb2R1bGUsXG4gICAgQnJvd3Nlck1vZHVsZSxcbiAgICBSb3V0ZXJUZXN0aW5nTW9kdWxlXG4gIF07XG5cbiAgcHVibGljIHN0YXRpYyBNQVRFUklBTF9NT0RVTEVTOiBhbnlbXSA9IFtcbiAgICBNYXRCdXR0b25Nb2R1bGUsXG4gICAgTWF0Q2FyZE1vZHVsZSxcbiAgICBNYXRJY29uTW9kdWxlLFxuICAgIE1hdEZvcm1GaWVsZE1vZHVsZSxcbiAgICBNYXRUYWJzTW9kdWxlLFxuICAgIE1hdFRvb2x0aXBNb2R1bGUsXG4gICAgTWF0Q2hpcHNNb2R1bGUsXG4gICAgTWF0UHJvZ3Jlc3NTcGlubmVyTW9kdWxlLFxuICAgIE1hdFByb2dyZXNzQmFyTW9kdWxlLFxuICAgIE1hdEV4cGFuc2lvbk1vZHVsZSxcbiAgICBNYXRTdGVwcGVyTW9kdWxlLFxuICAgIE1hdFRhYmxlTW9kdWxlLFxuICAgIE1hdFBhZ2luYXRvck1vZHVsZSxcbiAgICBNYXRTb3J0TW9kdWxlLFxuICAgIE1hdERpdmlkZXJNb2R1bGUsXG4gICAgTWF0U2VsZWN0TW9kdWxlLFxuICAgIE1hdElucHV0TW9kdWxlLFxuICAgIE1hdENoZWNrYm94TW9kdWxlLFxuICAgIE1hdFJhZGlvTW9kdWxlLFxuICAgIE1hdERhdGVwaWNrZXJNb2R1bGUsXG4gICAgTWF0TmF0aXZlRGF0ZU1vZHVsZSxcbiAgICBNYXRBdXRvY29tcGxldGVNb2R1bGUsXG4gICAgTWF0U2xpZGVyTW9kdWxlLFxuICAgIE1hdE9wdGlvbk1vZHVsZSxcbiAgICBNYXRDb21tb25Nb2R1bGUsXG4gICAgTWF0QmFkZ2VNb2R1bGVcbiAgXTtcblxuICBwdWJsaWMgc3RhdGljIExVWF9NT0RVTEVTOiBhbnlbXSA9IFtcbiAgICBMdXhGb3JtTW9kdWxlLFxuICAgIEx1eExheW91dE1vZHVsZSxcbiAgICBMdXhBY3Rpb25Nb2R1bGUsXG4gICAgTHV4RGlyZWN0aXZlc01vZHVsZSxcbiAgICBMdXhQaXBlc01vZHVsZSxcbiAgICBMdXhJY29uTW9kdWxlLFxuICAgIEx1eExvb2t1cE1vZHVsZSxcbiAgICBMdXhFcnJvck1vZHVsZSxcbiAgICBMdXhDb21tb25Nb2R1bGUsXG4gICAgTHV4UG9wdXBzTW9kdWxlLFxuICAgIEx1eENvbXBvbmVudHNDb25maWdNb2R1bGUuZm9yUm9vdCh7XG4gICAgICBnZW5lcmF0ZUx1eFRhZ0lkczogZmFsc2UsXG4gICAgICBkaXNwbGF5THV4Q29uc29sZUxvZ3M6IHRydWUsXG4gICAgICBsYWJlbENvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgYWxsVXBwZXJjYXNlOiB0cnVlLFxuICAgICAgICBub3RBcHBsaWVkVG86IFtdXG4gICAgICB9LFxuICAgICAgY2FyZEV4cGFuc2lvbkFuaW1hdGlvbkFjdGl2ZTogdHJ1ZVxuICAgIH0pXG4gIF07XG5cbiAgLyoqXG4gICAqIFdpY2h0aWc6IGF1cyBmYWtlQXN5bmMtQmxvY2sgaGVyYXVzIGF1ZnJ1ZmVuLCBkYSBoaWVyIHRpY2soKSBnZW51dHp0IHdpcmQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNldElucHV0VmFsdWUoaW5wdXQ6IGFueSwgdmFsdWU6IGFueSwgZml4dHVyZTogYW55KSB7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChMdXhUZXN0SGVscGVyLmNyZWF0ZUZha2VFdmVudCgnaW5wdXQnKSk7XG4gICAgICBMdXhUZXN0SGVscGVyLndhaXQoZml4dHVyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VOSVQtVEVTVCBGRUhMRVI6IGlucHV0IGlzdCBuaWNodCBkZWZpbmllcnQuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdpY2h0aWc6IGF1cyBmYWtlQXN5bmMtQmxvY2sgaGVyYXVzIGF1ZnJ1ZmVuLCBkYSBoaWVyIHRpY2soKSBnZW51dHp0IHdpcmQuXG4gICAqIFdhcnRldCBhc3luY2hyb25lIEF1ZnJ1ZmUgYWIgdW5kIHJ1ZnQgZGllIENoYW5nZURldGVjdGlvbiBhdWZcbiAgICogQHBhcmFtIGZpeHR1cmVcbiAgICogQHBhcmFtIHRpY2tEdXJhdGlvblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB3YWl0KGZpeHR1cmU6IGFueSwgdGlja0R1cmF0aW9uPzogbnVtYmVyKSB7XG4gICAgZml4dHVyZS5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgdGljayh0aWNrRHVyYXRpb24pO1xuICAgIGZpeHR1cmUuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdpY2h0aWc6IGF1cyBmYWtlQXN5bmMtQmxvY2sgaGVyYXVzIGF1ZnJ1ZmVuLCBkYSBoaWVyIHRpY2soKSBnZW51dHp0IHdpcmQuXG4gICAqIFNlbmRldCBlaW4gS2xpY2stRXZlbnQgYWIgdW5kIHdhcnRldCBkYW5uLlxuICAgKiBAcGFyYW0gZml4dHVyZVxuICAgKiBAcGFyYW0gRGVidWdFbGVtZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNsaWNrKGZpeHR1cmU6IGFueSwgZGVidWdFbGVtZW50OiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICBkZWJ1Z0VsZW1lbnQudHJpZ2dlckV2ZW50SGFuZGxlcignY2xpY2snLCBudWxsKTtcbiAgICBMdXhUZXN0SGVscGVyLndhaXQoZml4dHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogV2ljaHRpZzogYXVzIGZha2VBc3luYy1CbG9jayBoZXJhdXMgYXVmcnVmZW4sIGRhIGhpZXIgdGljaygpIGdlbnV0enQgd2lyZC5cbiAgICogU2VuZGV0IGVpbiBDaGFuZ2UtRXZlbnQgYWIgdW5kIHdhcnRldCBkYW5uLlxuICAgKiBAcGFyYW0gZml4dHVyZVxuICAgKiBAcGFyYW0gRGVidWdFbGVtZW50XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJhZGlvQnV0dG9uQ2hhbmdlKGZpeHR1cmU6IGFueSwgcmFkaW9CdXR0b246IERlYnVnRWxlbWVudCkge1xuICAgIHJhZGlvQnV0dG9uLm5hdGl2ZUVsZW1lbnQuZGlzcGF0Y2hFdmVudChMdXhUZXN0SGVscGVyLmNyZWF0ZUZha2VFdmVudCgnY2hhbmdlJykpO1xuICAgIEx1eFRlc3RIZWxwZXIud2FpdChmaXh0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcnN0ZWxsdCBlaW5lIENvbXBvbmVudEZpeHR1cmUgZnVlciBkaWUgbWl0Z2VnZWJlbmUgS29tcG9uZW50ZSwgb3B0aW9uYWwgaXN0IGVzIG1vZWdsaWNoXG4gICAqIHdlaXRlcmUgUHJvdmlkZXIgdW5kIERlY2xhcmF0aW9ucyBlaW56dXRyYWdlbi4gRGllc2Ugd2VyZGVuIGRhbm4gaW0gVGVzdG1vZHVsIGVpbmdldHJhZ2VuLlxuICAgKiBAcGFyYW0gY29tcG9uZW50XG4gICAqIEBwYXJhbSBwcm92aWRlcnNcbiAgICogQHBhcmFtIGRlY2xhcmF0aW9uc1xuICAgKiBAZGVwcmVjYXRlZCBTdGF0dGRlc3NlbiBjb25maWd1cmVUZXN0TW9kdWxlIGluIEtvbWJpbmF0aW9uIG1pdCBjb25maWd1cmVUZXN0U3VpdGUgdmVyd2VuZGVuIC0tPiBlcmhlYmxpY2ggcGVyZm9ybWFudGVyXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUNvbXBvbmVudChcbiAgICBjb21wb25lbnQ6IGFueSxcbiAgICBwcm92aWRlcnM6IFByb3ZpZGVyW10gPSBbXSxcbiAgICBkZWNsYXJhdGlvbnM6IGFueVtdID0gW11cbiAgKTogQ29tcG9uZW50Rml4dHVyZTxhbnk+IHtcbiAgICBUZXN0QmVkLmNvbmZpZ3VyZVRlc3RpbmdNb2R1bGUoe1xuICAgICAgaW1wb3J0czogW1xuICAgICAgICAuLi5MdXhUZXN0SGVscGVyLkNPTU1PTl9BTkdVTEFSX01PRFVMRVMsXG4gICAgICAgIC4uLkx1eFRlc3RIZWxwZXIuTUFURVJJQUxfTU9EVUxFUyxcbiAgICAgICAgLi4uTHV4VGVzdEhlbHBlci5MVVhfTU9EVUxFU1xuICAgICAgXSxcbiAgICAgIGRlY2xhcmF0aW9uczogWy4uLmRlY2xhcmF0aW9ucywgY29tcG9uZW50XSxcbiAgICAgIHByb3ZpZGVyczogWy4uLnByb3ZpZGVyc11cbiAgICB9KTtcblxuICAgIFRlc3RCZWQuY29tcGlsZUNvbXBvbmVudHMoKTtcblxuICAgIHJldHVybiBUZXN0QmVkLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnQpO1xuICB9XG5cbiAgLyoqIFV0aWxpdHkgdG8gZGlzcGF0Y2ggYW55IGV2ZW50IG9uIGEgTm9kZS4gKi9cbiAgcHVibGljIHN0YXRpYyBkaXNwYXRjaEV2ZW50KG5vZGU6IE5vZGUgfCBXaW5kb3csIGV2ZW50OiBFdmVudCk6IEV2ZW50IHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIC8qKiBTaG9ydGhhbmQgdG8gZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IG9uIGEgc3BlY2lmaWVkIG5vZGUuICovXG4gIHB1YmxpYyBzdGF0aWMgZGlzcGF0Y2hGYWtlRXZlbnQobm9kZTogTm9kZSB8IFdpbmRvdywgdHlwZTogc3RyaW5nLCBjYW5CdWJibGU/OiBib29sZWFuKTogRXZlbnQge1xuICAgIHJldHVybiBMdXhUZXN0SGVscGVyLmRpc3BhdGNoRXZlbnQobm9kZSwgTHV4VGVzdEhlbHBlci5jcmVhdGVGYWtlRXZlbnQodHlwZSwgY2FuQnViYmxlKSk7XG4gIH1cblxuICAvKiogU2hvcnRoYW5kIHRvIGRpc3BhdGNoIGEga2V5Ym9hcmQgZXZlbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgY29kZS4gKi9cbiAgcHVibGljIHN0YXRpYyBkaXNwYXRjaEtleWJvYXJkRXZlbnQobm9kZTogTm9kZSwgdHlwZTogc3RyaW5nLCBrZXlDb2RlOiBudW1iZXIsIHRhcmdldD86IEVsZW1lbnQpOiBLZXlib2FyZEV2ZW50IHtcbiAgICByZXR1cm4gTHV4VGVzdEhlbHBlci5kaXNwYXRjaEV2ZW50KG5vZGUsIEx1eFRlc3RIZWxwZXIuY3JlYXRlS2V5Ym9hcmRFdmVudCh0eXBlLCBrZXlDb2RlLCB0YXJnZXQpKSBhcyBLZXlib2FyZEV2ZW50O1xuICB9XG5cbiAgLyoqIEZvY3VzZXMgYW4gaW5wdXQgYW5kIHNldHMgaXRzIHZhbHVlLiBEaXNwYXRjaGVzIGFuIGZha2UgaW5wdXQgZXZlbnQgYWZ0ZXJ3YXJkcy4gKi9cbiAgcHVibGljIHN0YXRpYyB0eXBlSW5FbGVtZW50KGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQsIHZhbHVlOiBzdHJpbmcsIG5vSW5wdXRFdmVudD86IGJvb2xlYW4pIHtcbiAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xuICAgIGlmICghbm9JbnB1dEV2ZW50KSB7XG4gICAgICBMdXhUZXN0SGVscGVyLmRpc3BhdGNoRmFrZUV2ZW50KGVsZW1lbnQsICdpbnB1dCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBTdGV1ZXJ1bmcgdW5kIHRyaWdnZXJuIHZvbiBPdmVybGF5cyBpbXBsZW1lbnRpZXJlbiAqKi9cblxuICAvKipcbiAgICogSW5zZXJ0cyBkYXRhIGludG8gYW4gaW5wdXQgZmllbGQsIHRoYXQgaGFzIHRvIHVwZGF0ZSBhc3luY2hyb3Vub3MgYmVmb3JlIGNhbGxpbmcgYSBjYWxsYmFjay1mdW5jdGlvblxuICAgKiBBbGxvd3MgdG8gdXNlIFJ4SnMgSW50ZXJ2YWwtVGltZXJzIHdpdGhpbiB0aGUgVGFyZ2V0LUNvbXBvbmVudHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHR5cGVJbkVsZW1lbnRBc3luY2godGV4dDogc3RyaW5nLCBmaXh0dXJlOiBDb21wb25lbnRGaXh0dXJlPGFueT4sIGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgZml4dHVyZS53aGVuU3RhYmxlKCkudGhlbigoKSA9PiB7XG4gICAgICBMdXhUZXN0SGVscGVyLnR5cGVJbkVsZW1lbnQoZWxlbWVudCwgdGV4dCk7XG4gICAgICBmaXh0dXJlLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgZml4dHVyZS53aGVuU3RhYmxlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIEx1eFRlc3RIZWxwZXIuZGlzcGF0Y2hLZXlib2FyZEV2ZW50KGVsZW1lbnQsICdrZXlkb3duJywgU1BBQ0UpO1xuICAgICAgICBmaXh0dXJlLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgICBmaXh0dXJlLndoZW5TdGFibGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIERpc3BhdGNoZXMgYSBrZXlkb3duIGV2ZW50IGZyb20gYW4gZWxlbWVudC4gKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVLZXlib2FyZEV2ZW50KHR5cGU6IHN0cmluZywga2V5Q29kZTogbnVtYmVyLCB0YXJnZXQ/OiBFbGVtZW50LCBrZXk/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdLZXlib2FyZEV2ZW50JykgYXMgYW55O1xuICAgIC8vIEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBgaW5pdEtleWJvYXJkRXZlbnRgLCBidXQgc3VwcG9ydHMgYGluaXRLZXlFdmVudGAuXG4gICAgY29uc3QgaW5pdEV2ZW50Rm4gPSAoZXZlbnQuaW5pdEtleUV2ZW50IHx8IGV2ZW50LmluaXRLZXlib2FyZEV2ZW50KS5iaW5kKGV2ZW50KTtcbiAgICBjb25zdCBvcmlnaW5hbFByZXZlbnREZWZhdWx0ID0gZXZlbnQucHJldmVudERlZmF1bHQ7XG5cbiAgICBpbml0RXZlbnRGbih0eXBlLCB0cnVlLCB0cnVlLCB3aW5kb3csIDAsIDAsIDAsIDAsIDAsIGtleUNvZGUpO1xuXG4gICAgLy8gV2Via2l0IEJyb3dzZXJzIGRvbid0IHNldCB0aGUga2V5Q29kZSB3aGVuIGNhbGxpbmcgdGhlIGluaXQgZnVuY3Rpb24uXG4gICAgLy8gU2VlIHJlbGF0ZWQgYnVnIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjczNVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV2ZW50LCB7XG4gICAgICBrZXlDb2RlOiB7IGdldDogKCkgPT4ga2V5Q29kZSB9LFxuICAgICAga2V5OiB7IGdldDogKCkgPT4ga2V5IH0sXG4gICAgICB0YXJnZXQ6IHsgZ2V0OiAoKSA9PiB0YXJnZXQgfVxuICAgIH0pO1xuXG4gICAgLy8gSUUgd29uJ3Qgc2V0IGBkZWZhdWx0UHJldmVudGVkYCBvbiBzeW50aGV0aWMgZXZlbnRzIHNvIHdlIG5lZWQgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ2RlZmF1bHRQcmV2ZW50ZWQnLCB7IGdldDogKCkgPT4gdHJ1ZSB9KTtcbiAgICAgIHJldHVybiBvcmlnaW5hbFByZXZlbnREZWZhdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIC8qKiBDcmVhdGVzIGEgZmFrZSBldmVudCBvYmplY3Qgd2l0aCBhbnkgZGVzaXJlZCBldmVudCB0eXBlLiAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZUZha2VFdmVudCh0eXBlOiBzdHJpbmcsIGNhbkJ1YmJsZSA9IGZhbHNlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xuICAgIGxldCBldmVudDtcbiAgICBpZiAodHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldmVudCA9IG5ldyBFdmVudCh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2ZW50LmluaXRFdmVudCh0eXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxla3RpZXJ0IGVpbiBFbGVtZW50IGFuaGFuZCBkZXIgUXVlcnkgdm9uIGRlbSBGaXh0dXJlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNlbGVjdE9uZUZyb21GaXh0dXJlKGZpeHR1cmU6IENvbXBvbmVudEZpeHR1cmU8YW55PiwgcXVlcnk6IHN0cmluZyk6IERlYnVnRWxlbWVudCB7XG4gICAgcmV0dXJuIGZpeHR1cmUuZGVidWdFbGVtZW50LnF1ZXJ5KEJ5LmNzcyhxdWVyeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVrdGllcnQgZWluIEFycmF5IHZvbiBFbGVtZW50ZW4gYW5oYW5kIGRlciBRdWVyeSB2b24gZGVtIEZpeHR1cmVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2VsZWN0QWxsRnJvbUZpeHR1cmUoZml4dHVyZTogQ29tcG9uZW50Rml4dHVyZTxhbnk+LCBxdWVyeTogc3RyaW5nKTogRGVidWdFbGVtZW50W10ge1xuICAgIHJldHVybiBmaXh0dXJlLmRlYnVnRWxlbWVudC5xdWVyeUFsbChCeS5jc3MocXVlcnkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnRmZXJudCBuaWNodC1BU0NJSS1DaGFycyBhdXMgZGVtIFN0cmluZyAoQmVpbSBJRSB3aWNodGlnLCBkaWVzZXIgZsO8Z3QgZ2VybmUgdmVyc3RlY2t0ZSBTdGV1ZXJ6ZWljaGVuXG4gICAqIGluIElucHV0LUZlbGRlcm4gYW4gZGllIFN0cmluZ3MpLlxuICAgKiBAcGFyYW0gZGF0ZVN0cmluZ1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzdHJpbmdXaXRob3V0QVNDSUlDaGFycyhkYXRlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGV4cCA9IG5ldyBSZWdFeHAoJ1teQS1aYS16IDAtOSBcXFxcLixcXFxcP1wiXCIhQCNcXFxcJCVcXFxcXiZcXFxcKlxcXFwoXFxcXCktXz1cXFxcKzs6PD5cXFxcL1xcXFxcXFxcXFxcXHxcXFxcfVxcXFx7XFxcXFtcXFxcXWB+XSonLCAnZycpO1xuICAgIHJldHVybiBkYXRlU3RyaW5nLnJlcGxhY2UoZXhwLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogIERlYWt0aXZpZXJ0IGRlbiBSZXNldCBkZXMgVGVzdG1vZHVscyBhbSBFbmRlIGVpbmVzIFRlc3RkdXJjaGxhdWZzLlxuICAgKiAgVmVyYmVzc2VydCBkaWUgUGVyZm9ybWFuY2UgZGVyIEthcm1hLVRlc3RzIGVyaGVibGljaC5cbiAgICogIEFtIEVuZGUgZGVyIFRlc3RzdWl0ZSB3aXJkIGRpZXNlIEZ1bmt0aW9uIHdpZWRlciBha3RpdmllcnQuXG4gICAqXG4gICAqICBGdW5rdGlvbiBkYWbDvHIgZWluZmFjaCBhbSBBbmZhbmcgZWluZXIgVGVzdHN1aXRlIChlcnN0ZXMgZGVzY3JpYmUpIGF1ZnJ1ZmVuIHVuZCBpbiBlaW5lbSBiZWZvcmVBbGwgZGFzIFRlc3Rtb2R1bFxuICAgKiAgZXJ6ZXVnZW4uIERpZXNlcyB3aXJkIG51biBuaWNodCBtZWhyIG5hY2ggamVkZW0gVGVzdCBuZXUgZXJ6ZXVndC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY29uZmlndXJlVGVzdFN1aXRlKCkge1xuICAgIGNvbnN0IHRlc3RCZWRBcGk6IGFueSA9IGdldFRlc3RCZWQoKTtcbiAgICBjb25zdCBvcmlnaW5SZXNldCA9IFRlc3RCZWQucmVzZXRUZXN0aW5nTW9kdWxlO1xuXG4gICAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAgIFRlc3RCZWQucmVzZXRUZXN0aW5nTW9kdWxlKCk7XG4gICAgICBUZXN0QmVkLnJlc2V0VGVzdGluZ01vZHVsZSA9ICgpID0+IFRlc3RCZWQ7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgdGVzdEJlZEFwaS5fYWN0aXZlRml4dHVyZXMuZm9yRWFjaCgoZml4dHVyZTogQ29tcG9uZW50Rml4dHVyZTxhbnk+KSA9PiBmaXh0dXJlLmRlc3Ryb3koKSk7XG4gICAgICB0ZXN0QmVkQXBpLl9pbnN0YW50aWF0ZWQgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIGFmdGVyQWxsKCgpID0+IHtcbiAgICAgIFRlc3RCZWQucmVzZXRUZXN0aW5nTW9kdWxlID0gb3JpZ2luUmVzZXQ7XG4gICAgICBUZXN0QmVkLnJlc2V0VGVzdGluZ01vZHVsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEtvbmZpZ3VyaWVydCBkYXMgVGVzdE1vZHVsIGbDvHIgZWluZSBUZXN0c3VpdGUsIGthbm4gZGFiZWkgUHJvdmlkZXIgdW5kIEtvbXBvbmVudGVuIChEZWtsYXJhdGlvbmVuKSBlbnRnZWdlbm5laG1lbi5cbiAgICogQHBhcmFtIHByb3ZpZGVyc1xuICAgKiBAcGFyYW0gZGVjbGFyYXRpb25zXG4gICAqIEBwYXJhbSBpbXBvcnRzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbmZpZ3VyZVRlc3RNb2R1bGUocHJvdmlkZXJzOiBQcm92aWRlcltdID0gW10sIGRlY2xhcmF0aW9uczogYW55W10gPSBbXSwgaW1wb3J0czogYW55W10gPSBbXSkge1xuICAgIFRlc3RCZWQuY29uZmlndXJlVGVzdGluZ01vZHVsZSh7XG4gICAgICBpbXBvcnRzOiBbXG4gICAgICAgIC4uLkx1eFRlc3RIZWxwZXIuQ09NTU9OX0FOR1VMQVJfTU9EVUxFUyxcbiAgICAgICAgLi4uTHV4VGVzdEhlbHBlci5NQVRFUklBTF9NT0RVTEVTLFxuICAgICAgICAuLi5MdXhUZXN0SGVscGVyLkxVWF9NT0RVTEVTLFxuICAgICAgICAuLi5pbXBvcnRzXG4gICAgICBdLFxuICAgICAgZGVjbGFyYXRpb25zOiBbLi4uZGVjbGFyYXRpb25zXSxcbiAgICAgIHByb3ZpZGVyczogWy4uLnByb3ZpZGVyc11cbiAgICB9KTtcblxuICAgIFRlc3RCZWQuY29tcGlsZUNvbXBvbmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcnN0ZWxsdCBlaW4gbGVlcmVzIEZpbGUtT2JqZWt0IG1pdCBOYW1lbiB1bmQgVHlwIHZpYSBCbG9iLUNvbnN0cnVjdG9yICh1bSBFZGdlL0lFLUZlaGxlciB6dSB2ZXJtZWlkZW4pLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gdHlwZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjcmVhdGVGaWxlQnJvd3NlclNhZmUobmFtZSwgdHlwZSkge1xuICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbJyddLCB7IHR5cGU6IHR5cGUgfSk7XG4gICAgZmlsZVsnbmFtZSddID0gbmFtZTtcblxuICAgIHJldHVybiA8RmlsZT5maWxlO1xuICB9XG59XG4iXX0=