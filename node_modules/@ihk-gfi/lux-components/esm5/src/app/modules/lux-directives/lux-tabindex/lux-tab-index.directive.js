import * as tslib_1 from "tslib";
import { AfterViewInit, Directive, ElementRef, Input, OnChanges, OnDestroy, Renderer2, SimpleChanges } from '@angular/core';
import { ReplaySubject } from 'rxjs';
var LuxTabIndexDirective = /** @class */ (function () {
    function LuxTabIndexDirective(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.changes$ = new ReplaySubject(1);
        this.luxTabIndex = '0';
        this.luxApplyToParent = false;
        this.luxApplyToChildren = true;
        this.luxPotentialChildren = ['input', 'textarea', 'a', 'button', 'mat-select'];
    }
    LuxTabIndexDirective.prototype.ngOnChanges = function (simpleChanges) {
        this.changes$.next(simpleChanges);
    };
    LuxTabIndexDirective.prototype.ngAfterViewInit = function () {
        this.updateElementsWithTabIndex();
        // Dadurch verhindern wir, dass Changes vor afterViewInit zu etwaigen Fehlern führen könnten und erst danach aufgelöst werden
        this.changesSubscription = this.changes$.subscribe(this.onChanges.bind(this));
    };
    LuxTabIndexDirective.prototype.ngOnDestroy = function () {
        if (this.changesSubscription) {
            this.changesSubscription.unsubscribe();
        }
    };
    /**
     * Eigener Listener für Änderungen, der erst nach dem AfterViewInit-Lifecycle greift.
     * Sicherheitshalber, um evtl. noch unaufgelösten Elementen zu entgehen.
     * @param simpleChanges
     */
    LuxTabIndexDirective.prototype.onChanges = function (simpleChanges) {
        if (simpleChanges.luxTabIndex) {
            this.updateElementsWithTabIndex();
        }
    };
    /**
     * Aktualisiert den Tabindex für
     *  - das Zielelement, wenn luxApplyToParent === true (default = false) ist
     *  - potentielle Kindelemente, wenn luxApplyToChildren === true (default) ist
     */
    LuxTabIndexDirective.prototype.updateElementsWithTabIndex = function () {
        var _this = this;
        if (this.luxApplyToParent) {
            this.setTabIndexForElement(this.elementRef.nativeElement);
        }
        if (this.luxApplyToChildren) {
            this.luxPotentialChildren.forEach(function (childQuery) { return _this.setTabIndexByQuery(childQuery); });
        }
    };
    LuxTabIndexDirective.prototype.setTabIndexByQuery = function (elementQuery) {
        var elements = this.elementRef.nativeElement.querySelectorAll(elementQuery);
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            this.setTabIndexForElement(element);
        }
    };
    LuxTabIndexDirective.prototype.setTabIndexForElement = function (element) {
        this.renderer.setAttribute(element, 'tabIndex', this.luxTabIndex);
    };
    LuxTabIndexDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], LuxTabIndexDirective.prototype, "luxTabIndex", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxTabIndexDirective.prototype, "luxApplyToParent", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], LuxTabIndexDirective.prototype, "luxApplyToChildren", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array)
    ], LuxTabIndexDirective.prototype, "luxPotentialChildren", void 0);
    LuxTabIndexDirective = tslib_1.__decorate([
        Directive({
            selector: '[luxTabIndex]'
        }),
        tslib_1.__metadata("design:paramtypes", [ElementRef, Renderer2])
    ], LuxTabIndexDirective);
    return LuxTabIndexDirective;
}());
export { LuxTabIndexDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHV4LXRhYi1pbmRleC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaWhrLWdmaS9sdXgtY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbInNyYy9hcHAvbW9kdWxlcy9sdXgtZGlyZWN0aXZlcy9sdXgtdGFiaW5kZXgvbHV4LXRhYi1pbmRleC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCxhQUFhLEVBQ2IsU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBQ0wsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsYUFBYSxFQUNkLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBS25EO0lBU0UsOEJBQW9CLFVBQXNCLEVBQVUsUUFBbUI7UUFBbkQsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUFVLGFBQVEsR0FBUixRQUFRLENBQVc7UUFQL0QsYUFBUSxHQUFpQyxJQUFJLGFBQWEsQ0FBZ0IsQ0FBQyxDQUFDLENBQUM7UUFFNUUsZ0JBQVcsR0FBVyxHQUFHLENBQUM7UUFDMUIscUJBQWdCLEdBQVksS0FBSyxDQUFDO1FBQ2xDLHVCQUFrQixHQUFZLElBQUksQ0FBQztRQUNuQyx5QkFBb0IsR0FBYSxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUVuQixDQUFDO0lBRTNFLDBDQUFXLEdBQVgsVUFBWSxhQUE0QjtRQUN0QyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsOENBQWUsR0FBZjtRQUNFLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDO1FBQ2xDLDZIQUE2SDtRQUM3SCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRUQsMENBQVcsR0FBWDtRQUNFLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFO1lBQzVCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN4QztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssd0NBQVMsR0FBakIsVUFBa0IsYUFBNEI7UUFDNUMsSUFBSSxhQUFhLENBQUMsV0FBVyxFQUFFO1lBQzdCLElBQUksQ0FBQywwQkFBMEIsRUFBRSxDQUFDO1NBQ25DO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyx5REFBMEIsR0FBbEM7UUFBQSxpQkFRQztRQVBDLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ3pCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzNEO1FBRUQsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDM0IsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxVQUFDLFVBQWtCLElBQUssT0FBQSxLQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLEVBQW5DLENBQW1DLENBQUMsQ0FBQztTQUNoRztJQUNILENBQUM7SUFFTyxpREFBa0IsR0FBMUIsVUFBMkIsWUFBb0I7UUFDN0MsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDOUUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsSUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNyQztJQUNILENBQUM7SUFFTyxvREFBcUIsR0FBN0IsVUFBOEIsT0FBb0I7UUFDaEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDcEUsQ0FBQzs7Z0JBdEQrQixVQUFVO2dCQUFvQixTQUFTOztJQUw5RDtRQUFSLEtBQUssRUFBRTs7NkRBQTJCO0lBQzFCO1FBQVIsS0FBSyxFQUFFOztrRUFBbUM7SUFDbEM7UUFBUixLQUFLLEVBQUU7O29FQUFvQztJQUNuQztRQUFSLEtBQUssRUFBRTs7c0VBQXFGO0lBUGxGLG9CQUFvQjtRQUhoQyxTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsZUFBZTtTQUMxQixDQUFDO2lEQVVnQyxVQUFVLEVBQW9CLFNBQVM7T0FUNUQsb0JBQW9CLENBZ0VoQztJQUFELDJCQUFDO0NBQUEsQUFoRUQsSUFnRUM7U0FoRVksb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlcGxheVN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbHV4VGFiSW5kZXhdJ1xufSlcbmV4cG9ydCBjbGFzcyBMdXhUYWJJbmRleERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBjaGFuZ2VzU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgY2hhbmdlcyQ6IFJlcGxheVN1YmplY3Q8U2ltcGxlQ2hhbmdlcz4gPSBuZXcgUmVwbGF5U3ViamVjdDxTaW1wbGVDaGFuZ2VzPigxKTtcblxuICBASW5wdXQoKSBsdXhUYWJJbmRleDogc3RyaW5nID0gJzAnO1xuICBASW5wdXQoKSBsdXhBcHBseVRvUGFyZW50OiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGx1eEFwcGx5VG9DaGlsZHJlbjogYm9vbGVhbiA9IHRydWU7XG4gIEBJbnB1dCgpIGx1eFBvdGVudGlhbENoaWxkcmVuOiBzdHJpbmdbXSA9IFsnaW5wdXQnLCAndGV4dGFyZWEnLCAnYScsICdidXR0b24nLCAnbWF0LXNlbGVjdCddO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIG5nT25DaGFuZ2VzKHNpbXBsZUNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICB0aGlzLmNoYW5nZXMkLm5leHQoc2ltcGxlQ2hhbmdlcyk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50c1dpdGhUYWJJbmRleCgpO1xuICAgIC8vIERhZHVyY2ggdmVyaGluZGVybiB3aXIsIGRhc3MgQ2hhbmdlcyB2b3IgYWZ0ZXJWaWV3SW5pdCB6dSBldHdhaWdlbiBGZWhsZXJuIGbDvGhyZW4ga8O2bm50ZW4gdW5kIGVyc3QgZGFuYWNoIGF1ZmdlbMO2c3Qgd2VyZGVuXG4gICAgdGhpcy5jaGFuZ2VzU3Vic2NyaXB0aW9uID0gdGhpcy5jaGFuZ2VzJC5zdWJzY3JpYmUodGhpcy5vbkNoYW5nZXMuYmluZCh0aGlzKSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jaGFuZ2VzU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmNoYW5nZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRWlnZW5lciBMaXN0ZW5lciBmw7xyIMOEbmRlcnVuZ2VuLCBkZXIgZXJzdCBuYWNoIGRlbSBBZnRlclZpZXdJbml0LUxpZmVjeWNsZSBncmVpZnQuXG4gICAqIFNpY2hlcmhlaXRzaGFsYmVyLCB1bSBldnRsLiBub2NoIHVuYXVmZ2Vsw7ZzdGVuIEVsZW1lbnRlbiB6dSBlbnRnZWhlbi5cbiAgICogQHBhcmFtIHNpbXBsZUNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgb25DaGFuZ2VzKHNpbXBsZUNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoc2ltcGxlQ2hhbmdlcy5sdXhUYWJJbmRleCkge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50c1dpdGhUYWJJbmRleCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBa3R1YWxpc2llcnQgZGVuIFRhYmluZGV4IGbDvHJcbiAgICogIC0gZGFzIFppZWxlbGVtZW50LCB3ZW5uIGx1eEFwcGx5VG9QYXJlbnQgPT09IHRydWUgKGRlZmF1bHQgPSBmYWxzZSkgaXN0XG4gICAqICAtIHBvdGVudGllbGxlIEtpbmRlbGVtZW50ZSwgd2VubiBsdXhBcHBseVRvQ2hpbGRyZW4gPT09IHRydWUgKGRlZmF1bHQpIGlzdFxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVFbGVtZW50c1dpdGhUYWJJbmRleCgpIHtcbiAgICBpZiAodGhpcy5sdXhBcHBseVRvUGFyZW50KSB7XG4gICAgICB0aGlzLnNldFRhYkluZGV4Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubHV4QXBwbHlUb0NoaWxkcmVuKSB7XG4gICAgICB0aGlzLmx1eFBvdGVudGlhbENoaWxkcmVuLmZvckVhY2goKGNoaWxkUXVlcnk6IHN0cmluZykgPT4gdGhpcy5zZXRUYWJJbmRleEJ5UXVlcnkoY2hpbGRRdWVyeSkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0VGFiSW5kZXhCeVF1ZXJ5KGVsZW1lbnRRdWVyeTogc3RyaW5nKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRRdWVyeSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgdGhpcy5zZXRUYWJJbmRleEZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRUYWJJbmRleEZvckVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbGVtZW50LCAndGFiSW5kZXgnLCB0aGlzLmx1eFRhYkluZGV4KTtcbiAgfVxufVxuIl19